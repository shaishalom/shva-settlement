

file Read:C:\Users\AP068\git\documentum\duecmcustomerwrappers\.git\config
-----------------------------------------------------
[core]
	repositoryformatversion = 0
	filemode = false
	bare = false
	logallrefupdates = true
	symlinks = false
	ignorecase = true
[remote "origin"]
	url = ssh://git@gitlab.devops.poalim.bank:31007/m28008doc/duecmcustomerwrappers.git
	fetch = +refs/heads/*:refs/remotes/origin/*
[branch "master"]
	remote = origin
	merge = refs/heads/master


file Read:C:\Users\AP068\git\documentum\duecmcustomerwrappers\.git\hooks\applypatch-msg.sample
-----------------------------------------------------
#!/bin/sh
#
# An example hook script to check the commit log message taken by
# applypatch from an e-mail message.
#
# The hook should exit with non-zero status after issuing an
# appropriate message if it wants to stop the commit.  The hook is
# allowed to edit the commit message file.
#
# To enable this hook, rename this file to "applypatch-msg".

. git-sh-setup
commitmsg="$(git rev-parse --git-path hooks/commit-msg)"
test -x "$commitmsg" && exec "$commitmsg" ${1+"$@"}
:


file Read:C:\Users\AP068\git\documentum\duecmcustomerwrappers\.git\hooks\commit-msg.sample
-----------------------------------------------------
#!/bin/sh
#
# An example hook script to check the commit log message.
# Called by "git commit" with one argument, the name of the file
# that has the commit message.  The hook should exit with non-zero
# status after issuing an appropriate message if it wants to stop the
# commit.  The hook is allowed to edit the commit message file.
#
# To enable this hook, rename this file to "commit-msg".

# Uncomment the below to add a Signed-off-by line to the message.
# Doing this in a hook is a bad idea in general, but the prepare-commit-msg
# hook is more suited to it.
#
# SOB=$(git var GIT_AUTHOR_IDENT | sed -n 's/^\(.*>\).*$/Signed-off-by: \1/p')
# grep -qs "^$SOB" "$1" || echo "$SOB" >> "$1"

# This example catches duplicate Signed-off-by lines.

test "" = "$(grep '^Signed-off-by: ' "$1" |
	 sort | uniq -c | sed -e '/^[ 	]*1[ 	]/d')" || {
	echo >&2 Duplicate Signed-off-by lines.
	exit 1
}


file Read:C:\Users\AP068\git\documentum\duecmcustomerwrappers\.git\hooks\fsmonitor-watchman.sample
-----------------------------------------------------
#!/usr/bin/perl

use strict;
use warnings;
use IPC::Open2;

# An example hook script to integrate Watchman
# (https://facebook.github.io/watchman/) with git to speed up detecting
# new and modified files.
#
# The hook is passed a version (currently 1) and a time in nanoseconds
# formatted as a string and outputs to stdout all files that have been
# modified since the given time. Paths must be relative to the root of
# the working tree and separated by a single NUL.
#
# To enable this hook, rename this file to "query-watchman" and set
# 'git config core.fsmonitor .git/hooks/query-watchman'
#
my ($version, $time) = @ARGV;

# Check the hook interface version

if ($version == 1) {
	# convert nanoseconds to seconds
	$time = int $time / 1000000000;
} else {
	die "Unsupported query-fsmonitor hook version '$version'.\n" .
	    "Falling back to scanning...\n";
}

my $git_work_tree;
if ($^O =~ 'msys' || $^O =~ 'cygwin') {
	$git_work_tree = Win32::GetCwd();
	$git_work_tree =~ tr/\\/\//;
} else {
	require Cwd;
	$git_work_tree = Cwd::cwd();
}

my $retry = 1;

launch_watchman();

sub launch_watchman {

	my $pid = open2(\*CHLD_OUT, \*CHLD_IN, 'watchman -j --no-pretty')
	    or die "open2() failed: $!\n" .
	    "Falling back to scanning...\n";

	# In the query expression below we're asking for names of files that
	# changed since $time but were not transient (ie created after
	# $time but no longer exist).
	#
	# To accomplish this, we're using the "since" generator to use the
	# recency index to select candidate nodes and "fields" to limit the
	# output to file names only. Then we're using the "expression" term to
	# further constrain the results.
	#
	# The category of transient files that we want to ignore will have a
	# creation clock (cclock) newer than $time_t value and will also not
	# currently exist.

	my $query = <<"	END";
		["query", "$git_work_tree", {
			"since": $time,
			"fields": ["name"],
			"expression": ["not", ["allof", ["since", $time, "cclock"], ["not", "exists"]]]
		}]
	END

	print CHLD_IN $query;
	close CHLD_IN;
	my $response = do {local $/; <CHLD_OUT>};

	die "Watchman: command returned no output.\n" .
	    "Falling back to scanning...\n" if $response eq "";
	die "Watchman: command returned invalid output: $response\n" .
	    "Falling back to scanning...\n" unless $response =~ /^\{/;

	my $json_pkg;
	eval {
		require JSON::XS;
		$json_pkg = "JSON::XS";
		1;
	} or do {
		require JSON::PP;
		$json_pkg = "JSON::PP";
	};

	my $o = $json_pkg->new->utf8->decode($response);

	if ($retry > 0 and $o->{error} and $o->{error} =~ m/unable to resolve root .* directory (.*) is not watched/) {
		print STDERR "Adding '$git_work_tree' to watchman's watch list.\n";
		$retry--;
		qx/watchman watch "$git_work_tree"/;
		die "Failed to make watchman watch '$git_work_tree'.\n" .
		    "Falling back to scanning...\n" if $? != 0;

		# Watchman will always return all files on the first query so
		# return the fast "everything is dirty" flag to git and do the
		# Watchman query just to get it over with now so we won't pay
		# the cost in git to look up each individual file.
		print "/\0";
		eval { launch_watchman() };
		exit 0;
	}

	die "Watchman: $o->{error}.\n" .
	    "Falling back to scanning...\n" if $o->{error};

	binmode STDOUT, ":utf8";
	local $, = "\0";
	print @{$o->{files}};
}


file Read:C:\Users\AP068\git\documentum\duecmcustomerwrappers\.git\hooks\post-update.sample
-----------------------------------------------------
#!/bin/sh
#
# An example hook script to prepare a packed repository for use over
# dumb transports.
#
# To enable this hook, rename this file to "post-update".

exec git update-server-info


file Read:C:\Users\AP068\git\documentum\duecmcustomerwrappers\.git\hooks\pre-applypatch.sample
-----------------------------------------------------
#!/bin/sh
#
# An example hook script to verify what is about to be committed
# by applypatch from an e-mail message.
#
# The hook should exit with non-zero status after issuing an
# appropriate message if it wants to stop the commit.
#
# To enable this hook, rename this file to "pre-applypatch".

. git-sh-setup
precommit="$(git rev-parse --git-path hooks/pre-commit)"
test -x "$precommit" && exec "$precommit" ${1+"$@"}
:


file Read:C:\Users\AP068\git\documentum\duecmcustomerwrappers\.git\hooks\pre-commit.sample
-----------------------------------------------------
#!/bin/sh
#
# An example hook script to verify what is about to be committed.
# Called by "git commit" with no arguments.  The hook should
# exit with non-zero status after issuing an appropriate message if
# it wants to stop the commit.
#
# To enable this hook, rename this file to "pre-commit".

if git rev-parse --verify HEAD >/dev/null 2>&1
then
	against=HEAD
else
	# Initial commit: diff against an empty tree object
	against=$(git hash-object -t tree /dev/null)
fi

# If you want to allow non-ASCII filenames set this variable to true.
allownonascii=$(git config --bool hooks.allownonascii)

# Redirect output to stderr.
exec 1>&2

# Cross platform projects tend to avoid non-ASCII filenames; prevent
# them from being added to the repository. We exploit the fact that the
# printable range starts at the space character and ends with tilde.
if [ "$allownonascii" != "true" ] &&
	# Note that the use of brackets around a tr range is ok here, (it's
	# even required, for portability to Solaris 10's /usr/bin/tr), since
	# the square bracket bytes happen to fall in the designated range.
	test $(git diff --cached --name-only --diff-filter=A -z $against |
	  LC_ALL=C tr -d '[ -~]\0' | wc -c) != 0
then
	cat <<\EOF
Error: Attempt to add a non-ASCII file name.

This can cause problems if you want to work with people on other platforms.

To be portable it is advisable to rename the file.

If you know what you are doing you can disable this check using:

  git config hooks.allownonascii true
EOF
	exit 1
fi

# If there are whitespace errors, print the offending file names and fail.
exec git diff-index --check --cached $against --


file Read:C:\Users\AP068\git\documentum\duecmcustomerwrappers\.git\hooks\pre-push.sample
-----------------------------------------------------
#!/bin/sh

# An example hook script to verify what is about to be pushed.  Called by "git
# push" after it has checked the remote status, but before anything has been
# pushed.  If this script exits with a non-zero status nothing will be pushed.
#
# This hook is called with the following parameters:
#
# $1 -- Name of the remote to which the push is being done
# $2 -- URL to which the push is being done
#
# If pushing without using a named remote those arguments will be equal.
#
# Information about the commits which are being pushed is supplied as lines to
# the standard input in the form:
#
#   <local ref> <local sha1> <remote ref> <remote sha1>
#
# This sample shows how to prevent push of commits where the log message starts
# with "WIP" (work in progress).

remote="$1"
url="$2"

z40=0000000000000000000000000000000000000000

while read local_ref local_sha remote_ref remote_sha
do
	if [ "$local_sha" = $z40 ]
	then
		# Handle delete
		:
	else
		if [ "$remote_sha" = $z40 ]
		then
			# New branch, examine all commits
			range="$local_sha"
		else
			# Update to existing branch, examine new commits
			range="$remote_sha..$local_sha"
		fi

		# Check for WIP commit
		commit=`git rev-list -n 1 --grep '^WIP' "$range"`
		if [ -n "$commit" ]
		then
			echo >&2 "Found WIP commit in $local_ref, not pushing"
			exit 1
		fi
	fi
done

exit 0


file Read:C:\Users\AP068\git\documentum\duecmcustomerwrappers\.git\hooks\pre-rebase.sample
-----------------------------------------------------
#!/bin/sh
#
# Copyright (c) 2006, 2008 Junio C Hamano
#
# The "pre-rebase" hook is run just before "git rebase" starts doing
# its job, and can prevent the command from running by exiting with
# non-zero status.
#
# The hook is called with the following parameters:
#
# $1 -- the upstream the series was forked from.
# $2 -- the branch being rebased (or empty when rebasing the current branch).
#
# This sample shows how to prevent topic branches that are already
# merged to 'next' branch from getting rebased, because allowing it
# would result in rebasing already published history.

publish=next
basebranch="$1"
if test "$#" = 2
then
	topic="refs/heads/$2"
else
	topic=`git symbolic-ref HEAD` ||
	exit 0 ;# we do not interrupt rebasing detached HEAD
fi

case "$topic" in
refs/heads/??/*)
	;;
*)
	exit 0 ;# we do not interrupt others.
	;;
esac

# Now we are dealing with a topic branch being rebased
# on top of master.  Is it OK to rebase it?

# Does the topic really exist?
git show-ref -q "$topic" || {
	echo >&2 "No such branch $topic"
	exit 1
}

# Is topic fully merged to master?
not_in_master=`git rev-list --pretty=oneline ^master "$topic"`
if test -z "$not_in_master"
then
	echo >&2 "$topic is fully merged to master; better remove it."
	exit 1 ;# we could allow it, but there is no point.
fi

# Is topic ever merged to next?  If so you should not be rebasing it.
only_next_1=`git rev-list ^master "^$topic" ${publish} | sort`
only_next_2=`git rev-list ^master           ${publish} | sort`
if test "$only_next_1" = "$only_next_2"
then
	not_in_topic=`git rev-list "^$topic" master`
	if test -z "$not_in_topic"
	then
		echo >&2 "$topic is already up to date with master"
		exit 1 ;# we could allow it, but there is no point.
	else
		exit 0
	fi
else
	not_in_next=`git rev-list --pretty=oneline ^${publish} "$topic"`
	/usr/bin/perl -e '
		my $topic = $ARGV[0];
		my $msg = "* $topic has commits already merged to public branch:\n";
		my (%not_in_next) = map {
			/^([0-9a-f]+) /;
			($1 => 1);
		} split(/\n/, $ARGV[1]);
		for my $elem (map {
				/^([0-9a-f]+) (.*)$/;
				[$1 => $2];
			} split(/\n/, $ARGV[2])) {
			if (!exists $not_in_next{$elem->[0]}) {
				if ($msg) {
					print STDERR $msg;
					undef $msg;
				}
				print STDERR " $elem->[1]\n";
			}
		}
	' "$topic" "$not_in_next" "$not_in_master"
	exit 1
fi

<<\DOC_END

This sample hook safeguards topic branches that have been
published from being rewound.

The workflow assumed here is:

 * Once a topic branch forks from "master", "master" is never
   merged into it again (either directly or indirectly).

 * Once a topic branch is fully cooked and merged into "master",
   it is deleted.  If you need to build on top of it to correct
   earlier mistakes, a new topic branch is created by forking at
   the tip of the "master".  This is not strictly necessary, but
   it makes it easier to keep your history simple.

 * Whenever you need to test or publish your changes to topic
   branches, merge them into "next" branch.

The script, being an example, hardcodes the publish branch name
to be "next", but it is trivial to make it configurable via
$GIT_DIR/config mechanism.

With this workflow, you would want to know:

(1) ... if a topic branch has ever been merged to "next".  Young
    topic branches can have stupid mistakes you would rather
    clean up before publishing, and things that have not been
    merged into other branches can be easily rebased without
    affecting other people.  But once it is published, you would
    not want to rewind it.

(2) ... if a topic branch has been fully merged to "master".
    Then you can delete it.  More importantly, you should not
    build on top of it -- other people may already want to
    change things related to the topic as patches against your
    "master", so if you need further changes, it is better to
    fork the topic (perhaps with the same name) afresh from the
    tip of "master".

Let's look at this example:

		   o---o---o---o---o---o---o---o---o---o "next"
		  /       /           /           /
		 /   a---a---b A     /           /
		/   /               /           /
	       /   /   c---c---c---c B         /
	      /   /   /             \         /
	     /   /   /   b---b C     \       /
	    /   /   /   /             \     /
    ---o---o---o---o---o---o---o---o---o---o---o "master"


A, B and C are topic branches.

 * A has one fix since it was merged up to "next".

 * B has finished.  It has been fully merged up to "master" and "next",
   and is ready to be deleted.

 * C has not merged to "next" at all.

We would want to allow C to be rebased, refuse A, and encourage
B to be deleted.

To compute (1):

	git rev-list ^master ^topic next
	git rev-list ^master        next

	if these match, topic has not merged in next at all.

To compute (2):

	git rev-list master..topic

	if this is empty, it is fully merged to "master".

DOC_END


file Read:C:\Users\AP068\git\documentum\duecmcustomerwrappers\.git\hooks\pre-receive.sample
-----------------------------------------------------
#!/bin/sh
#
# An example hook script to make use of push options.
# The example simply echoes all push options that start with 'echoback='
# and rejects all pushes when the "reject" push option is used.
#
# To enable this hook, rename this file to "pre-receive".

if test -n "$GIT_PUSH_OPTION_COUNT"
then
	i=0
	while test "$i" -lt "$GIT_PUSH_OPTION_COUNT"
	do
		eval "value=\$GIT_PUSH_OPTION_$i"
		case "$value" in
		echoback=*)
			echo "echo from the pre-receive-hook: ${value#*=}" >&2
			;;
		reject)
			exit 1
		esac
		i=$((i + 1))
	done
fi


file Read:C:\Users\AP068\git\documentum\duecmcustomerwrappers\.git\hooks\prepare-commit-msg.sample
-----------------------------------------------------
#!/bin/sh
#
# An example hook script to prepare the commit log message.
# Called by "git commit" with the name of the file that has the
# commit message, followed by the description of the commit
# message's source.  The hook's purpose is to edit the commit
# message file.  If the hook fails with a non-zero status,
# the commit is aborted.
#
# To enable this hook, rename this file to "prepare-commit-msg".

# This hook includes three examples. The first one removes the
# "# Please enter the commit message..." help message.
#
# The second includes the output of "git diff --name-status -r"
# into the message, just before the "git status" output.  It is
# commented because it doesn't cope with --amend or with squashed
# commits.
#
# The third example adds a Signed-off-by line to the message, that can
# still be edited.  This is rarely a good idea.

COMMIT_MSG_FILE=$1
COMMIT_SOURCE=$2
SHA1=$3

/usr/bin/perl -i.bak -ne 'print unless(m/^. Please enter the commit message/..m/^#$/)' "$COMMIT_MSG_FILE"

# case "$COMMIT_SOURCE,$SHA1" in
#  ,|template,)
#    /usr/bin/perl -i.bak -pe '
#       print "\n" . `git diff --cached --name-status -r`
# 	 if /^#/ && $first++ == 0' "$COMMIT_MSG_FILE" ;;
#  *) ;;
# esac

# SOB=$(git var GIT_COMMITTER_IDENT | sed -n 's/^\(.*>\).*$/Signed-off-by: \1/p')
# git interpret-trailers --in-place --trailer "$SOB" "$COMMIT_MSG_FILE"
# if test -z "$COMMIT_SOURCE"
# then
#   /usr/bin/perl -i.bak -pe 'print "\n" if !$first_line++' "$COMMIT_MSG_FILE"
# fi


file Read:C:\Users\AP068\git\documentum\duecmcustomerwrappers\.git\hooks\update.sample
-----------------------------------------------------
#!/bin/sh
#
# An example hook script to block unannotated tags from entering.
# Called by "git receive-pack" with arguments: refname sha1-old sha1-new
#
# To enable this hook, rename this file to "update".
#
# Config
# ------
# hooks.allowunannotated
#   This boolean sets whether unannotated tags will be allowed into the
#   repository.  By default they won't be.
# hooks.allowdeletetag
#   This boolean sets whether deleting tags will be allowed in the
#   repository.  By default they won't be.
# hooks.allowmodifytag
#   This boolean sets whether a tag may be modified after creation. By default
#   it won't be.
# hooks.allowdeletebranch
#   This boolean sets whether deleting branches will be allowed in the
#   repository.  By default they won't be.
# hooks.denycreatebranch
#   This boolean sets whether remotely creating branches will be denied
#   in the repository.  By default this is allowed.
#

# --- Command line
refname="$1"
oldrev="$2"
newrev="$3"

# --- Safety check
if [ -z "$GIT_DIR" ]; then
	echo "Don't run this script from the command line." >&2
	echo " (if you want, you could supply GIT_DIR then run" >&2
	echo "  $0 <ref> <oldrev> <newrev>)" >&2
	exit 1
fi

if [ -z "$refname" -o -z "$oldrev" -o -z "$newrev" ]; then
	echo "usage: $0 <ref> <oldrev> <newrev>" >&2
	exit 1
fi

# --- Config
allowunannotated=$(git config --bool hooks.allowunannotated)
allowdeletebranch=$(git config --bool hooks.allowdeletebranch)
denycreatebranch=$(git config --bool hooks.denycreatebranch)
allowdeletetag=$(git config --bool hooks.allowdeletetag)
allowmodifytag=$(git config --bool hooks.allowmodifytag)

# check for no description
projectdesc=$(sed -e '1q' "$GIT_DIR/description")
case "$projectdesc" in
"Unnamed repository"* | "")
	echo "*** Project description file hasn't been set" >&2
	exit 1
	;;
esac

# --- Check types
# if $newrev is 0000...0000, it's a commit to delete a ref.
zero="0000000000000000000000000000000000000000"
if [ "$newrev" = "$zero" ]; then
	newrev_type=delete
else
	newrev_type=$(git cat-file -t $newrev)
fi

case "$refname","$newrev_type" in
	refs/tags/*,commit)
		# un-annotated tag
		short_refname=${refname##refs/tags/}
		if [ "$allowunannotated" != "true" ]; then
			echo "*** The un-annotated tag, $short_refname, is not allowed in this repository" >&2
			echo "*** Use 'git tag [ -a | -s ]' for tags you want to propagate." >&2
			exit 1
		fi
		;;
	refs/tags/*,delete)
		# delete tag
		if [ "$allowdeletetag" != "true" ]; then
			echo "*** Deleting a tag is not allowed in this repository" >&2
			exit 1
		fi
		;;
	refs/tags/*,tag)
		# annotated tag
		if [ "$allowmodifytag" != "true" ] && git rev-parse $refname > /dev/null 2>&1
		then
			echo "*** Tag '$refname' already exists." >&2
			echo "*** Modifying a tag is not allowed in this repository." >&2
			exit 1
		fi
		;;
	refs/heads/*,commit)
		# branch
		if [ "$oldrev" = "$zero" -a "$denycreatebranch" = "true" ]; then
			echo "*** Creating a branch is not allowed in this repository" >&2
			exit 1
		fi
		;;
	refs/heads/*,delete)
		# delete branch
		if [ "$allowdeletebranch" != "true" ]; then
			echo "*** Deleting a branch is not allowed in this repository" >&2
			exit 1
		fi
		;;
	refs/remotes/*,commit)
		# tracking branch
		;;
	refs/remotes/*,delete)
		# delete tracking branch
		if [ "$allowdeletebranch" != "true" ]; then
			echo "*** Deleting a tracking branch is not allowed in this repository" >&2
			exit 1
		fi
		;;
	*)
		# Anything else (is there anything else?)
		echo "*** Update hook: unknown type of update to ref $refname of type $newrev_type" >&2
		exit 1
		;;
esac

# --- Finished
exit 0


file Read:C:\Users\AP068\git\documentum\duecmcustomerwrappers\.gitignore
-----------------------------------------------------
# Created by https://www.gitignore.io/api/eclipse

### Eclipse ###

.metadata
bin/
tmp/
*.tmp
*.bak
*.swp
*~.nib
local.properties
.settings/
.loadpath
.recommenders

# compiled output
/dist
/tmp
/out-tsc

# dependencies
/node_modules

# IDEs and editors
/.idea
.project
.classpath
.c9/
*.launch
.settings/
*.sublime-workspace

# IDE - VSCode
.vscode/*
!.vscode/settings.json
!.vscode/tasks.json
!.vscode/launch.json
!.vscode/extensions.json

# misc
/.sass-cache
/connect.lock
/coverage
/libpeerconnection.log
npm-debug.log
testem.log
/typings

# e2e
/e2e/*.js
/e2e/*.map

# System Files
.DS_Store
Thumbs.db

# Eclipse Core
.project

# External tool builders
.externalToolBuilders/

# Locally stored "Eclipse launch configurations"
*.launch

# PyDev specific (Python IDE for Eclipse)
*.pydevproject

# CDT-specific (C/C++ Development Tooling)
.cproject

# JDT-specific (Eclipse Java Development Tools)
.classpath

# Java annotation processor (APT)
.factorypath

# PDT-specific (PHP Development Tools)
.buildpath

# sbteclipse plugin
.target

# Tern plugin
.tern-project

# TeXlipse plugin
.texlipse

# STS (Spring Tool Suite)
.springBeans

# Code Recommenders
.recommenders/

#NPM
target/
bowerrc.
node_modules/

#JAVA
*.jar
*~
\#*\#


file Read:C:\Users\AP068\git\documentum\duecmcustomerwrappers\BnhpWrapperDependencyModule\.settings\org.eclipse.wst.common.project.facet.core.xml
-----------------------------------------------------
<?xml version="1.0" encoding="UTF-8"?>
<faceted-project>
  <installed facet="java" version="1.6"/>
  <installed facet="jst.utility" version="1.0"/>
</faceted-project>


file Read:C:\Users\AP068\git\documentum\duecmcustomerwrappers\BnhpWrapperDependencyModule\app.properties
-----------------------------------------------------
# base64 convet every 3bytes to 4bytes so the ration is 
BASE_64_OVERHEAD_RATIO=1.3334

# assume that soap xml message without base64 attachments 
# will not take more than 
BASE_64_MEASSAGE_BODY_RATIO=0.85

# current message size limit on MQ
MQ_MESSAGE_SIZE=4096


file Read:C:\Users\AP068\git\documentum\duecmcustomerwrappers\BnhpWrapperDependencyModule\pom.xml
-----------------------------------------------------
<?xml version="1.0" encoding="UTF-8"?>

<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
	<modelVersion>4.0.0</modelVersion>
	
	<parent>
		<groupId>com.poalim.documentum</groupId>
		<artifactId>parent</artifactId>
		<version>1.0-SNAPSHOT</version>
	</parent>
	
	<artifactId>BnhpWrapperDependencyModule</artifactId>
	<packaging>jar</packaging>
	<name>BnhpWrapperDependencyModule</name>
	<description>BnhpWrapperDependencyModule</description>		
	
	<dependencies>					
														
			<dependency>
				<groupId>was</groupId>
				<artifactId>j2ee</artifactId>
				<scope>provided</scope>
			</dependency>
			
			<dependency>				
				<groupId>com.poalim.documentum</groupId>				
				<artifactId>BnhpInfraDFServices</artifactId>
				<classifier>basic</classifier>
				<exclusions>
					<exclusion>
						<groupId>*</groupId>
						<artifactId>*</artifactId>
					</exclusion>
				</exclusions>
			</dependency>
			
			<dependency>
				<groupId>com.poalim.dependencies</groupId>
				<artifactId>documentum-71-deps</artifactId>
				<type>pom</type>
				<scope>provided</scope>				
			</dependency>
			
			<dependency>
				<groupId>bnhp.infra.dfs.services</groupId>
				<artifactId>BHSearchContexts</artifactId>												
			</dependency>
			
			<dependency>
				<groupId>bnhp.infra.dfs.services</groupId>
				<artifactId>BHInputObjectContexts</artifactId>						
			</dependency>
			
			<dependency>
				<groupId>bnhp.infra.dfs.services</groupId>
				<artifactId>BHObjectContexts</artifactId>					
			</dependency>
		<dependency>
		    <groupId>org.dudinea.explang</groupId>
		    <artifactId>explang</artifactId>
		    <version>0.2</version>
		</dependency>			

	</dependencies>

	<build>						
			
		<resources>
			<resource>
				<directory>ejbModule</directory>
				<excludes>
					<exclude>**/*.java</exclude>
					<exclude>**/.copyarea.db</exclude>
				</excludes>
			</resource>
		</resources>				
		
	</build>

	

</project>


file Read:C:\Users\AP068\git\documentum\duecmcustomerwrappers\BnhpWrapperDependencyModule\src\bnhp\infra\dfs\services\AddDocEventData.java
-----------------------------------------------------
package bnhp.infra.dfs.services;

import java.util.List;

import bnhp.infra.dfs.model.business.SecurityContext;
import bnhp.infra.dfs.model.service.ClntV2;
import bnhp.infra.dfs.model.service.DocEventDataForCreate;
import bnhp.infra.dfs.services.exceptions.ECMException;
import bnhp.infra.dfs.services.utils.AuditUtils;
import bnhp.infra.dfs.services.utils.ServiceUtils;

import com.emc.documentum.fs.rt.context.ServiceFactory;
import com.services.infra.bnhp.client.ICreateDocEventDataServices;

public class AddDocEventData {
	protected static List<String> addDocEventDataToDocuments(
			List<DocEventDataForCreate> docEventDataForCreateList,
			SecurityContext securityContext, ClntV2 clntV2) throws ECMException {
		String serviceName = "addDocEventDataToDocuments";
		long startTS = System.currentTimeMillis();
		boolean success = false;

		String moreInfo = " docEventDataForCreateList="
				+ docEventDataForCreateList;
		AuditUtils.logDetailedEnterStatus(serviceName, securityContext, moreInfo);
		
		ICreateDocEventDataServices objectServices;
		List<String> result = null;
		try {
			objectServices = (ICreateDocEventDataServices) ServiceFactory
					.getInstance().getLocalService(
							ICreateDocEventDataServices.class,
							ServiceUtils.createServiceContext(securityContext));
			result = objectServices.addDocEventDataToDocuments(
					docEventDataForCreateList, securityContext);
			success = true;
			return result;
		} catch (Exception e) {
			AuditUtils.logErrors(e, serviceName);
			throw new ECMException(e);
		} finally {
			AuditUtils.logDetailedFinishStatus(serviceName, success, startTS, (Object) result);
		}
	}

}


file Read:C:\Users\AP068\git\documentum\duecmcustomerwrappers\BnhpWrapperDependencyModule\src\bnhp\infra\dfs\services\ApplicativeRequest.java
-----------------------------------------------------
package bnhp.infra.dfs.services;

import java.util.ArrayList;
import java.util.List;

import javax.xml.ws.Holder;

import org.dudinea.explang.ICompiled;

import bnhp.infra.dfs.exceptions.DFSDocumentumException;
import bnhp.infra.dfs.exceptions.DFSValidationException;
import bnhp.infra.dfs.explang.Explang;
import bnhp.infra.dfs.model.business.ExecutorDetails;
import bnhp.infra.dfs.model.business.PropertyKeyValue;
import bnhp.infra.dfs.model.business.SecurityContext;
import bnhp.infra.dfs.model.query.prepared.AbstractParam;
import bnhp.infra.dfs.model.query.prepared.NamedQueryParam;
import bnhp.infra.dfs.model.query.prepared.PreparedQuery;
import bnhp.infra.dfs.model.query.prepared.QueryParam;
import bnhp.infra.dfs.model.service.ClntV2;
import bnhp.infra.dfs.model.service.RequestDetails;
import bnhp.infra.dfs.population.business.Cleaner;
import bnhp.infra.dfs.services.exceptions.ECMDetailedException;
import bnhp.infra.dfs.services.exceptions.ECMException;
import bnhp.infra.dfs.services.utils.AuditUtils;
import bnhp.infra.dfs.services.utils.ExceptionUtils;
import bnhp.infra.dfs.services.utils.ServiceUtils;
import bnhp.infra.dfs.utils.basic.BnhpAudit;
import bnhp.infra.dfs.utils.basic.LoggingUtils;
import bnhp.infra.dfs.utils.basic.properties.PropertyLoader;

import com.emc.documentum.fs.rt.context.ServiceFactory;
import com.services.infra.bnhp.client.IApplicativeRequestService;

import bnhp.infra.dfs.utils.service.DfsRequestThreadAttributes;

public class ApplicativeRequest {
	private static boolean shouldPerformAudit = PropertyLoader.getInstance()
			.getBoolean(BnhpAudit.PERFORM_AUDIT_PROP);

	protected static List<NamedQueryParam> applicativeRequest(
			SecurityContext securityContext, PreparedQuery preparedQuery,
			ExecutorDetails executorDetails, ClntV2 clntV2, String requestId,
			Holder<List<RequestDetails>> requestDetails)
			throws ECMDetailedException, ECMException {
		String serviceName = "applicativeRequest";
		long startTS = System.currentTimeMillis();
		String auditedObjId = null;
		boolean success = false;
		RequestDetails details = null;
		boolean shouldHandleRequestDetails = (requestId != null && requestId
				.trim().length() > 0);
		List<NamedQueryParam> resultList = null;

		String moreInfo = " preparedQuery=" + preparedQuery
				+ " executorDetails=" + executorDetails + " requestId="
				+ requestId;
		AuditUtils.logDetailedEnterStatus(serviceName, securityContext,
				moreInfo);

		try {
			if (shouldHandleRequestDetails) {
				if (shouldPerformAudit) {
					auditedObjId = BnhpAudit.audit(securityContext,
							BnhpAudit.STATUS_PROCESS, serviceName, requestId);
				}
				details = ServiceUtils.buildRequestDetails(requestId,
						BnhpAudit.STATUS_PROCESS, auditedObjId, requestDetails);
			}
			runAppreqHook("appreq_pre_xact_hook", securityContext, preparedQuery, executorDetails);
			securityContext = ServiceUtils.applyDefaults(securityContext);
			IApplicativeRequestService svc = (IApplicativeRequestService) ServiceFactory
					.getInstance().getLocalService(
							IApplicativeRequestService.class,
							ServiceUtils.createServiceContext(securityContext));
			resultList = svc.applicativeRequest(securityContext, preparedQuery,
					executorDetails);
			success = true;
			if (shouldHandleRequestDetails && shouldPerformAudit) {
				BnhpAudit.audit(securityContext, BnhpAudit.STATUS_SUCCESS,
						serviceName, requestId, auditedObjId);
			}
			return resultList;
		} catch (Exception e) {
			AuditUtils.auditDetailedFailure(securityContext,
					BnhpAudit.STATUS_FAILED, serviceName, requestId,
					auditedObjId, e);
			ExceptionUtils.throwECMException(e, details);
			// not reached
			return null;
		} finally {
			try { 
				if (success) {
					DfsRequestThreadAttributes.runPostTransactionCommitAction();
				} else {
					DfsRequestThreadAttributes.runPostTransactionAbortAction();
				}
			} finally { 
				ServiceUtils.setRequestStatus(requestId, success, requestDetails);
				AuditUtils.logDetailedFinishStatus(serviceName, success, startTS,
					(Object) resultList);
			}
		}
	}


	protected static List<PropertyKeyValue> applicativeRequestLT (
			SecurityContext sc, 
			String requestName,
			List<PropertyKeyValue> parameters,
			ExecutorDetails executorDetails,
			Holder<List<RequestDetails>> requestDetails,
			String requestId)
		throws ECMDetailedException, ECMException {
		if (null == requestId || "".equals(requestId.trim())) {
			requestId = DfsRequestThreadAttributes.dctmRequestId.get();
		}
		String moreInfo = " requestName=" + requestName +
			" parameters=" + parameters +
			" executorDetails=" + executorDetails;
		String serviceName = "applicativeRequestLT";
		AuditUtils.logDetailedEnterStatus(serviceName, sc,	moreInfo);
		long startTS = System.currentTimeMillis();
		boolean success = false;
		String auditedObjId = null;
		List<PropertyKeyValue> results = new ArrayList<PropertyKeyValue>();
		RequestDetails details = null;
		try {
			if (shouldPerformAudit) {
				auditedObjId = BnhpAudit.audit(
											   sc,
											   BnhpAudit.STATUS_PROCESS,
											   serviceName,
											   requestId
											   );
			}
			details = ServiceUtils.buildRequestDetails(
													   requestId,
													   BnhpAudit.STATUS_PROCESS,
													   auditedObjId,
													   requestDetails);
			Cleaner.trim(sc);
			Cleaner.trim(executorDetails);
			PreparedQuery query = new PreparedQuery();
			query.setName(Cleaner.trim(requestName));
			if (null == parameters) {
				ECMException ex = new ECMException("parameters must not be null");
				AuditUtils.logDetailedError(ex, serviceName);
				throw ex;
			}

			//setLTVersion(sc.getUserName());
		
			List<NamedQueryParam> queryParams = new ArrayList<NamedQueryParam>();
			for (PropertyKeyValue parameter : parameters) {
				if (null != parameter) {
					Cleaner.trim(parameter);
					NamedQueryParam queryParam = new NamedQueryParam();
					queryParam.setName(parameter.getKey());
					QueryParam value = new QueryParam();
					value.setValue(parameter.getValue());
					queryParam.setParamValue(value);
					queryParams.add(queryParam);
				}
			}
			query.setParams(queryParams);

			runAppreqHook("appreq_pre_xact_hook", sc, query, executorDetails);
			IApplicativeRequestService appReqServices = (IApplicativeRequestService) ServiceFactory
				.getInstance().getLocalService(IApplicativeRequestService.class,
											   ServiceUtils.createServiceContext(sc));
			List<NamedQueryParam> resultParams = appReqServices.applicativeRequest(sc, query, executorDetails);
			if (null!=resultParams) {
				for (NamedQueryParam nqp : resultParams) {
					PropertyKeyValue kv = new PropertyKeyValue();
					kv.setKey(nqp.getName());
					QueryParam pv = (QueryParam)nqp.getParamValue();
					kv.setValue(null == pv.getValue() ? null : pv.getValue().toString());
					results.add(kv);
				}
			}
			success = true;
			return results;
		} catch (Exception e) {
			AuditUtils.auditDetailedFailure(
											sc,
											BnhpAudit.STATUS_FAILED,
											serviceName,
											requestId,
											auditedObjId,
											e
											);
			ExceptionUtils.throwECMException(e, details);
			// not reached
			return null;
		} finally {
			try { 
				if (success) {
					DfsRequestThreadAttributes.runPostTransactionCommitAction();
				} else {
					DfsRequestThreadAttributes.runPostTransactionAbortAction();
				}
			} finally { 
				ServiceUtils.setRequestStatus(requestId, success, requestDetails);
				AuditUtils.logDetailedFinishStatus(serviceName, success, startTS,
												   (Object) results);
			}
			AuditUtils.logDetailedFinishStatus(serviceName, success, startTS, null);
		}
	}


	protected static void runAppreqHook(final String hookName,
										final SecurityContext securityContext,
										final PreparedQuery preparedQuery,
										final ExecutorDetails executorDetails) 
		throws DFSDocumentumException, DFSValidationException {
		final String serviceName = "applicativeRequest";
		final LoggingUtils logger = DfsRequestThreadAttributes.dfsLogger.get();
		final String sysUser = DfsRequestThreadAttributes.sysUser.get();
		ICompiled hook = Explang.getHook(hookName, securityContext.getUserName(), sysUser);
		if (null == hook) {
			logger.debug(serviceName, "hook "+hookName+" not defined");
		} else {
			logger.info(serviceName, "running hook "+hookName);
			boolean hookFinished = false;
			Object result = null;
			try {
				result = Explang.evalHook(hookName,
										  hook,
										  "sysUser",         sysUser,
										  "securityContext", securityContext,
										  "preparedQuery", preparedQuery,
										  "executorDetails", executorDetails
										  );
				hookFinished = true;
			} catch (RuntimeException rex) {
				logger.error(serviceName, "hook run failed: ",rex);
				throw new DFSDocumentumException("hook run failed: ",rex);
			} finally {
				if (hookFinished) {
					logger.info(serviceName, "hook returned "+result);
				} else {
					logger.warn(serviceName, "hook run resulted in exception");
				}
			}
		}
	}

}


file Read:C:\Users\AP068\git\documentum\duecmcustomerwrappers\BnhpWrapperDependencyModule\src\bnhp\infra\dfs\services\CancelDocument.java
-----------------------------------------------------
package bnhp.infra.dfs.services;

import java.util.List;

import javax.xml.ws.Holder;

import bnhp.infra.dfs.model.business.ExecutorDetails;
import bnhp.infra.dfs.model.business.SecurityContext;
import bnhp.infra.dfs.model.query.prepared.NamedQueryParam;
import bnhp.infra.dfs.model.query.prepared.PreparedQuery;
import bnhp.infra.dfs.model.service.ClntV2;
import bnhp.infra.dfs.model.service.DocIdData;
import bnhp.infra.dfs.model.service.RequestDetails;
import bnhp.infra.dfs.services.exceptions.ECMDetailedException;
import bnhp.infra.dfs.services.exceptions.ECMException;
import bnhp.infra.dfs.services.utils.AuditUtils;
import bnhp.infra.dfs.services.utils.ExceptionUtils;
import bnhp.infra.dfs.services.utils.ServiceUtils;
import bnhp.infra.dfs.utils.basic.BnhpAudit;
import bnhp.infra.dfs.utils.basic.properties.PropertyLoader;

import com.services.infra.bnhp.client.ICancelDocumentService;
import com.emc.documentum.fs.rt.context.IServiceContext;
import com.emc.documentum.fs.rt.context.ServiceFactory;
//import com.services.infra.bnhp.client.IApplicativeRequestService;
import bnhp.infra.dfs.population.business.Cleaner;
import bnhp.infra.dfs.utils.service.DfsRequestThreadAttributes;
import bnhp.infra.dfs.utils.service.NumericVersionSpec;


public class CancelDocument {
	private static boolean shouldPerformAudit = PropertyLoader.getInstance()
		.getBoolean(BnhpAudit.PERFORM_AUDIT_PROP);
	// these services were intorduced in version 3.0 of spec, 03.01.2018
	// currently no way for this service to get client version
	// since clntVX disabled on request of doron zur that
	// just can't get it working with his WSDL<->COBOL mapper
	private static NumericVersionSpec versionSpec = new NumericVersionSpec("3,0");

	protected static DocIdData cancelDocument(
											String documentId,
											boolean isLegacyId,
											SecurityContext securityContext, 
											ExecutorDetails executorDetails,
											ClntV2 clntV2, String requestId,
											Holder<List<RequestDetails>> requestDetails)
		throws ECMDetailedException, ECMException {
		// FIXME
		final boolean trimStrings = true;
		
		String serviceName = "cancelDocument";
		long startTS = System.currentTimeMillis();
		String auditedObjId = null;
		boolean success = false;
		RequestDetails details = null;
		boolean shouldHandleRequestDetails =
			(requestId != null && requestId.trim().length() > 0);
		List<NamedQueryParam> resultList = null;

		StringBuilder bld = new StringBuilder(50);
		bld.append(" ").append(isLegacyId ? "legacy": "dctm").
			append("documentId=").append(documentId).append(" ").
			append(" executorDetails=").append(executorDetails)
			.append(" requestId=").append(requestId);

		// got rid of version spec in cancel service on request of
		// Doron Zur
		DfsRequestThreadAttributes.safVersion.set(versionSpec);		
		AuditUtils.logDetailedEnterStatus(serviceName, securityContext, bld.toString());

		if (trimStrings) {
			documentId = Cleaner.trim(documentId);
			requestId = Cleaner.trim(requestId);
			Cleaner.trim(securityContext);
			Cleaner.trim(executorDetails);
		}
		
		try {
			if (shouldHandleRequestDetails) {
				if (shouldPerformAudit) {
					auditedObjId = BnhpAudit.audit(securityContext,
												   BnhpAudit.STATUS_PROCESS, serviceName, requestId);
				}
				details = ServiceUtils.buildRequestDetails(requestId,
														   BnhpAudit.STATUS_PROCESS, auditedObjId, requestDetails);
			}
			securityContext = ServiceUtils.applyDefaults(securityContext);
			IServiceContext context = ServiceUtils.createTransactionalServiceContext(securityContext);
			ICancelDocumentService cds = (ICancelDocumentService) ServiceFactory
				.getInstance().getLocalService(ICancelDocumentService.class, context);
			DocIdData result = cds.cancelDocument(documentId, isLegacyId, securityContext, executorDetails);
			success = true;
			if (shouldHandleRequestDetails && shouldPerformAudit) {
				BnhpAudit.audit(securityContext, BnhpAudit.STATUS_SUCCESS,
								serviceName, requestId, auditedObjId);
			}
			return result;
		} catch (Exception e) {
			AuditUtils.auditDetailedFailure(securityContext,
											BnhpAudit.STATUS_FAILED, serviceName, requestId,
											auditedObjId, e);
			ExceptionUtils.throwECMException(e, details);
			// not reached
			return null;
		} finally {
			try { 
				if (success) {
					DfsRequestThreadAttributes.runPostTransactionCommitAction();
				} else {
					DfsRequestThreadAttributes.runPostTransactionAbortAction();
				}
			} finally { 
				ServiceUtils.setRequestStatus(requestId, success, requestDetails);
				AuditUtils.logDetailedFinishStatus(serviceName, success, startTS,
												   (Object) resultList);
			}
		}
	}
}


file Read:C:\Users\AP068\git\documentum\duecmcustomerwrappers\BnhpWrapperDependencyModule\src\bnhp\infra\dfs\services\CreateDocuments.java
-----------------------------------------------------
package bnhp.infra.dfs.services;

import java.lang.reflect.UndeclaredThrowableException;
import java.util.ArrayList;
import java.util.List;

import javax.xml.ws.Holder;

import bnhp.infra.dfs.exceptions.DFSDocumentumException;
import bnhp.infra.dfs.exceptions.DFSNotUniqueDocKeyException;
import bnhp.infra.dfs.exceptions.DFSValidationException;
import bnhp.infra.dfs.model.business.BankAccount;
import bnhp.infra.dfs.model.business.Custom;
import bnhp.infra.dfs.model.business.CustomerKey;
import bnhp.infra.dfs.model.business.DocCustomerData;
import bnhp.infra.dfs.model.business.DocData;
import bnhp.infra.dfs.model.business.DocDetails;
import bnhp.infra.dfs.model.business.DocFile;
import bnhp.infra.dfs.model.business.DocProperties;
import bnhp.infra.dfs.model.business.ExecutorDetails;
import bnhp.infra.dfs.model.business.PensionFund;
import bnhp.infra.dfs.model.business.SecurityContext;
import bnhp.infra.dfs.model.service.ClntV2;
import bnhp.infra.dfs.model.service.DocDataForCreate;
import bnhp.infra.dfs.model.service.DocIdData;
import bnhp.infra.dfs.model.service.RequestDetails;
import bnhp.infra.dfs.services.exceptions.ECMDetailedException;
import bnhp.infra.dfs.services.exceptions.ECMException;
import bnhp.infra.dfs.population.business.Cleaner;
import bnhp.infra.dfs.services.utils.AuditUtils;
import bnhp.infra.dfs.services.utils.ExceptionUtils;
import bnhp.infra.dfs.services.utils.ServiceUtils;
import bnhp.infra.dfs.utils.basic.BnhpAudit;
import bnhp.infra.dfs.utils.basic.properties.PropertyLoader;
import bnhp.infra.dfs.utils.service.DfsRequestThreadAttributes;
import bnhp.infra.dfs.utils.service.OperatingMode;

import com.emc.documentum.fs.rt.ServiceException;
import com.emc.documentum.fs.rt.ServiceInvocationException;
import com.emc.documentum.fs.rt.context.IServiceContext;
import com.emc.documentum.fs.rt.context.ServiceFactory;
import com.services.infra.bnhp.client.ICreateObjectServices;
import com.services.infra.bnhp.client.IUrlRequestServices;

public class CreateDocuments {
	private static boolean shouldPerformAudit = PropertyLoader.getInstance()
			.getBoolean(BnhpAudit.PERFORM_AUDIT_PROP);

	protected static List<DocIdData> doAuditedCreateDocuments(
			String serviceName, List<DocDataForCreate> docData4CreateList,
			SecurityContext securityContext, String versionLabel,
			String requestId, Boolean switchRelatedDocuments,
			Holder<List<RequestDetails>> requestDetails) throws ECMException,
			ECMDetailedException {
		long startTS = System.currentTimeMillis();
		boolean success = false;
		String moreInfo = " docData4CreateList=" + docData4CreateList
				+ " versionLabel=" + versionLabel + " requestId=" + requestId
				+ " switchRelatedDocuments=" + switchRelatedDocuments;
		AuditUtils.logDetailedEnterStatus(serviceName, securityContext, moreInfo);
		AuditUtils.logBusinessEnterStatus(serviceName,AuditUtils.extractDocDataForCreateBusinessInfo(docData4CreateList));
		String auditedObjId = null;
		List<DocIdData> resultList = null;
		RequestDetails details = null;
		boolean shouldHandleRequestDetails = (requestId != null && requestId
				.trim().length() > 0);
		try {
			if (shouldHandleRequestDetails) {
				if (shouldPerformAudit) {
					auditedObjId = BnhpAudit.audit(securityContext,
							BnhpAudit.STATUS_PROCESS, serviceName, requestId);
				}
				details = ServiceUtils.buildRequestDetails(requestId,
						BnhpAudit.STATUS_PROCESS, auditedObjId, requestDetails);
			}
			securityContext = ServiceUtils.applyDefaults(securityContext);

			resultList = doCreateDocuments(docData4CreateList, securityContext,
					versionLabel, requestId, switchRelatedDocuments);
			success = true;
			if (shouldHandleRequestDetails && shouldPerformAudit) {
				BnhpAudit.audit(securityContext, BnhpAudit.STATUS_SUCCESS,
						serviceName, requestId, auditedObjId, resultList);
			}
		} catch (DFSNotUniqueDocKeyException e) {
			AuditUtils.auditFailures(securityContext, BnhpAudit.STATUS_FAILED,
					serviceName, requestId, auditedObjId, e);
			ExceptionUtils.throwECMException(e, details);
		} catch (Exception e) {
			AuditUtils.auditFailures(securityContext, BnhpAudit.STATUS_FAILED,
					serviceName, requestId, auditedObjId, e);
			ExceptionUtils.throwECMException(e, details);
		} finally {
			ServiceUtils.setRequestStatus(requestId, success, requestDetails);
			AuditUtils.logFinishStatuses(serviceName, success, startTS,
					(Object) resultList);
		}
		return resultList;

	}


	protected static DocIdData doAuditedCreateDocumentLT(String serviceName,
														 SecurityContext securityContext,
														 DocProperties docProperties,
														 ExecutorDetails executorDetails,
														 String legacyDocumentId,
														 String versionLabel,
														 List<DocFile> docFiles,
														 List<CustomerKey> customers,
														 List<BankAccount> accounts,
														 List<PensionFund> pensionFunds,
														 List<String> documentGroupIds,
														 String requestId,
														 Holder<List<RequestDetails>> requestDetails)
		throws ECMException, ECMDetailedException {
		long startTS = System.currentTimeMillis();
		boolean success = false;
	
		//String moreInfo = " ddfc=" + ddfc+ " versionLabel=" + versionLabel + " requestId=" + requestId;
		//AuditUtils.logDetailedEnterStatus(serviceName, securityContext, moreInfo);
		//AuditUtils.logBusinessEnterStatus(serviceName,AuditUtils.extractBusinessInfo(ddfc));
		String auditedObjId = null;
		List<DocIdData> resultList = null;
		RequestDetails details = null;
		boolean shouldHandleRequestDetails = (requestId != null && requestId.trim().length() > 0);
		try {
			DocDataForCreate ddfc = new DocDataForCreate();
			DocData dd = new DocData();
			DocCustomerData dcd = new DocCustomerData();
		

			DocDetails docDetails = new DocDetails();
			docDetails.setBusinessProcessId(docProperties.getBusinessProcessId());
			docDetails.setBusinessAreaCode(docProperties.getBusinessAreaCode());
			docDetails.setBusinessSubAreaCode(docProperties.getBusinessSubAreaCode());
			docDetails.setChannelId(docProperties.getChannelId());
			docDetails.setCurrencyCode(docProperties.getCurrencyCode());
			docDetails.setDocCompletenessCode(docProperties.getDocCompletenessCode());
			docDetails.setDocDeliveryNum(docProperties.getDocDeliveryNum());
			docDetails.setDocumentEditionNbr(docProperties.getDocumentEditionNbr());
			docDetails.setDocumentFormId(docProperties.getDocumentFormId());
			docDetails.setLegacyDocumentEntryDttm(docProperties.getLegacyDocumentEntryDttm());
			docDetails.setObjectName(docProperties.getObjectName());
			docDetails.setProjectId(docProperties.getProjectId());
			docDetails.setScanStatusCode(docProperties.getScanStatusCode());
			docDetails.setSignatureStatusCode(docProperties.getSignatureStatusCode());
			docDetails.setSystemCode(docProperties.getSystemCode());
			docDetails.setTransactionAmt(docProperties.getTransactionAmt());
			docDetails.setTemplateDataExistsInd(docProperties.getTemplateDataExistsInd());
			docDetails.setDocumentGroupIds(documentGroupIds);
			docDetails.setOngoingOrHistoryCode(docProperties.getOngoingOrHistoryCode());
			docDetails.setLegacyDocumentId(legacyDocumentId);

			if (null!=docProperties.getCustom()) {
				Custom custom = new Custom();
				custom.setCustomText(docProperties.getCustom());
			}
		
			dcd.setDocDetails(docDetails);
			if (null!=pensionFunds && pensionFunds.size() > 0) {
				dcd.setPensionFund( pensionFunds.get(0));
			}
			dcd.setExecutorDetails(executorDetails);
			dcd.setCustomerKeys(customers);
			dcd.setBankAccounts(accounts);
			/// FIXME: secondary doc file
			if (null != docFiles && docFiles.size() > 0) {
				dd.setDocFile(docFiles.get(0));
			}
			dcd.setExecutorDetails(executorDetails);
			dd.setDocCustomerData(dcd);
			ddfc.setDocData(dd);
			Cleaner.trim(ddfc);
			List<DocDataForCreate> ddfcl = new ArrayList<DocDataForCreate>(1);
			ddfcl.add(ddfc);
			if (shouldHandleRequestDetails) {
				if (shouldPerformAudit) {
					auditedObjId = BnhpAudit.audit(securityContext,
							BnhpAudit.STATUS_PROCESS, serviceName, requestId);
				}
				details = ServiceUtils.buildRequestDetails(requestId,
						BnhpAudit.STATUS_PROCESS, auditedObjId, requestDetails);
			}
			securityContext = ServiceUtils.applyDefaults(securityContext);

			resultList = doCreateDocuments(ddfcl, securityContext, 	versionLabel, requestId, true);
			success = true;
			if (shouldHandleRequestDetails && shouldPerformAudit) {
				BnhpAudit.audit(securityContext, BnhpAudit.STATUS_SUCCESS,
						serviceName, requestId, auditedObjId, resultList);
			}
		} catch (DFSNotUniqueDocKeyException e) {
			AuditUtils.auditFailures(securityContext, BnhpAudit.STATUS_FAILED,
					serviceName, requestId, auditedObjId, e);
			ExceptionUtils.throwECMException(e, details);
		} catch (Exception e) {
			AuditUtils.auditFailures(securityContext, BnhpAudit.STATUS_FAILED,
					serviceName, requestId, auditedObjId, e);
			ExceptionUtils.throwECMException(e, details);
		} finally {
			ServiceUtils.setRequestStatus(requestId, success, requestDetails);
			AuditUtils.logFinishStatuses(serviceName, success, startTS,
					(Object) resultList);
		}
		return (null!=resultList && (!resultList.isEmpty())) ? resultList.get(0) : null;
	}
	
	protected static List<DocIdData> createDocumentsFromURLAsync(
			String inputURL, SecurityContext securityContext,
			List<DocDataForCreate> inputOverride, String requestId,
			Holder<List<RequestDetails>> requestDetails, ClntV2 clntV2)
			throws ECMException, ECMDetailedException {
		long startTS = System.currentTimeMillis();
		boolean success = false;
		final String serviceName = "createDocumentsFromUrlAsync";

		String moreInfo = " inputURL=" + inputURL + " inputOverride="
				+ inputOverride + " requestId=" + requestId;
		AuditUtils.logDetailedEnterStatus(serviceName, securityContext, moreInfo);
		AuditUtils.logBusinessEnterStatus(serviceName,AuditUtils.extractDocDataForCreateBusinessInfo(inputOverride));
		List<DocIdData> result = null;
		IUrlRequestServices svc = null;
		String auditedObjId = null;
		RequestDetails details = null;
		boolean shouldAudit = (shouldPerformAudit && requestId != null && requestId
				.trim().length() > 0);
		try {
			DfsRequestThreadAttributes.operatingMode.set(OperatingMode.ASYNC);
			if (shouldAudit) {
				auditedObjId = BnhpAudit.audit(securityContext,
						BnhpAudit.STATUS_PROCESS, serviceName, requestId);
			}
			details = ServiceUtils.buildRequestDetails(requestId,
					BnhpAudit.STATUS_PROCESS, auditedObjId, requestDetails);
			securityContext = ServiceUtils.applyDefaults(securityContext);
			IServiceContext context = ServiceUtils
					.createTransactionalServiceContext(securityContext);
			svc = (IUrlRequestServices) ServiceFactory.getInstance()
					.getLocalService(IUrlRequestServices.class, context);
			CreateDocumentsParameters fileParams = (CreateDocumentsParameters) svc
					.readUrlInput(inputURL, securityContext,
							CreateDocumentsParameters.class);
			if (null == fileParams) {
				throw new DFSDocumentumException(
						"error=FailedToLoadMethodParametersFromFile errorInfo=gotNullObject");
			}
			String verb = svc.getNodeName();
			if ((!"createDocuments".equals(verb))
					&& (!"createDocumentsAsync".equals(verb))) {
				throw new DFSValidationException(
						"error=InvalidMethodNameInInputFile errorInfo=[expected one of createDocuments or createDocumentsAsync]");
			}
			InputOverride.performOverride(fileParams, inputOverride);
			DfsRequestThreadAttributes.logger.get().info("CreateDocuments",
					"inputObjectAfterOverride=" + fileParams);
			result = doCreateDocuments(fileParams.getDocDataForCreateList(),
					securityContext, fileParams.getVersionLabel(), requestId,
					fileParams.getSwitchRelatedDocuments());

			success = true;

			if (shouldAudit) {
				BnhpAudit.audit(securityContext, BnhpAudit.STATUS_SUCCESS,
						serviceName, requestId, auditedObjId, result);
			}
		} catch (Exception e) {
			AuditUtils.auditFailures(securityContext, BnhpAudit.STATUS_FAILED,
					serviceName, requestId, auditedObjId, e);
			ExceptionUtils.throwECMException(e, details);
		} finally {
			if (null != svc) {
				try {
					DfsRequestThreadAttributes.logger.get().debug(
							"CreateDocuments",
							"operationName=" + serviceName
									+ " status=deletingInputFile");
					svc.deleteInputFile();
				} catch (ServiceException ex) {
					DfsRequestThreadAttributes.logger.get().error("CreateDocuments",
							"operationName=" + serviceName 
									+ " status=FailedToFeleteInputFile error=["
									+ ex.getMessage() + "]");
				}
			}
			ServiceUtils.setRequestStatus(requestId, success, requestDetails);
			AuditUtils.logFinishStatuses(serviceName, success, startTS,
					(Object) result);
		}
		return result;

	}

	private static List<DocIdData> doCreateDocuments(
			List<DocDataForCreate> docData4CreateList,
			SecurityContext securityContext, String versionLabel,
			String requestId, Boolean switchRelatedDocuments) throws ServiceInvocationException,
			DFSValidationException, DFSDocumentumException, ServiceException,
			ECMException {
		IServiceContext context = ServiceUtils
				.createTransactionalServiceContext(securityContext);
		ICreateObjectServices objectServices = (ICreateObjectServices) ServiceFactory
				.getInstance().getLocalService(ICreateObjectServices.class,
						context);
		List<DocIdData> resultList = null;
		List<DocIdData> outList = new ArrayList<DocIdData>();
		boolean success = false;
		try {
			resultList = objectServices.createDocumentsDfs2(docData4CreateList,
					securityContext, versionLabel, outList);
			success= true;
		} catch (UndeclaredThrowableException utex) {
			DfsRequestThreadAttributes.logger.get().warn("CreateDocuments",
					" state=gotUndeclaredThrowableException: outListSize="
							+ outList.size());
			DfsRequestThreadAttributes.runPostTransactionAbortAction();
			if (outList.size() > 0) {
				DfsRequestThreadAttributes.logger.get().warn("CreateDocuments", 
						" state=successWorkaroundUndeclaredThrowableException");
				resultList = outList;
			} else {
				DfsRequestThreadAttributes.logger.get().error("CreateDocuments", 
						"state=rethrowingException");
				throw utex;
			}
		} finally {
			if (success) {
				DfsRequestThreadAttributes.runPostTransactionCommitAction();
			} else {
				DfsRequestThreadAttributes.runPostTransactionAbortAction();
			}
		}
		return resultList;
	}

}


file Read:C:\Users\AP068\git\documentum\duecmcustomerwrappers\BnhpWrapperDependencyModule\src\bnhp\infra\dfs\services\DctmRequestIdHandler.java
-----------------------------------------------------
package bnhp.infra.dfs.services;

import java.util.Set;

import javax.xml.namespace.QName;
import javax.xml.ws.handler.MessageContext;
import javax.xml.ws.handler.soap.SOAPMessageContext;

import bnhp.infra.dfs.utils.service.DfsRequestThreadAttributes;

public class DctmRequestIdHandler implements
		javax.xml.ws.handler.soap.SOAPHandler<SOAPMessageContext> {

	public void close(MessageContext messagecontext) {
	}

	public Set<QName> getHeaders() {
		return null;
	}

	public boolean handleFault(SOAPMessageContext messagecontext) {
		return true;
	}

	public boolean handleMessage(SOAPMessageContext messagecontext) {
		Boolean outbound = (Boolean) messagecontext
				.get(MessageContext.MESSAGE_OUTBOUND_PROPERTY);
		if (!outbound) {
			// Generate new dctmRequestId for each inbound message
			DfsRequestThreadAttributes.generateDctmRequestId();
		} else {
			// set dctmRequestId to null for each outbound message
			DfsRequestThreadAttributes.dctmRequestId.set(null);
		}
		return true;
	}

}


file Read:C:\Users\AP068\git\documentum\duecmcustomerwrappers\BnhpWrapperDependencyModule\src\bnhp\infra\dfs\services\exceptions\DocIdDataFault.java
-----------------------------------------------------
package bnhp.infra.dfs.services.exceptions;


import javax.xml.bind.annotation.XmlAccessorType;
import javax.xml.bind.annotation.XmlType;
import javax.xml.bind.annotation.XmlAccessType;


// Currently not in USE
@XmlAccessorType(XmlAccessType.FIELD)
@XmlType(name = "DocIdDataFault")
public class DocIdDataFault {
	private String dctmDocumentId;
	private String versionLabel;
	
	public String getDctmDocumentId() {
		return dctmDocumentId;
	}
	public void setDctmDocumentId(String dctmDocumentId) {
		this.dctmDocumentId = dctmDocumentId;
	}
	public String getVersionLabel() {
		return versionLabel;
	}
	public void setVersionLabel(String versionLabel) {
		this.versionLabel = versionLabel;
	}

}


file Read:C:\Users\AP068\git\documentum\duecmcustomerwrappers\BnhpWrapperDependencyModule\src\bnhp\infra\dfs\services\exceptions\ECMDetailedException.java
-----------------------------------------------------
package bnhp.infra.dfs.services.exceptions;

import java.util.List;

import javax.xml.bind.annotation.XmlElement;
import javax.xml.ws.WebFault;

import bnhp.infra.dfs.exceptions.DFSDocumentumException;
import bnhp.infra.dfs.exceptions.utils.ErrorInfoPropertyLoader;
import bnhp.infra.dfs.model.service.RequestDetails;

// not in use currently
@WebFault(name = "DocIdDataFault")
//@WebFault(name = "DocIdDataFault", faultBean="DocIdDataFault")
public class ECMDetailedException extends Exception {
	private static final String DEFAULT_FAULT_CODE = "EXCEPTION";
	private static final long serialVersionUID = 1L;
	private String faultMsg;
	private String faultCode = DEFAULT_FAULT_CODE;
	
	@XmlElement(name = "faultInfo", required = false)
	private ECMFaultDetails faultInfo = null;
	
	public void setFaultInfo(ECMFaultDetails faultInfo) {
		this.faultInfo = faultInfo;
	}

	public ECMDetailedException() {
		super();
		ECMFaultDetails aFaultInfo = new ECMFaultDetails();
		this.setFaultInfo(aFaultInfo);
	} 

	
	
	public ECMDetailedException(String message, Throwable t) {
		super(message, t);
		this.faultMsg = message;
		// last dicth effort to get meaningfull error code (first part)
		this.faultCode = ErrorInfoPropertyLoader.getInstance().getErrorCode(t);
		if (null !=t ) {
			if (null == faultMsg) {
				faultMsg = t.getMessage();
			}
		}
		ECMFaultDetails aFaultInfo = new ECMFaultDetails();
		aFaultInfo.setFaultCode(this.faultCode);
		aFaultInfo.setFaultString(this.faultMsg);
		this.setFaultInfo(aFaultInfo);
	}

	/*public ECMDetailedException(String message) {
		super(message);
		this.faultMsg = message;
		ECMFaultDetails aFaultInfo = new ECMFaultDetails();
		this.setFaultInfo(aFaultInfo);
	}*/

	public ECMDetailedException(DFSDocumentumException t) {
		super(t);
		if (null !=t ) {
			if (t.getErrorCode() != null) {
				this.faultCode =  t.getErrorCode();
			}  else {
				this.faultCode =  ErrorInfoPropertyLoader.getInstance().getErrorCode(t);
			}
			faultMsg = t.getMessage();
		}
		ECMFaultDetails aFaultInfo = new ECMFaultDetails();
		aFaultInfo.setFaultCode(this.faultCode);
		aFaultInfo.setFaultString(this.faultMsg);
		this.setFaultInfo(aFaultInfo);
	}
	
	public ECMDetailedException(String message, DFSDocumentumException t) {
		super(message, t);
		this.faultMsg = message;
		if (null !=t ) {
			if (t.getErrorCode() != null) {
				this.faultCode =  t.getErrorCode();
			}  else {
				this.faultCode =  ErrorInfoPropertyLoader.getInstance().getErrorCode(t);
			}
			if (null == faultMsg) {
				faultMsg = t.getMessage();
			}
		}
		ECMFaultDetails aFaultInfo = new ECMFaultDetails();
		aFaultInfo.setFaultCode(this.faultCode);
		aFaultInfo.setFaultString(this.faultMsg);
		this.setFaultInfo(aFaultInfo);
	}
	
	
	public ECMDetailedException(Throwable t) {
		super(t);
		if (null !=t ) {
			this.faultCode =  ErrorInfoPropertyLoader.getInstance().getErrorCode(t);
			this.faultMsg = t.getMessage();
		}
		ECMFaultDetails aFaultInfo = new ECMFaultDetails();
		aFaultInfo.setFaultCode(this.faultCode);
		aFaultInfo.setFaultString(this.faultMsg);
		this.setFaultInfo(aFaultInfo);
	}

	public ECMDetailedException(DFSDocumentumException t, RequestDetails requestDetails) {
		this(t);
		if (null != requestDetails) {
			requestDetails.setRequestStatus("FAILED");
			ECMFaultDetails aFaultInfo = new ECMFaultDetails();
			this.setFaultInfo(aFaultInfo);
			this.getFaultInfo().setRequestDetails(requestDetails);
			this.getFaultInfo().setFaultCode(faultCode);
			this.getFaultInfo().setFaultString(faultMsg);
		}
	}
	
	public ECMDetailedException(Throwable t, RequestDetails requestDetails) {
		this(t);
		if (null != requestDetails) {
			requestDetails.setRequestStatus("FAILED");
			ECMFaultDetails aFaultInfo = new ECMFaultDetails();
			this.setFaultInfo(aFaultInfo);
			this.getFaultInfo().setRequestDetails(requestDetails);
			this.getFaultInfo().setFaultCode(faultCode);
			this.getFaultInfo().setFaultString(faultMsg);
		}
	}
	
	// getFaultInfo method must be implemented for jax-ws
	
	public ECMFaultDetails getFaultInfo() {
		return faultInfo;
	}
	// getFaultInfo method must be implemented for jax-ws
	//public String getFaultInfo() {
	//	return "";
	//}

}


file Read:C:\Users\AP068\git\documentum\duecmcustomerwrappers\BnhpWrapperDependencyModule\src\bnhp\infra\dfs\services\exceptions\ECMDocKeyNotUniqueException.java
-----------------------------------------------------
package bnhp.infra.dfs.services.exceptions;

import javax.xml.ws.WebFault;

// Currently not in use
//@WebFault(name = "DocIdDataFault")
public class ECMDocKeyNotUniqueException extends Exception{

	private static final long serialVersionUID = -5024560202930142623L;
	private String faultCode;
	
	private DocIdDataFault faultInfo;
	
	public ECMDocKeyNotUniqueException() {
		super();
	}

	public ECMDocKeyNotUniqueException(String message, Throwable t, DocIdDataFault docIdData) {
		super(message, t);
		this.faultInfo = docIdData;
	}

	public ECMDocKeyNotUniqueException(String message, DocIdDataFault docIdData) {
		super(message);
		this.faultInfo = docIdData;
	}

	public ECMDocKeyNotUniqueException(Throwable t) {
		super(t);
	}
	
	public DocIdDataFault getFaultInfo() {
		return this.faultInfo;
	}
	
	public void setFaultInfo (DocIdDataFault docIdData) {
		this.faultInfo = docIdData;
	}
	
	public String getFaultCode() {
		return this.faultCode;
		
	}
	
	public void setFaultCode (String faultCode) {
		this.faultCode = faultCode;
		
	}
}


file Read:C:\Users\AP068\git\documentum\duecmcustomerwrappers\BnhpWrapperDependencyModule\src\bnhp\infra\dfs\services\exceptions\ECMException.java
-----------------------------------------------------
package bnhp.infra.dfs.services.exceptions;

import javax.xml.ws.WebFault;

// not in use currently
@WebFault(name = "DocIdDataFault")
//@WebFault(name = "DocIdDataFault", faultBean="DocIdDataFault")
public class ECMException extends Exception {
	private static final String DEFAULT_FAULT_CODE = "EXCEPTION";
	private static final long serialVersionUID = 1L;
	private String faultMsg;
	private String faultCode = DEFAULT_FAULT_CODE;
	
	public ECMException() {
		super();
	} 

	public ECMException(String message, Throwable t) {
		super(message, t);
		this.faultMsg = message;
		if (null !=t ) {
			this.faultCode =  t.getClass().getSimpleName();
		}
	}

	public ECMException(String message) {
		super(message);
		this.faultMsg = message;
	}

	public ECMException(Throwable t) {
		super(t);
		if (null !=t ) {
			this.faultCode =  t.getClass().getSimpleName();
			this.faultMsg = t.getMessage();
		}
	}

	// getFaultInfo method must be implemented for jax-ws
	/*public ECMFaultDetails getFaultInfo() {
		ECMFaultDetails faultDetails = new ECMFaultDetails();
		faultDetails.setFaultCode("ECMEXCEPTION");
		faultDetails.setFaultString(faultMsg);
		return faultDetails;
	}*/
	// getFaultInfo method must be implemented for jax-ws
	public String getFaultInfo() {
		return "";
	}

}


file Read:C:\Users\AP068\git\documentum\duecmcustomerwrappers\BnhpWrapperDependencyModule\src\bnhp\infra\dfs\services\exceptions\ECMFaultDetails.java
-----------------------------------------------------
package bnhp.infra.dfs.services.exceptions;

import javax.xml.bind.annotation.XmlAccessorType;
import javax.xml.bind.annotation.XmlAccessType;
import javax.xml.bind.annotation.XmlElement;
import javax.xml.bind.annotation.XmlRootElement;

import bnhp.infra.dfs.model.service.RequestDetails;

//XmlRootElement(name = "ECMFaultDetails", namespace="http://bnhp.infra.services.com")
@XmlAccessorType(XmlAccessType.FIELD)
public class ECMFaultDetails {
	@XmlElement(name = "faultCode", required = false)
	private String faultCode = null;
	@XmlElement(name = "faultString", required = false)
	private String faultString = null;
	@XmlElement(name = "requestDetails", required = false)
	private RequestDetails requestDetails = null;
	

	public RequestDetails getRequestDetails() {
		return requestDetails;
	}


	public void setRequestDetails(RequestDetails requestDetails) {
		this.requestDetails = requestDetails;
	}

	
	public String getFaultCode() {
		return faultCode;
	}
	
	public String setFaultCode(String faultCode) {
		return this.faultCode = faultCode;
	}

	
	public String getFaultString() {
		return faultString;
	}
	
	public String setFaultString(String faultString) {
		return this.faultString = faultString;
	}
	
	
}


file Read:C:\Users\AP068\git\documentum\duecmcustomerwrappers\BnhpWrapperDependencyModule\src\bnhp\infra\dfs\services\exceptions\ECMTemporaryFailure.java
-----------------------------------------------------
package bnhp.infra.dfs.services.exceptions;

import javax.xml.ws.WebFault;

@WebFault
public class ECMTemporaryFailure extends RuntimeException {
	private static final long serialVersionUID = 1L;
	public ECMTemporaryFailure() {
		super();
	}

	public ECMTemporaryFailure(String message, Throwable t) {
		super(message, t);
	}

	public ECMTemporaryFailure(String faultMsg) {
		super(faultMsg);
	}

	public ECMTemporaryFailure(Throwable t) {
		super(t);
	}
}


file Read:C:\Users\AP068\git\documentum\duecmcustomerwrappers\BnhpWrapperDependencyModule\src\bnhp\infra\dfs\services\exceptions\ECMValidationException.java
-----------------------------------------------------
package bnhp.infra.dfs.services.exceptions;

import javax.xml.ws.WebFault;

@WebFault
public class ECMValidationException extends RuntimeException {
	private static final long serialVersionUID = 1L;
	public ECMValidationException() {
		super();
	}

	public ECMValidationException(String message, Throwable t) {
		super(message, t);
	}

	public ECMValidationException(String faultMsg) {
		super(faultMsg);
	}

	public ECMValidationException(Throwable t) {
		super(t);
	}
}


file Read:C:\Users\AP068\git\documentum\duecmcustomerwrappers\BnhpWrapperDependencyModule\src\bnhp\infra\dfs\services\HackHandler.java
-----------------------------------------------------
package bnhp.infra.dfs.services;

import java.io.ByteArrayOutputStream;
import bnhp.infra.dfs.utils.service.DfsRequestThreadAttributes;

import javax.jms.JMSException;
import javax.jms.Message;
import javax.xml.transform.Source;
import javax.xml.transform.dom.DOMSource;
import javax.xml.transform.stream.StreamResult;
import javax.xml.ws.LogicalMessage;
import javax.xml.ws.handler.LogicalHandler;
import javax.xml.ws.handler.LogicalMessageContext;
import javax.xml.ws.handler.MessageContext;

import org.w3c.dom.Document;
import org.w3c.dom.Node;
import org.w3c.dom.NodeList;

import com.sun.org.apache.xerces.internal.dom.DocumentImpl;


public class HackHandler implements javax.xml.ws.handler.LogicalHandler<LogicalMessageContext> {

	// @Override
	// public boolean handleMessage(MessageContext context) {
	// 	Boolean isOutbound = (Boolean)
	// 		context.get(MessageContext.MESSAGE_OUTBOUND_PROPERTY);
	// 	if (isOutbound) {
	// 		System.out.println("PROCESSING OUTBOUND MESSAGE");

	// 	} else {
	// 		System.out.println("PROCESSING  INBOUND MESSAGE");
	// 	}
	// 	return true;
	// }

	// @Override
	// public boolean handleFault(MessageContext context) {
	// 	// TODO Auto-generated method stub
	// 	return true;
	// }

	@Override
	public void close(MessageContext context) {
		// TODO Auto-generated method stub
	}

	@Override
	public boolean handleMessage(LogicalMessageContext context) {
		Boolean isOutbound = (Boolean)
			context.get(MessageContext.MESSAGE_OUTBOUND_PROPERTY);
		if (isOutbound) {
			//System.out.println("PROCESSING OUTBOUND MESSAGE");
			DfsRequestThreadAttributes.sysUser.set(null);
			// LogicalMessage msg = context.getMessage();
			// Source msgSource = msg.getPayload();
			// if (msgSource instanceof DOMSource) {
			// 	System.out.println("SOURCE IS "+msgSource);
			// 	DOMSource dsrc = (DOMSource) msgSource;
			// 	Node rootNode = dsrc.getNode();
			// 	Node msgNode = rootNode.getFirstChild();
								
			// 	if ("searchByDocumentGroupIdResponse".equals(msgNode.getLocalName())) {
			// 		Node newNode = dsrc.getNode().cloneNode(true);
			// 		msgNode = newNode.getFirstChild();
			// 		NodeList nodeList = msgNode.getChildNodes();
			// 		int len = nodeList.getLength();
			// 		for (int i = 0; i < len; i++) {
			// 			Node child = nodeList.item(i);
			// 			System.out.println("child id "+ child.getLocalName());
			// 			if ("searchResult".equals(child.getLocalName())) {
			// 				Document xmlDoc = child.getOwnerDocument();
			// 				System.out.println("owner doc is"+xmlDoc);
			// 				Node newChild = xmlDoc.createElement(""+child.getNodeName()+"_HACK");
			// 				for (int j = 0; j < child.getChildNodes().getLength(); j++) {
			// 					newChild.appendChild(child.getChildNodes().item(j));
			// 				}
			// 				msgNode.replaceChild(newChild, child);
			// 			}
			// 		}
			// 		DOMSource modified = new DOMSource();
			// 		modified.setNode(newNode);
			// 		msg.setPayload(modified);
			// 	} else {
			// 		System.out.println("leavinng "+msgNode.getLocalName()+" as is");
			// 	}
			//} else {
			//	System.out.println("HANDLING OF  "+msgSource+ " is not implemented!");
			//}
		} else {
			//System.out.println("PROCESSING  INBOUND MESSAGE");
		}
		return true;
	}

	@Override
	public boolean handleFault(LogicalMessageContext context) {
		// TODO Auto-generated method stub
		return true;
	}
	
}


file Read:C:\Users\AP068\git\documentum\duecmcustomerwrappers\BnhpWrapperDependencyModule\src\bnhp\infra\dfs\services\IDocumentumWrapper.java
-----------------------------------------------------
package bnhp.infra.dfs.services;

import com.services.infra.bnhp.client.ICreateObjectServices;
import com.services.infra.bnhp.client.IRetrieveObjectServices;
import com.services.infra.bnhp.client.ISearchObjectServices;
import com.services.infra.bnhp.client.IUpdateObjectServices;


public interface IDocumentumWrapper extends ICreateObjectServices, IRetrieveObjectServices, ISearchObjectServices, IUpdateObjectServices
{
}


file Read:C:\Users\AP068\git\documentum\duecmcustomerwrappers\BnhpWrapperDependencyModule\src\bnhp\infra\dfs\services\InputOverride.java
-----------------------------------------------------
package bnhp.infra.dfs.services;

import java.util.List;

import bnhp.infra.dfs.exceptions.DFSDocumentumException;
import bnhp.infra.dfs.exceptions.DFSValidationException;
import bnhp.infra.dfs.model.business.DocData;
import bnhp.infra.dfs.model.business.DocDetails;
import bnhp.infra.dfs.model.service.DocDataForCreate;
import bnhp.infra.dfs.model.service.DocDataForUpdate;

public class InputOverride {
	public static void performOverride(UpdateDocumentVersionParameters fileParams,
			DocDataForUpdate inputOverride) throws DFSValidationException {
		if (null == fileParams.getDocDataForUpdate() && null == inputOverride) {
			throw new DFSValidationException(
					"at least one of xml input file or inputOverride must have DocDataForUpdate object");
		} else if ((null == fileParams.getDocDataForUpdate())
				&& null != inputOverride) {
			fileParams.setDocDataForUpdate(inputOverride);
		} else if ((null != fileParams.getDocDataForUpdate())
				&& (null != inputOverride)) {
			DocDataForUpdate targetItem = fileParams.getDocDataForUpdate();
			if (null != inputOverride.getDocData()) {
				DocData overrideDocData = inputOverride.getDocData();
				DocData targetDocData = targetItem.getDocData();
				if (null == targetDocData) {
					targetItem.setDocData(overrideDocData);
				} else {
					overrideDocData(overrideDocData, targetDocData);
				}
			}
		}
	}

	public static void performOverride(CreateDocumentsParameters fileParams,
			List<DocDataForCreate> inputOverride) throws DFSDocumentumException {
		if (null == fileParams.getDocDataForCreateList()
				&& null == inputOverride) {
			throw new DFSValidationException(
					"at least one of xml input file or inputOverride must have list of DocDataForCreate objects");
		} else if ((null == fileParams.getDocDataForCreateList())
				&& null != inputOverride) {
			fileParams.setDocDataForCreateList(inputOverride);
		} else if (null != fileParams.getDocDataForCreateList()
				&& null != inputOverride) {
			if (inputOverride.size() != fileParams.getDocDataForCreateList()
					.size()) {
				throw new DFSValidationException(
						"Number of objects in the inputOverride must be equal to number of object in the xml input");
			}
			for (int i = 0; i < inputOverride.size(); i++) {
				DocDataForCreate overrideItem = inputOverride.get(i);
				if (null == overrideItem) {
					continue;
				}
				DocDataForCreate targetItem = fileParams
						.getDocDataForCreateList().get(i);
				if (null == targetItem) {
					fileParams.getDocDataForCreateList().set(i, overrideItem);
					continue;
				}
				if (null != overrideItem.getDocData()) {
					DocData overrideDocData = overrideItem.getDocData();
					DocData targetDocData = targetItem.getDocData();
					if (null == targetDocData) {
						targetItem.setDocData(overrideDocData);
					} else {
						overrideDocData(overrideDocData, targetDocData);
					}
				}

			}
		}

	}


	protected static void overrideDocData(DocData overrideDocData, DocData targetDocData) {
		if (null != overrideDocData.getDocFile()) {
			targetDocData.setDocFile(overrideDocData
					.getDocFile());
		}
		if (null != overrideDocData.getSecondaryDocFile()) {
			targetDocData.setSecondaryDocFile(overrideDocData
					.getSecondaryDocFile());
		}
		if (null != overrideDocData.getDocCustomerData()) {
			if (null == targetDocData.getDocCustomerData()) {
				targetDocData.setDocCustomerData(overrideDocData.getDocCustomerData());
			} else {
				if (null != overrideDocData.getDocCustomerData().getDocDetails()) {
					DocDetails overrideDetails = overrideDocData.getDocCustomerData().getDocDetails();
					if (null == targetDocData.getDocCustomerData().getDocDetails()) {	
						targetDocData.getDocCustomerData().setDocDetails(overrideDetails);
					} else {
						// need  to make it generic
						DocDetails targetDetails = targetDocData.getDocCustomerData().getDocDetails();
						if (null != overrideDetails.getBusinessAreaCode()) {
							targetDetails.setBusinessAreaCode(overrideDetails.getBusinessAreaCode());
						}
						if (null != overrideDetails.getBusinessProcessId()) {
							targetDetails.setBusinessProcessId(overrideDetails.getBusinessProcessId());
						}
						if (null != overrideDetails.getBusinessSubAreaCode()) {
							targetDetails.setBusinessSubAreaCode(overrideDetails.getBusinessSubAreaCode());
						}
						if (null != overrideDetails.getChannelId()) {
							targetDetails.setChannelId(overrideDetails.getChannelId());
						}
						if (null != overrideDetails.getConcatenatedEventIds()) {
							targetDetails.setConcatenatedEventIds(overrideDetails.getConcatenatedEventIds());
						}
						if (null != overrideDetails.getCurrencyCode()) {
							targetDetails.setCurrencyCode(overrideDetails.getCurrencyCode());
						}
						if (null != overrideDetails.getDocCompletenessCode()) {
							targetDetails.setDocCompletenessCode(overrideDetails.getDocCompletenessCode());
						}
						if (null != overrideDetails.getDocumentEditionNbr()) {
							targetDetails.setDocumentEditionNbr(overrideDetails.getDocumentEditionNbr());
						}
						
						if (null != overrideDetails.getDocumentFormId()) {
							targetDetails.setDocumentFormId(overrideDetails.getDocumentFormId());
						}
						if (null != overrideDetails.getDocumentGroupIds()) {
							targetDetails.setDocumentGroupIds(overrideDetails.getDocumentGroupIds());
						}
						if (null != overrideDetails.getProjectId()) {
							targetDetails.setProjectId(overrideDetails.getProjectId());
						}
						if (null != overrideDetails.getLegacyDocumentEntryDttm()) {
							targetDetails.setLegacyDocumentEntryDttm(overrideDetails.getLegacyDocumentEntryDttm());
						}
						if (null != overrideDetails.getLegacyDocumentId()) {
							targetDetails.setLegacyDocumentId(overrideDetails.getLegacyDocumentId());
						}
						if (null != overrideDetails.getObjectName()) {
							targetDetails.setObjectName(overrideDetails.getObjectName());
						}
						if (null != overrideDetails.getOngoingOrHistoryCode()) {
							targetDetails.setOngoingOrHistoryCode(overrideDetails.getOngoingOrHistoryCode());
						}
						if (null != overrideDetails.getScanStatusCode()) {
							targetDetails.setScanStatusCode(overrideDetails.getScanStatusCode());
						}
						if (null != overrideDetails.getSystemCode()) {
							targetDetails.setSystemCode(overrideDetails.getSystemCode());
						}
						if (null != overrideDetails.getTemplateDataExistsInd()) {
							targetDetails.setTemplateDataExistsInd(overrideDetails.getTemplateDataExistsInd());
						}
						if (null != overrideDetails.getTransactionAmt()) {
							targetDetails.setTransactionAmt(overrideDetails.getTransactionAmt());
						}
						if (null != overrideDetails.getSignatureStatusCode()) {
							targetDetails.setSignatureStatusCode(overrideDetails.getSignatureStatusCode());
						}
						if (null != overrideDetails.getDocDeliveryNum()) {
							targetDetails.setDocDeliveryNum(overrideDetails.getDocDeliveryNum());
						}
					} /* else */
				} /* null != overrideDocData.getDocCustomerData().getDocDetails() */
			}
		}
	}
	
}


file Read:C:\Users\AP068\git\documentum\duecmcustomerwrappers\BnhpWrapperDependencyModule\src\bnhp\infra\dfs\services\JMSHandler.java
-----------------------------------------------------
package bnhp.infra.dfs.services;

import java.io.ByteArrayOutputStream;
import bnhp.infra.dfs.utils.service.DfsRequestThreadAttributes;

import javax.jms.JMSException;
import javax.jms.Message;
import javax.xml.transform.Source;
import javax.xml.transform.dom.DOMSource;
import javax.xml.transform.stream.StreamResult;
import javax.xml.ws.LogicalMessage;
import javax.xml.ws.handler.LogicalHandler;
import javax.xml.ws.handler.LogicalMessageContext;
import javax.xml.ws.handler.MessageContext;

import org.w3c.dom.Document;
import org.w3c.dom.Node;
import org.w3c.dom.NodeList;

import com.sun.org.apache.xerces.internal.dom.DocumentImpl;


public class JMSHandler implements javax.xml.ws.handler.LogicalHandler<LogicalMessageContext> {

	private static final String serviceId = "JMSHandler";
	
	@Override
	public void close(final MessageContext context) {
		// TODO Auto-generated method stub
	}

	@Override
	public boolean handleMessage(final LogicalMessageContext context) {
		final Boolean isOutbound = (Boolean)
			context.get(MessageContext.MESSAGE_OUTBOUND_PROPERTY);
		if (isOutbound) {
			DfsRequestThreadAttributes.sysUser.set(null);
		} else {
			//System.out.println("PROCESSING  INBOUND MESSAGE");
			String sysUser = null;
			String messageId = null;
			/* 
			   JMSMessage class: jms_bytes
			   JMSType:          mcd://xmlnsc//?format=
			   JMSDeliveryMode:  1
			   JMSExpiration:    1532972730422
			   JMSPriority:      0
			   JMSMessageID:     ID:414d512044455647454e3031202020205b221ca720448587
			   JMSTimestamp:     1532972130425
			   JMSCorrelationID: null
			   JMSDestination:   queue:///DU.DOCUMENTUM.SERVICES.ECM.TEMP.REQUEST.SRV
			   JMSReplyTo:       queue://DEVFW01/FW.SERVICES.XMLSAF.E02.REPLY?persistence=1&priority=0&expiry=599997
			   JMSRedelivered:   false
			   JMSXAppID: DataFlowEngine              
			   JMSXDeliveryCount: 1
			   JMSXUserID: safinvo     
			   JMS_IBM_Character_Set: UTF-8
			   JMS_IBM_Encoding: 273
			   JMS_IBM_Format:         
			   JMS_IBM_MsgType: 1
			   JMS_IBM_PutApplType: 6
			   JMS_IBM_PutDate: 20180730
			   JMS_IBM_PutTime: 14353042
			   targetService: DocumentumServicesJmsWrapper
			*/

			//System.out.println(context.keySet());
			final Object jmsMessage = context.get("JMSMESSAGE");
			if (null!=jmsMessage && (jmsMessage instanceof javax.jms.Message)) {
				final Message msg = (Message) jmsMessage;
				try {
					final StringBuilder buf = new StringBuilder(16);
					final String jmsUser = msg.getStringProperty("JMSXUserID");
					//System.out.println("JMSUSER='"+ jmsUser +"'");
					if (null != jmsUser) {
						buf.append(jmsUser.trim()).append("@JMS");
						sysUser = buf.toString();
					}
				} catch (JMSException e) {
					DfsRequestThreadAttributes.
						logger.get().error(serviceId,"exception getting JMSXUserID variable", e);
				}
				DfsRequestThreadAttributes.logger.get().debug(serviceId,"sysUser=",new String[] {sysUser});
				try {
					messageId =  msg.getJMSMessageID();
				} catch (JMSException e) {
					DfsRequestThreadAttributes.
						logger.get().error(serviceId,"exception getting JMSMessageID", e);
				}
				DfsRequestThreadAttributes.logger.get().debug(serviceId,"messageId=",new String[] {messageId});
			} else {
				DfsRequestThreadAttributes.logger.get().warn(serviceId,"did not get JMS variables");
			}
			DfsRequestThreadAttributes.sysUser.set(sysUser);
			DfsRequestThreadAttributes.messageId.set(messageId);
		}
		return true;
	}

	@Override
	public boolean handleFault(LogicalMessageContext context) {
		// TODO Auto-generated method stub
		return true;
	}
	
}


file Read:C:\Users\AP068\git\documentum\duecmcustomerwrappers\BnhpWrapperDependencyModule\src\bnhp\infra\dfs\services\MessageSizeValidatorInterceptor.java
-----------------------------------------------------
package bnhp.infra.dfs.services;

import java.io.FileInputStream;
import java.io.IOException;
import java.util.List;
import java.util.Properties;

import javax.interceptor.AroundInvoke;
import javax.interceptor.InvocationContext;

import bnhp.infra.dfs.model.business.DocData;
import bnhp.infra.dfs.model.service.DocDataForRetrieve;
import bnhp.infra.dfs.model.service.SearchResult;

/**
 * Validate the response size from service 
 */
public class MessageSizeValidatorInterceptor {

	private static final float BASE_64_OVERHEAD_RATIO ;
	private static final float BASE_64_MEASSAGE_BODY_RATIO;

	private static final long MQ_MESSAGE_SIZE;
	
	static {
		Properties props = new Properties();
		FileInputStream fStream=null; 
		try {
			fStream = new FileInputStream("app.properties");
			props.load(fStream);
		} catch (Exception e) {
			e.printStackTrace();
		} finally {
			if( fStream!=null )
				try {fStream.close();} catch (IOException e) {}
		}
		
		BASE_64_OVERHEAD_RATIO = Float.valueOf(props.getProperty("BASE_64_OVERHEAD_RATIO","1.3334"));
		BASE_64_MEASSAGE_BODY_RATIO = Float.valueOf(props.getProperty("BASE_64_MEASSAGE_BODY_RATIO","0.85"));
		MQ_MESSAGE_SIZE = Long.parseLong(props.getProperty("MQ_MESSAGE_SIZE","4096"));
	}
	
	// disabled currently!
	//@AroundInvoke
	public Object checkResponseSize(InvocationContext context)throws Exception {
		System.out.println("MessageSizeValidatorInterseptor.checkResponseSize()-> invoke= "+context.getMethod().getName());
		Object response = context.proceed();
		long responseSize = 0;
		if( response instanceof DocData ) {
			responseSize = estimatedMessageSize((DocData)response);
		} else if( response instanceof SearchResult ){
			responseSize = estimatedMessageSize((SearchResult)response);
		}
		System.err.println("DocumentumServicesJmsWrapper.checkResponseSize() "+responseSize);
		if( responseSize > MQ_MESSAGE_SIZE*BASE_64_MEASSAGE_BODY_RATIO ) {
			throw new RuntimeException("esimated message too long "+responseSize+" with limit of "+MQ_MESSAGE_SIZE);
		}
		return response;
	}

	protected static long estimatedMessageSize(DocData data) {
		long size=0;
		if( data.getDocFile()!=null && data.getDocFile().getDocStream()!=null ) {
			size+= Math.round(data.getDocFile().getDocStream().length*BASE_64_OVERHEAD_RATIO); 
		}

		return size;
	}

	protected static long estimatedMessageSize(SearchResult result) {
		long size=0;

		if( result.getDocuments()!=null ) {
			List<DocDataForRetrieve> documents = result.getDocuments();
			for (DocDataForRetrieve documentData : documents) {
				size+=estimatedMessageSize(documentData.getDocData());
			}
		}
		return size;
	}
}


file Read:C:\Users\AP068\git\documentum\duecmcustomerwrappers\BnhpWrapperDependencyModule\src\bnhp\infra\dfs\services\RequestHandler.java
-----------------------------------------------------
package bnhp.infra.dfs.services;

import java.io.IOException;
import java.io.OutputStream;
import java.util.Iterator;
import java.util.Set;

import javax.xml.namespace.QName;
import javax.xml.soap.AttachmentPart;
import javax.xml.soap.MimeHeaders;
import javax.xml.soap.SOAPElement;
import javax.xml.soap.SOAPException;
import javax.xml.soap.SOAPMessage;
import javax.xml.soap.SOAPPart;
import javax.xml.ws.handler.MessageContext;
import javax.xml.ws.handler.soap.SOAPMessageContext;

import org.w3c.dom.Node;
import org.w3c.dom.NodeList;

import bnhp.infra.dfs.utils.basic.LoggingUtils;
import bnhp.infra.dfs.utils.service.DfsRequestThreadAttributes;

public class RequestHandler implements
		javax.xml.ws.handler.soap.SOAPHandler<SOAPMessageContext> {

	public void close(MessageContext messagecontext) {
	}

	public Set<QName> getHeaders() {
		return null;
	}

	public boolean handleFault(SOAPMessageContext messagecontext) {
		return true;
	}

	public boolean handleMessage(SOAPMessageContext messagecontext) {
		try {
			SOAPMessage msg = messagecontext.getMessage();
			Boolean outbound = (Boolean) messagecontext
					.get(MessageContext.MESSAGE_OUTBOUND_PROPERTY);
			DfsRequestThreadAttributes.postTransactionCommitAction.set(null);
			DfsRequestThreadAttributes.postTransactionAbortAction.set(null);
			if (!outbound) {
				// Set the current request on the threadAttributes
				DfsRequestThreadAttributes.request.set(msg.getSOAPBody());
				setLoggers();
			} else {
				// set request, operatingMode to null for each outbound message
				DfsRequestThreadAttributes.request.set(null);
				DfsRequestThreadAttributes.operatingMode.set(null);
				// messagecontext.setMessage(null);

				// NodeList children = msg.getSOAPBody().getChildNodes();
				// if (null != children) {
				// 	for (int i = 0; i < children.getLength(); i++) {
				// 		Node child = children.item(i);
				// 		System.out.println("CHILD["+i+"]="+child.getLocalName());
				// 		if ("searchByDocumentGroupIdResponse".equals(child.getLocalName())) {
				// 			System.out.println("modifying message!");
				// 			Node firstChild = child.getFirstChild();
				// 			System.out.println("first child: "+firstChild);
				// 			child.removeChild(firstChild);
				// 		}
						
				// 	}
				// }
			}
		} catch (SOAPException e) {
			throw new RuntimeException(e);
		}
		return true;
	}

	private void setLoggers() {
		if (DfsRequestThreadAttributes.dfsLogger.get() == null) {
			DfsRequestThreadAttributes.dfsLogger.set(new LoggingUtils(
					"dfs_logger_id"));
		}
		if (DfsRequestThreadAttributes.logger.get() == null) {
			DfsRequestThreadAttributes.logger.set(new LoggingUtils(
					"wrapper_logger_id"));
		}
		if (DfsRequestThreadAttributes.bsLogger.get() == null) {
			DfsRequestThreadAttributes.bsLogger.set(new LoggingUtils(
					"business_logger_id"));
		}
		if (DfsRequestThreadAttributes.errLogger.get() == null) {
			DfsRequestThreadAttributes.errLogger.set(new LoggingUtils(
					"err_logger_id"));
		}
		if (DfsRequestThreadAttributes.opLogger.get() == null) {
			DfsRequestThreadAttributes.opLogger.set(new LoggingUtils(
					"operator_logger_id"));
		}

	}
}


file Read:C:\Users\AP068\git\documentum\duecmcustomerwrappers\BnhpWrapperDependencyModule\src\bnhp\infra\dfs\services\RequestStatus.java
-----------------------------------------------------
package bnhp.infra.dfs.services;

import java.util.ArrayList;
import java.util.List;

import javax.jws.WebParam;
import javax.xml.ws.Holder;

import bnhp.infra.dfs.model.business.SecurityContext;
import bnhp.infra.dfs.model.service.ClntV2;
import bnhp.infra.dfs.model.service.DocIdsDataList;
import bnhp.infra.dfs.model.service.RequestDetails;
import bnhp.infra.dfs.services.exceptions.ECMException;
import bnhp.infra.dfs.services.utils.AuditUtils;
import bnhp.infra.dfs.services.utils.ServiceUtils;

import com.emc.documentum.fs.rt.context.IServiceContext;
import com.emc.documentum.fs.rt.context.ServiceFactory;
import com.services.infra.bnhp.client.IGetRequestStatusService;

public class RequestStatus {
	protected static List<RequestDetails> getRequestStatusList(
			SecurityContext securityContext, String requestId,
			Integer projectId, Integer systemCode,
			Holder<List<DocIdsDataList>> dataListListResult,
			Holder<List<String>> faultResultList,
			@WebParam(name = "clntV2") ClntV2 clntV2) throws ECMException {

		final String serviceName = "getRequestStatus";
		boolean success = false;
		long startTS = System.currentTimeMillis();

		String moreInfo = " requestId=" + requestId + " projectId=" + projectId
				+ " systemCode=" + systemCode;
		AuditUtils.logDetailedEnterStatus(serviceName, securityContext,
				moreInfo);

		faultResultList.value = new ArrayList<String>();
		dataListListResult.value = new ArrayList<DocIdsDataList>();

		IGetRequestStatusService service = null;
		List<RequestDetails> details = null;

		try {
			ServiceUtils.applyDefaults(securityContext);
			IServiceContext context = ServiceUtils
					.createServiceContext(securityContext);
			service = (IGetRequestStatusService) ServiceFactory.getInstance()
					.getLocalService(IGetRequestStatusService.class, context);
			details = service.getRequestStatus(requestId, projectId,
					systemCode, securityContext.getUserName(),
					dataListListResult, faultResultList);
			success = true;
			return details;
		} catch (Exception e) {
			AuditUtils.logDetailedError(e, serviceName);
			throw new ECMException(e);
		} finally {
			AuditUtils.logDetailedFinishStatus(serviceName, success, startTS,
					(Object) details);
		}
	}
}


file Read:C:\Users\AP068\git\documentum\duecmcustomerwrappers\BnhpWrapperDependencyModule\src\bnhp\infra\dfs\services\RetrieveDocuments.java
-----------------------------------------------------
package bnhp.infra.dfs.services;

import java.util.List;

import javax.xml.ws.Holder;

import bnhp.infra.dfs.exceptions.DFSDocumentumException;
import bnhp.infra.dfs.model.business.DocEventData;
import bnhp.infra.dfs.model.business.EventFilter;
import bnhp.infra.dfs.model.business.ExecutorDetails;
import bnhp.infra.dfs.model.business.SecurityContext;
import bnhp.infra.dfs.model.business.descr.DocEventDataDescr;
import bnhp.infra.dfs.model.service.DocDataForRetrieve;
import bnhp.infra.dfs.model.business.DocData;
import bnhp.infra.dfs.model.service.DocRetrievalFlags;
import bnhp.infra.dfs.model.service.FetchTypeSet;
import bnhp.infra.dfs.model.service.RequestDetails;
import bnhp.infra.dfs.services.exceptions.ECMDetailedException;
import bnhp.infra.dfs.services.exceptions.ECMException;
import bnhp.infra.dfs.services.utils.AuditUtils;
import bnhp.infra.dfs.services.utils.ServiceUtils;
import bnhp.infra.dfs.utils.basic.BnhpAudit;
import bnhp.infra.dfs.utils.basic.properties.PropertyLoader;
import bnhp.infra.dfs.utils.service.DfsRequestThreadAttributes;
import bnhp.infra.dfs.services.utils.ExceptionUtils;

import com.emc.documentum.fs.rt.context.IServiceContext;
import com.emc.documentum.fs.rt.context.ServiceFactory;
import com.services.infra.bnhp.client.IRetrieveDocEventDataServices;
import com.services.infra.bnhp.client.IRetrieveObjectServices;

public class RetrieveDocuments {
	protected static DocDataForRetrieve
		doRetrieveDoc(String serviceName,
					  String documentId, boolean isLegacyId, String docFormat,
					  ExecutorDetails executorDetails, SecurityContext securityContext,
					  FetchTypeSet fetchTypeSet, DocRetrievalFlags flags,
					  String versionLabel,
					  DocData  docDataCheck) throws ECMException, ECMDetailedException {
		long startTS = System.currentTimeMillis();
		boolean success = false;
		String moreInfo = " documentId= " + documentId + " docFolrmat="
			+ docFormat + " executorDetails=" + executorDetails
			+ " fetchTypeSet=" + fetchTypeSet + " flags=" + flags
			+ " versionLabel=" + versionLabel + " docDataCheck="+docDataCheck;
		AuditUtils.logDetailedEnterStatus(serviceName, securityContext,
				moreInfo);
		DfsRequestThreadAttributes.setOuterOperation(isLegacyId
													 ? "retrieveDoc4LegacyDocumentId"
													 : "retrieveDoc4DctmDocumentId");
		RequestDetails details = null;
		PropertyLoader loader = PropertyLoader.getInstance();
		boolean detailedFaults = DfsRequestThreadAttributes.isClentV3();

		final String FORCE_DETAILED_FAULT = "force_detailed_fault";
		
		// FIXME: common for diff. services
		if ((!detailedFaults) && DfsRequestThreadAttributes.isClentV2() ) {
			if (null!=securityContext) {
				if (loader.hasUserProperty(FORCE_DETAILED_FAULT, securityContext.getUserName())) {
					detailedFaults |= loader.getUserBoolean(FORCE_DETAILED_FAULT, securityContext.getUserName());
				}
			} else {
				if (loader.hasProperty(FORCE_DETAILED_FAULT)) {
					detailedFaults |= loader.getBoolean(FORCE_DETAILED_FAULT);
				}
			}
		}
		
		
		Holder<List<RequestDetails>> requestDetails = new Holder<List<RequestDetails>>();
		DocDataForRetrieve result = null;
		try {
			final String requestId = DfsRequestThreadAttributes.dctmRequestId.get();
			if (detailedFaults) {
				details = ServiceUtils.buildRequestDetails(requestId,
														   BnhpAudit.STATUS_PROCESS,
														   null,
														   requestDetails);
			}

			ServiceUtils.applyDefaults(securityContext);
			IServiceContext context = ServiceUtils
					.createTransactionalServiceContext(securityContext);
			IRetrieveObjectServices objectServices = (IRetrieveObjectServices) ServiceFactory
					.getInstance().getLocalService(
							IRetrieveObjectServices.class, context);
			result = isLegacyId ? objectServices.retrieveDoc4LegacyDocumentId(
					documentId, docFormat, securityContext, executorDetails,
					fetchTypeSet, flags, versionLabel, docDataCheck) : objectServices
					.retrieveDoc4DctmDocumentId(documentId, docFormat,
							securityContext, executorDetails, fetchTypeSet,
												flags, versionLabel, docDataCheck);
			success = true;
		} catch (DFSDocumentumException e) {
			AuditUtils.logDetailedError(e, serviceName);
			ExceptionUtils.throwECMException(e, details);
			//throw new ECMException(e);
		} catch (Exception e) {
			AuditUtils.logDetailedError(e, serviceName);
			ExceptionUtils.throwECMException(e, details);
			//throw new ECMException(e);
		} finally {
			AuditUtils.logDetailedFinishStatus(serviceName, success, startTS,
					(Object) result);
		}

		return result;
	}

	protected static List<DocEventData> doRetrieveDocEventDataListByDocumentId(
			String serviceName, boolean isLegacyId, String documentId,
			SecurityContext securityContext, ExecutorDetails executorDetails,
			EventFilter eventFilter,
			Holder<List<DocEventDataDescr>> docEventDataDescrList)
			throws ECMException {

		long startTS = System.currentTimeMillis();
		boolean success = false;

		String moreInfo = " documentId= " + documentId + " executorDetails="
				+ executorDetails + " eventFilter=" + eventFilter;
		AuditUtils.logDetailedEnterStatus(serviceName, securityContext,
				moreInfo);

		List<DocEventData> result = null;

		try {
			IRetrieveDocEventDataServices objectServices = (IRetrieveDocEventDataServices) ServiceFactory
					.getInstance().getLocalService(
							IRetrieveDocEventDataServices.class,
							ServiceUtils.createServiceContext(securityContext));
			result = isLegacyId ? objectServices
					.retrieveDocEventDataListByLegacyDocumentId(documentId,
							securityContext, executorDetails, eventFilter,
							docEventDataDescrList) : objectServices
					.retrieveDocEventDataListByDctmDocumentId(documentId,
							securityContext, executorDetails, eventFilter,
							docEventDataDescrList);
			success = true;
			if (null == DfsRequestThreadAttributes.isClentV2()
					|| (!DfsRequestThreadAttributes.isClentV2())) {
				docEventDataDescrList.value = null;
			}
			return result;
		} catch (Exception e) {
			AuditUtils.logDetailedError(e, serviceName);
			throw new ECMException(e);
		} finally {
			AuditUtils.logDetailedFinishStatus(serviceName, success, startTS,
					(Object) result);
		}
	}
}


file Read:C:\Users\AP068\git\documentum\duecmcustomerwrappers\BnhpWrapperDependencyModule\src\bnhp\infra\dfs\services\SAFVersionHandler.java
-----------------------------------------------------
package bnhp.infra.dfs.services;

import java.util.Set;

import javax.xml.namespace.QName;
import javax.xml.soap.SOAPBody;
import javax.xml.soap.SOAPException;
import javax.xml.soap.SOAPMessage;
import javax.xml.ws.handler.MessageContext;
import javax.xml.ws.handler.soap.SOAPMessageContext;

import org.w3c.dom.Node;
import org.w3c.dom.NodeList;

import bnhp.infra.dfs.utils.service.DfsRequestThreadAttributes;
import bnhp.infra.dfs.utils.service.NumericVersionSpec;

public class SAFVersionHandler implements javax.xml.ws.handler.soap.SOAPHandler<SOAPMessageContext> {

    public void close(MessageContext messagecontext) {
    }

    public Set<QName> getHeaders() {
	return null;
    }

    public boolean handleFault(SOAPMessageContext messagecontext) {
	return true;
    }

    protected String getVersionStr(SOAPBody body) {
	String num = "1.0";
	NodeList childNodes = body.getChildNodes();
	for (int i = 0; i < childNodes.getLength(); i++) {
	    Node node = childNodes.item(i); // this may be operation name
	    if ((node.getNodeType() != node.ELEMENT_NODE) || (!node.hasChildNodes())) {
		continue;
	    }
	    NodeList subchildren = node.getChildNodes();
	    for (int j = 0; j < subchildren.getLength(); j++) {
		Node subnode = subchildren.item(j);
		if (subnode.getNodeType() != node.ELEMENT_NODE) {
		    continue;
		}
		if ("clntV2".equals(subnode.getLocalName())) {
		    num = "2.0";
		    break;
		} else if ("clntV3".equals(subnode.getLocalName())) {
		    num = "3.0";
		    break;
		} else if ("clntV4".equals(subnode.getLocalName())) {
		    num = "4.0";
		    break;
		} else if ("clntV5".equals(subnode.getLocalName())) {
		    num = "5.0";
		    break;
		} else if ("clntV6".equals(subnode.getLocalName())) {
		    num = "6.0";
		    break;
		} else {
		    continue;
		}
		// System.err.println("FOUND clntV2");
		/*if (!"docRetrievalFlags".equals(subnode.getLocalName())) {
		  continue;
		  }
		  System.err.println("FOUND docRetrievalFlags");
		  NodeList retrievalEls = subnode.getChildNodes();
		  for(int k = 0; k < retrievalEls.getLength(); k++) {
		  Node retrievalEl = retrievalEls.item(k); 
		  if ((retrievalEl.getNodeType() != node.ELEMENT_NODE) ) {
		  continue;
		  }
		  System.err.println("FOUND "+retrievalEl.getLocalName());
		  if ("retrieveProfile".equals(retrievalEl.getLocalName())) {
		  System.err.println("RETURN TRUE");
		  return true;
						
		  }

		  }
		  System.err.println("RETURN FALSE");
		  return false;*/

	    }
	    // System.err.println("RETURN FALSE");
	    break;
	}
	// System.err.println("RETURN NULL");
	return num;
    }

    public boolean handleMessage(SOAPMessageContext messagecontext) {
	Boolean outbound = (Boolean) messagecontext.get(MessageContext.MESSAGE_OUTBOUND_PROPERTY);
	if (!outbound) {
	    // Include your steps for the inbound flow.

	    // System.err.println("HANDLE_MESSAGE: "+messagecontext);
	    SOAPMessage msg = messagecontext.getMessage();
	    try {
		final String versionStr = getVersionStr(msg.getSOAPBody());
		NumericVersionSpec versionSpec = new NumericVersionSpec(versionStr);
		DfsRequestThreadAttributes.safVersion.set(versionSpec);
	    } catch (SOAPException e) {
		throw new RuntimeException(e);
	    }
	    // System.err.println("VERSIONSPEC: "+versionSpec);
	}
	return true;
    }

}


file Read:C:\Users\AP068\git\documentum\duecmcustomerwrappers\BnhpWrapperDependencyModule\src\bnhp\infra\dfs\services\SearchDocuments.java
-----------------------------------------------------
package bnhp.infra.dfs.services;

import bh.dfs.services.common.inputobjectcontext.BHPeulaPakidDataContext;
import bh.dfs.services.common.searchcontext.BHSearchDateRangeDataContext;
import bh.dfs.services.common.searchcontext.BHSearchDomainActivityDataContext;
import bh.dfs.services.common.searchcontext.BHSearchGeneralDataContext;
import bh.dfs.services.common.searchcontext.BHSearchOperationBranchDataContext;

import bnhp.infra.dfs.model.business.ExecutorDetails;
import bnhp.infra.dfs.model.business.SecurityContext;
import bnhp.infra.dfs.model.business.DocumentTikLave;
import bnhp.infra.dfs.model.business.PropertyKeyValue;
import bnhp.infra.dfs.model.query.prepared.AbstractParam;
import bnhp.infra.dfs.model.query.prepared.NamedQueryParam;
import bnhp.infra.dfs.model.query.prepared.PreparedQuery;
import bnhp.infra.dfs.model.query.prepared.QueryParam;
import bnhp.infra.dfs.model.service.ClntV2;
import bnhp.infra.dfs.model.service.DocDataForRetrieve;
import bnhp.infra.dfs.model.service.DocRetrievalFlags;
import bnhp.infra.dfs.model.service.FetchTypeSet;
import bnhp.infra.dfs.model.service.Meta;
import bnhp.infra.dfs.model.service.SearchDefinition;
import bnhp.infra.dfs.model.service.SearchResult;
import bnhp.infra.dfs.model.service.SearchStatus;
import bnhp.infra.dfs.services.exceptions.ECMException;
import bnhp.infra.dfs.services.utils.AuditUtils;
import bnhp.infra.dfs.services.utils.ServiceUtils;
import bnhp.infra.dfs.utils.basic.properties.PropertyLoader;
import bnhp.infra.dfs.utils.service.DfsRequestThreadAttributes;
import bnhp.infra.dfs.utils.service.NumericVersionSpec;
import bnhp.infra.dfs.population.business.Cleaner;

import com.emc.documentum.fs.rt.context.ServiceFactory;
import com.services.infra.bnhp.client.ISearchObjectServices;

import java.util.ArrayList;
import java.util.List;

import javax.swing.event.DocumentListener;
import javax.xml.ws.Holder;

public class SearchDocuments {
	protected static SearchResult searchByDocumentGroupId(
			String documentGroupId, String docType,
			SearchDefinition searchDefinition, SecurityContext securityContext,
			FetchTypeSet fetchTypeSet, DocRetrievalFlags flags,
			BHSearchDomainActivityDataContext domainContext,
			BHSearchOperationBranchDataContext oprBranchDataContext,
			BHSearchDateRangeDataContext dateDataContext,
			BHPeulaPakidDataContext pakidDataContext,
			BHSearchGeneralDataContext generalSearchDataContext, ClntV2 clntV2)
			throws ECMException {
		String serviceName = "searchByDocumentGroupId";
		long startTS = System.currentTimeMillis();
		boolean success = false;

		String moreInfo = " documentGroupId=" + documentGroupId + " docType="
				+ docType + " searchDefinition=" + searchDefinition
				+ " fetchTypeSet=" + fetchTypeSet + " docRetrievalFlags="
				+ flags + " domainContext=" + domainContext
				+ " oprBranchDataContext=" + oprBranchDataContext
				+ " pakidDataContext=" + pakidDataContext
				+ " generalSearchDataContext=" + generalSearchDataContext;
		AuditUtils.logDetailedEnterStatus(serviceName, securityContext,
				moreInfo);
		SearchResult result = null;
		try {
			securityContext = ServiceUtils.applyDefaults(securityContext);
			ISearchObjectServices searchServices = (ISearchObjectServices) ServiceFactory
					.getInstance().getLocalService(ISearchObjectServices.class,
							ServiceUtils.createServiceContext(securityContext));
			result = searchServices
					.searchByDocumentGroupId(documentGroupId, docType,
							securityContext, fetchTypeSet, flags,
							searchDefinition, domainContext,
							oprBranchDataContext, dateDataContext,
							pakidDataContext, generalSearchDataContext);
			success = true;
			return result;
		} catch (Exception e) {
			AuditUtils.logDetailedError(e, serviceName);
			throw new ECMException(e);
		} finally {
			AuditUtils.logDetailedFinishStatus(serviceName, success, startTS, null);
		}

	}

	protected static SearchResult searchAllDocVersion(String documentId,
			SecurityContext securityContext, FetchTypeSet fetchTypeSet,
			DocRetrievalFlags flags, SearchDefinition searchDefinition,
			ExecutorDetails executorDetails, ClntV2 clntV2) throws ECMException {
		String serviceName = "searchAllDocVersion";
		long startTS = System.currentTimeMillis();
		boolean success = false;

		String moreInfo = " fetchTypeSet=" + fetchTypeSet
				+ " docRetrievalFlags=" + flags + " searchDefinition="
				+ searchDefinition + " pakidDataContext=" + executorDetails;
		AuditUtils.logDetailedEnterStatus(serviceName, securityContext,
				moreInfo);
		SearchResult result = null;
		try {
			securityContext = ServiceUtils.applyDefaults(securityContext);
			ISearchObjectServices searchServices = (ISearchObjectServices) ServiceFactory
					.getInstance().getLocalService(ISearchObjectServices.class,
							ServiceUtils.createServiceContext(securityContext));
			result = searchServices.searchAllDocVersion(documentId,
					securityContext, fetchTypeSet, flags, searchDefinition,
					/* FIXME */null);
			success = true;
			return result;
		} catch (Exception e) {
			AuditUtils.logDetailedError(e, serviceName);
			throw new ECMException(e);
		} finally {
			AuditUtils.logDetailedFinishStatus(serviceName, success, startTS,
					null);
		}

	}

	public static final String PROP_LT_VERSION_SPEC = "lt_saf_version_spec";

	protected static void setLTVersion(String user) {
		//if (null == DfsRequestThreadAttributes.safVersion.get()) {
			PropertyLoader loader = PropertyLoader.getInstance();
			if (loader.hasUserProperty(PROP_LT_VERSION_SPEC, user)) {
				final String strVersionSpec =
					loader.getUserProperty(PROP_LT_VERSION_SPEC, user);
				final NumericVersionSpec versionSpec = new NumericVersionSpec(strVersionSpec);
				DfsRequestThreadAttributes.safVersion.set(versionSpec);
			}
			//}
	}
	
	protected static SearchStatus preparedQueryMetaSearchLT(
			SecurityContext sc, 
			DocRetrievalFlags flags, SearchDefinition searchDefinition,
			String searchName,
			List<PropertyKeyValue> parameters,
			ExecutorDetails executorDetails,
			Holder<List<DocumentTikLave>> documents,
			ClntV2 clntV2) throws ECMException {
		
		String serviceName = "preparedQueryMetaSearchLT";
		long startTS = System.currentTimeMillis();
		boolean success = false;

		String moreInfo = " docRetrievalFlags=" + flags +
			" searchDefinition=" + searchDefinition +
			" searchName=" + searchName +
			" parameters=" + parameters +
			" executorDetails=" + executorDetails;
		AuditUtils.logDetailedEnterStatus(serviceName, sc,
				moreInfo);

		
		//sc = ServiceUtils.applyDefaults(sc);
		PreparedQuery query = new PreparedQuery();
		query.setName(Cleaner.trim(searchName));
		if (null == parameters) {
			ECMException ex = new ECMException("parameters must not be null");
			AuditUtils.logDetailedError(ex, serviceName);
			throw ex;
		}

		Cleaner.trim(sc);
		Cleaner.trim(flags);
		Cleaner.trim(executorDetails);

		setLTVersion(sc.getUserName());
		
		List<NamedQueryParam> queryParams = new ArrayList<NamedQueryParam>();
		for (PropertyKeyValue parameter : parameters) {
			if (null != parameter) {
				Cleaner.trim(parameter);
				NamedQueryParam queryParam = new NamedQueryParam();
				queryParam.setName(parameter.getKey());
				QueryParam value = new QueryParam();
				value.setValue(parameter.getValue());
				queryParam.setParamValue(value);
				queryParams.add(queryParam);
			}
		}
		query.setParams(queryParams);
		
		FetchTypeSet fetchTypeSet = new FetchTypeSet();
		fetchTypeSet.setFetchType(new Meta());

		SearchResult result = null;
		try {
			ISearchObjectServices searchServices = (ISearchObjectServices) ServiceFactory
					.getInstance().getLocalService(ISearchObjectServices.class,
							ServiceUtils.createServiceContext(sc));
			result = searchServices.preparedQueryMetaSearch(sc,
					fetchTypeSet, flags, searchDefinition, query,
					executorDetails);
			List<DocDataForRetrieve> docList = result.getDocuments();
			if (null != docList) {
				documents.value = new ArrayList<DocumentTikLave>(docList.size());
				for (int i = 0; i < docList.size(); i++) {
					DocumentTikLave docLT = new DocumentTikLave();
					DocDataForRetrieve doc = docList.get(i);
					if (null!=doc) {
						if (null!=doc.getDocData() &&
							null!=doc.getDocData().getDocCustomerData() &&
							null!=doc.getDocData().getDocCustomerData().getDocDetails()) {
							docLT.setLegacyDocumentId(doc.getDocData().getDocCustomerData().getDocDetails().getLegacyDocumentId());
							docLT.setLegacyDocumentEntryDttm(doc.getDocData().getDocCustomerData().getDocDetails().getLegacyDocumentEntryDttm());
							docLT.setDocumentGroupIds(doc.getDocData().getDocCustomerData().getDocDetails().getDocumentGroupIds());
							docLT.setDocumentFormId(doc.getDocData().getDocCustomerData().getDocDetails().getDocumentFormId());
						}
						if (null!=doc.getDocIdData()) {
							docLT.setDctmDocumentId(doc.getDocIdData().getDctmDocumentId());
							docLT.setVersionNumber(doc.getDocIdData().getVersionNumber());
							docLT.setVersionLabel(doc.getDocIdData().getVersionLabel());
						}
					}
					documents.value.add(docLT);
				}
				result.getSearchStatus().setResultsCount(docList.size());
			} else {
				documents.value=null;
				result.getSearchStatus().setResultsCount(0);
			}
			success = true;
			return result.getSearchStatus();
		} catch (Exception e) {
			AuditUtils.logDetailedError(e, serviceName);
			throw new ECMException(e);
		} finally {
			AuditUtils.logDetailedFinishStatus(serviceName, success, startTS, null);
		}
	}

	
	protected static SearchResult preparedQueryMetaSearch(
			SecurityContext securityContext, FetchTypeSet fetchTypeSet,
			DocRetrievalFlags flags, SearchDefinition searchDefinition,
			PreparedQuery preparedQuery, ExecutorDetails executorDetails,
			ClntV2 clntV2) throws ECMException {
		String serviceName = "preparedQueryMetaSearch";
		long startTS = System.currentTimeMillis();
		boolean success = false;

		String moreInfo = " fetchTypeSet=" + fetchTypeSet
				+ " docRetrievalFlags=" + flags + " searchDefinition="
				+ searchDefinition + " preparedQuery=" + preparedQuery
				+ " executorDetails=" + executorDetails;
		AuditUtils.logDetailedEnterStatus(serviceName, securityContext,
				moreInfo);

		SearchResult result = null;
		try {
			securityContext = ServiceUtils.applyDefaults(securityContext);
			ISearchObjectServices searchServices = (ISearchObjectServices) ServiceFactory
					.getInstance().getLocalService(ISearchObjectServices.class,
							ServiceUtils.createServiceContext(securityContext));
			result = searchServices.preparedQueryMetaSearch(securityContext,
					fetchTypeSet, flags, searchDefinition, preparedQuery,
					executorDetails);
			success = true;
			return result;
		} catch (Exception e) {
			AuditUtils.logDetailedError(e, serviceName);
			throw new ECMException(e);
		} finally {
			AuditUtils.logDetailedFinishStatus(serviceName, success, startTS, null);
		}
	}
}


file Read:C:\Users\AP068\git\documentum\duecmcustomerwrappers\BnhpWrapperDependencyModule\src\bnhp\infra\dfs\services\UpdateDocuments.java
-----------------------------------------------------
package bnhp.infra.dfs.services;

import java.util.ArrayList;
import java.util.List;

import javax.xml.ws.Holder;

import bnhp.infra.dfs.exceptions.DFSDocumentumException;
import bnhp.infra.dfs.exceptions.DFSValidationException;
import bnhp.infra.dfs.model.business.SecurityContext;
import bnhp.infra.dfs.model.service.ClntV2;
import bnhp.infra.dfs.model.service.DocDataForUpdate;
import bnhp.infra.dfs.model.service.DocIdData;
import bnhp.infra.dfs.model.service.RequestDetails;
import bnhp.infra.dfs.services.exceptions.ECMDetailedException;
import bnhp.infra.dfs.services.exceptions.ECMException;
import bnhp.infra.dfs.services.utils.AuditUtils;
import bnhp.infra.dfs.services.utils.ExceptionUtils;
import bnhp.infra.dfs.services.utils.ServiceUtils;
import bnhp.infra.dfs.utils.basic.BnhpAudit;
import bnhp.infra.dfs.utils.basic.properties.PropertyLoader;
import bnhp.infra.dfs.utils.service.DfsRequestThreadAttributes;
import bnhp.infra.dfs.utils.service.OperatingMode;

import com.emc.documentum.fs.rt.ServiceException;
import com.emc.documentum.fs.rt.context.IServiceContext;
import com.emc.documentum.fs.rt.context.ServiceFactory;
import com.services.infra.bnhp.client.IUpdateObjectServices;
import com.services.infra.bnhp.client.IUpdateObjectVersionServices;
import com.services.infra.bnhp.client.IUrlRequestServices;

public class UpdateDocuments {
	private static boolean shouldPerformAudit = PropertyLoader.getInstance()
			.getBoolean(BnhpAudit.PERFORM_AUDIT_PROP);

	protected static DocIdData doAuditedUpdateDocumentVersionByDocumentId(
			String serviceName, boolean isLegacyId, boolean allowCreate,
			DocDataForUpdate docDataForUpdate, SecurityContext securityContext,
			String versionLabel, String requestId,
			Holder<List<RequestDetails>> requestDetails) throws ECMException,
			ECMDetailedException {
		long startTS = System.currentTimeMillis();
		DfsRequestThreadAttributes.operatingMode.set(OperatingMode.SYNC);
		boolean success = false;

		String moreInfo = " docDataForUpdate=" + docDataForUpdate
				+ " versionLabel=" + versionLabel + " requestId=" + requestId;
		AuditUtils.logDetailedEnterStatus(serviceName, securityContext, moreInfo);
		AuditUtils.logBusinessEnterStatus(serviceName,AuditUtils.extractDocDataForUpdateBusinessInfo(docDataForUpdate));

		DocIdData result = null;
		String auditedObjId = null;
		RequestDetails details = null;
		boolean shouldHandleRequestDetails = (requestId != null && requestId
				.trim().length() > 0);
		try {
			if (shouldHandleRequestDetails) {
				if (shouldPerformAudit) {
					auditedObjId = BnhpAudit.audit(securityContext,
							BnhpAudit.STATUS_PROCESS, serviceName, requestId);
				}
				details = ServiceUtils.buildRequestDetails(requestId,
						BnhpAudit.STATUS_PROCESS, auditedObjId, requestDetails);
			}
			securityContext = ServiceUtils.applyDefaults(securityContext);
			
			result = doUpdateDocumentVersionByDocumentId(isLegacyId,  allowCreate,
						docDataForUpdate, securityContext, versionLabel, requestId);
			success = true;
		
			if (shouldHandleRequestDetails && shouldPerformAudit) {
				BnhpAudit.audit(securityContext, BnhpAudit.STATUS_SUCCESS,
						serviceName, requestId, result, auditedObjId);
			}
		} catch (Exception e) {
			AuditUtils.auditFailures(securityContext, BnhpAudit.STATUS_FAILED,
					serviceName, requestId, auditedObjId, e);
			ExceptionUtils.throwECMException(e, details);
		} finally {
			ServiceUtils.setRequestStatus(requestId, success, requestDetails);
			AuditUtils.logFinishStatuses(serviceName, success, startTS,
					(Object) result);
		}
		return result;
	}

	private static DocIdData doUpdateDocumentVersionByDocumentId(
			boolean isLegacyId, boolean allowCreate , DocDataForUpdate docDataForUpdate,
			SecurityContext securityContext, String versionLabel,
			String requestId) throws DFSValidationException,
			DFSDocumentumException, ServiceException {
		DocIdData result = null;
		IServiceContext context = ServiceUtils
				.createTransactionalServiceContext(securityContext);
		
		try {
			IUpdateObjectVersionServices updateServices = (IUpdateObjectVersionServices) ServiceFactory
				.getInstance().getLocalService(
						IUpdateObjectVersionServices.class, context);
			result = updateServices.updateDocumentVersionById2(docDataForUpdate,
						securityContext, versionLabel, isLegacyId, allowCreate);
			return result;
		} finally {
			if (null!=result) {
				DfsRequestThreadAttributes.runPostTransactionCommitAction();
			} else {
				DfsRequestThreadAttributes.runPostTransactionAbortAction();
			}
		}
	}

	protected static List<DocIdData> doAuditedUpdateDocumentsByDocumentId(
			String serviceName, boolean isLegacyId,
			List<DocDataForUpdate> docDataForUpdateList,
			SecurityContext securityContext, String requestId,
			Holder<List<RequestDetails>> requestDetails) throws ECMException,
			ECMDetailedException {
		long startTS = System.currentTimeMillis();
		boolean success = false;

		String moreInfo = "docDataForUpdateList=" + docDataForUpdateList
				+ " requestId=" + requestId;
		AuditUtils.logDetailedEnterStatus(serviceName, securityContext, moreInfo);
		AuditUtils.logBusinessEnterStatus(serviceName,AuditUtils.extractDocDataForUpdateBusinessInfo(docDataForUpdateList));

		String auditedObjId = null;
		List<DocIdData> result = null;
		RequestDetails details = null;
		boolean shouldHandleRequestDetails = (requestId != null && requestId
				.trim().length() > 0);
		try {
			if (shouldHandleRequestDetails) {
				if (shouldPerformAudit) {
					auditedObjId = BnhpAudit.audit(securityContext,
							BnhpAudit.STATUS_PROCESS, serviceName, requestId);
				}
				details = ServiceUtils.buildRequestDetails(requestId,
						BnhpAudit.STATUS_PROCESS, auditedObjId, requestDetails);
			}

			securityContext = ServiceUtils.applyDefaults(securityContext);
			IServiceContext context = ServiceUtils
					.createTransactionalServiceContext(securityContext);
			IUpdateObjectServices updateServices = (IUpdateObjectServices) ServiceFactory
					.getInstance().getLocalService(IUpdateObjectServices.class,
							context);

			try {
				result = isLegacyId ? updateServices.updateDocumentsByLegacyId(
					docDataForUpdateList, securityContext) : updateServices
					.updateDocumentsByDctmDocumentId(docDataForUpdateList,
							securityContext);
					success = true;
			} finally {
				if (success) {
					DfsRequestThreadAttributes.runPostTransactionCommitAction();
				} else {
					DfsRequestThreadAttributes.runPostTransactionAbortAction();
				}
			}
			if (shouldHandleRequestDetails && shouldPerformAudit) {
				BnhpAudit.audit(securityContext, BnhpAudit.STATUS_SUCCESS,
						serviceName, requestId, auditedObjId, result);
			}
		} catch (Exception e) {
			AuditUtils.auditFailures(securityContext, BnhpAudit.STATUS_FAILED,
					serviceName, requestId, auditedObjId, e);
			ExceptionUtils.throwECMException(e, details);
		} finally {
			ServiceUtils.setRequestStatus(requestId, success, requestDetails);
			AuditUtils.logFinishStatuses(serviceName, success, startTS,
					(Object) result);
		}
		return result;
	}

	protected static DocIdData updateDocumentVersionFromURLAsync(
			String inputURL, DocDataForUpdate inputOverride,
			SecurityContext securityContext, String versionLabel,
			String requestId, Holder<List<RequestDetails>> requestDetails,
			ClntV2 clntV2) throws ECMException, ECMDetailedException {
		long startTS = System.currentTimeMillis();
		boolean success = false;
		final String serviceName = "UpdateDocumentVersionFromURLAsync";

		String moreInfo = " inputURL=" + inputURL + " inputOverride="
				+ inputOverride + " requestId=" + requestId;
		AuditUtils.logDetailedEnterStatus(serviceName, securityContext, moreInfo);
		AuditUtils.logBusinessEnterStatus(serviceName,AuditUtils.extractDocDataForUpdateBusinessInfo(inputOverride));

		DocIdData result = null;
		IUrlRequestServices svc = null;
		String auditedObjId = null;
		RequestDetails details = null;
		boolean shouldHandleRequestDetails = (requestId != null && requestId
				.trim().length() > 0);
		try {
			DfsRequestThreadAttributes.operatingMode.set(OperatingMode.ASYNC);
			if (shouldHandleRequestDetails) {
				if (shouldPerformAudit) {
					auditedObjId = BnhpAudit.audit(securityContext,
							BnhpAudit.STATUS_PROCESS, serviceName, requestId);
				}
				details = ServiceUtils.buildRequestDetails(requestId,
						BnhpAudit.STATUS_PROCESS, auditedObjId, requestDetails);
			}
			securityContext = ServiceUtils.applyDefaults(securityContext);
			requestDetails.value = new ArrayList<RequestDetails>(1);
			requestDetails.value.add(details);
			IServiceContext context = ServiceUtils
					.createTransactionalServiceContext(securityContext);
			svc = (IUrlRequestServices) ServiceFactory.getInstance()
					.getLocalService(IUrlRequestServices.class, context);
			UpdateDocumentVersionParameters fileParams = (UpdateDocumentVersionParameters) svc
					.readUrlInput(inputURL, securityContext,
							UpdateDocumentVersionParameters.class);
			String verb = svc.getNodeName();
			DfsRequestThreadAttributes.logger.get().debug("UpdateDocuments", 
					"inputObject=" + fileParams + "verb=" + verb);
			if (null == fileParams) {
				throw new DFSDocumentumException(
						"Failed to load metod parameters from file, got null object");
			}
			boolean isLegacyId = false;
			;
			if ("updateDocumentVersionByLegacyDocumentId".equals(verb)
					|| "updateDocumentVersionByLegacyDocumentIdAsync"
							.equals(verb)) {
				isLegacyId = true;
			} else if ("updateDocumentVersionByDctmDocumentId".equals(verb)
					|| "updateDocumentVersionByDctmDocumentIdAsync"
							.equals(verb)) {
				isLegacyId = false;
			} else {
				throw new DFSValidationException(
						"Invalid method name in input file: '"
								+ verb
								+ "', expected one of updateDocumentVersionByLegacyDocumentId,"
								+ " updateDocumentVersionByLegacyDocumentIdAsync, "
								+ "updateDocumentVersionByDctmDocumentId, "
								+ "updateDocumentVersionByDctmDocumentIdAsync");
			}
			InputOverride.performOverride(fileParams, inputOverride);
			DfsRequestThreadAttributes.logger.get().debug("UpdateDocuments",
					"inputObjectAfterOverride=" + fileParams);
			result = doUpdateDocumentVersionByDocumentId(
					isLegacyId, false, 
					fileParams.getDocDataForUpdate(),
					securityContext,
					((null != versionLabel && versionLabel.length() > 0) ? versionLabel
							: fileParams.getVersionLabel()),
					((null != requestId && requestId.length() > 0) ? requestId
							: fileParams.getRequestId()));
			success = true;
			if (shouldHandleRequestDetails && shouldPerformAudit) {
				BnhpAudit.audit(securityContext, BnhpAudit.STATUS_SUCCESS,
						serviceName, requestId, result, auditedObjId);
			}
		} catch (Exception e) {
			AuditUtils.auditFailures(securityContext, BnhpAudit.STATUS_FAILED,
					serviceName, requestId, auditedObjId, e);
			ExceptionUtils.throwECMException(e, details);
		} finally {
			ServiceUtils.setRequestStatus(requestId, success, requestDetails);
			AuditUtils.logFinishStatuses(serviceName, success, startTS,
					(Object) result);
		}
		return result;
	}
}


file Read:C:\Users\AP068\git\documentum\duecmcustomerwrappers\BnhpWrapperDependencyModule\src\bnhp\infra\dfs\services\utils\AuditUtils.java
-----------------------------------------------------
package bnhp.infra.dfs.services.utils;

import java.io.PrintWriter;
import java.io.StringWriter;
import java.util.ArrayList;
import java.util.List;

import bnhp.infra.dfs.model.business.BankAccount;
import bnhp.infra.dfs.model.business.DocDetails;
import bnhp.infra.dfs.model.business.SecurityContext;
import bnhp.infra.dfs.model.service.DocDataForCreate;
import bnhp.infra.dfs.model.service.DocDataForUpdate;
import bnhp.infra.dfs.utils.basic.BnhpAudit;
import bnhp.infra.dfs.utils.basic.properties.PropertyLoader;
import bnhp.infra.dfs.utils.service.DfsRequestThreadAttributes;

public class AuditUtils {
	private static boolean shouldPerformAudit = PropertyLoader.getInstance()
			.getBoolean(BnhpAudit.PERFORM_AUDIT_PROP);

	private static void handleRequestAndBnhpAudit(
			SecurityContext securityContext, String failedStatus,
			String serviceName, String requestId, String auditedObjId,
			Exception e) {
		if (requestId != null && requestId.trim().length() > 0) {
			StringWriter sWriter = new StringWriter();
			PrintWriter printWriter = new PrintWriter(sWriter);
			e.printStackTrace(printWriter);

			String requestData = DfsRequestThreadAttributes.getRequest(2000);

			if (shouldPerformAudit) {
				BnhpAudit.auditFailure(securityContext, failedStatus,
						serviceName, requestId, requestData,
						sWriter.toString(), auditedObjId, e.getClass()
								.getSimpleName());
			}
		}

	}

	public static void auditFailures(SecurityContext securityContext,
			String failedStatus, String serviceName, String requestId,
			String auditedObjId, Exception e) {
		logDetailedError(e, serviceName);
		logBusinessError(e, serviceName);
		handleRequestAndBnhpAudit(securityContext, failedStatus, serviceName,
				requestId, auditedObjId, e);
	}

	public static void auditDetailedFailure(SecurityContext securityContext,
			String failedStatus, String serviceName, String requestId,
			String auditedObjId, Exception e) {
		logDetailedError(e, serviceName);
		handleRequestAndBnhpAudit(securityContext, failedStatus, serviceName,
				requestId, auditedObjId, e);
	}

	public static void auditBusinessFailure(SecurityContext securityContext,
			String failedStatus, String serviceName, String requestId,
			String auditedObjId, Exception e) {
		logBusinessError(e, serviceName);
		handleRequestAndBnhpAudit(securityContext, failedStatus, serviceName,
				requestId, auditedObjId, e);
	}

	public static void logErrors(Exception e, String serviceName) {
		logDetailedError(e, serviceName);
		logBusinessError(e, serviceName);
	}

	public static void logDetailedError(Exception e, String serviceName) {
		String exceptionInfo = "operationName=" + serviceName;
		if (e.getClass().getSimpleName().equals("DFSValidationException")
				|| e.getClass().getSimpleName()
						.equals("DFSNotUniqueDocKeyException")) {
			DfsRequestThreadAttributes.errLogger.get().warn("AuditUtils",
					exceptionInfo, e);
		} else {
			DfsRequestThreadAttributes.errLogger.get().error("AuditUtils",
					exceptionInfo, e);
		}

	}

	public static void logBusinessError(Exception e, String serviceName) {
		String exceptionBusinessInfo = " operationName=" + serviceName
				+ " error=" + e.getMessage();
		if (e.getClass().getSimpleName().equals("DFSValidationException")
				|| e.getClass().getSimpleName()
						.equals("DFSNotUniqueDocKeyException")) {
			DfsRequestThreadAttributes.bsLogger.get().warn("AuditUtils",
					exceptionBusinessInfo);
		} else {
			DfsRequestThreadAttributes.bsLogger.get().error("AuditUtils",
					exceptionBusinessInfo);
		}
	}

	public static void logDetailedEnterStatus(String operationName,
			SecurityContext securityContext, String moreInfo) {
		DfsRequestThreadAttributes.logger.get().info(
				"AuditUtils",
				"operationState=entered " +
				" operationName="   + operationName +
				" securityContext=" + securityContext +
				" sysUser="         + DfsRequestThreadAttributes.sysUser.get() +
				" messageId="       + DfsRequestThreadAttributes.messageId.get() +
				moreInfo);
	}

	public static void logBusinessEnterStatus(String operationName,
			StringBuffer moreInfo) {
		DfsRequestThreadAttributes.bsLogger.get().info(
				"AuditUtils",
				"operationState=entered " + " operationName=" + operationName
						+ moreInfo);
	}

	public static void logFinishStatuses(String serviceName, boolean success,
			long startTS, Object result) {
		logDetailedFinishStatus(serviceName, success, startTS, result);
		logBusinessFinishStatus(serviceName, success, startTS, result);
	}

	public static void logDetailedFinishStatus(String serviceName,
			boolean success, long startTS, Object result) {
		String msg = "operationState=finished" + " operationName="
				+ serviceName + " success=" + success
				+ (result == null ? "" : " result=" + result) + " elapsedTime="
				+ (System.currentTimeMillis() - startTS);
		DfsRequestThreadAttributes.logger.get().info("AuditUtils", msg);
	}

	public static void logBusinessFinishStatus(String serviceName,
			boolean success, long startTS, Object result) {
		String msg = "operationState=finished" + " operationName="
				+ serviceName + " success=" + success
				+ (result == null ? "" : " result=" + result) + " elapsedTime="
				+ (System.currentTimeMillis() - startTS);

		DfsRequestThreadAttributes.bsLogger.get().info("AuditUtils", msg);
	}

	public static StringBuffer extractDocDataForCreateBusinessInfo(
			List<DocDataForCreate> docDataForCreateList) {
		StringBuffer businessInfo = new StringBuffer();
		if (null != docDataForCreateList) {
			for (DocDataForCreate docDataForCreate : docDataForCreateList) {
				businessInfo.append(extractBusinessInfo(docDataForCreate));
			}
		}
		return businessInfo;
	}

	public static StringBuffer extractDocDataForUpdateBusinessInfo(
			List<DocDataForUpdate> docDataForUpdateList) {
		StringBuffer businessInfo = new StringBuffer();
		for (DocDataForUpdate docDataForUpdate : docDataForUpdateList) {
			if (null!= docDataForUpdate && docDataForUpdate.getDocData() != null
					&& docDataForUpdate.getDocData().getDocCustomerData() != null) {
				DocDetails docDetails = docDataForUpdate.getDocData()
						.getDocCustomerData().getDocDetails();
				businessInfo.append(" documentFormId=").append(
						docDetails.getDocumentFormId());
				businessInfo.append(" legacyDocumentId=").append(
						docDetails.getLegacyDocumentId());
				if (docDataForUpdate.getDocData().getDocCustomerData()
						.getBankAccounts() != null) {
					for (BankAccount bankAccount : docDataForUpdate
							.getDocData().getDocCustomerData()
							.getBankAccounts()) {
						if (bankAccount.getAccountNbr() != null) {
							businessInfo.append(" accountNbr=").append(
									bankAccount.getAccountNbr());
						} else {
							businessInfo.append(" accountNbr=null");
						}
						if (bankAccount.getBranchId() != null) {
							businessInfo.append(" branchId=").append(
									bankAccount.getBranchId());
						} else {
							businessInfo.append(" branchId=null");
						}
					}
				} else {
					businessInfo.append(" accountNbr=null");
					businessInfo.append(" branchId=null");
				}
				businessInfo.append(" legacyDocumentEntryDttm=").append(
						docDetails.getLegacyDocumentEntryDttm());
			}
		}
		return businessInfo;
	}

	public static StringBuffer extractDocDataForUpdateBusinessInfo(
			DocDataForUpdate docDataForUpdate) {
		ArrayList<DocDataForUpdate> docDataForUpdateList = new ArrayList<DocDataForUpdate>();
		docDataForUpdateList.add(docDataForUpdate);
		return extractDocDataForUpdateBusinessInfo(docDataForUpdateList);
	}


	public static StringBuffer extractBusinessInfo(DocDataForCreate docDataForCreate) {
		final StringBuffer businessInfo = new StringBuffer();
		if (null!=docDataForCreate) {
			if (docDataForCreate.getDocData() != null
				&& docDataForCreate.getDocData().getDocCustomerData() != null) {
				
				DocDetails docDetails = docDataForCreate.getDocData()
					.getDocCustomerData().getDocDetails();
				if (null != docDetails) {
					businessInfo.append(" documentFormId=").append(docDetails.getDocumentFormId());
					businessInfo.append(" legacyDocumentId=").append(docDetails.getLegacyDocumentId());
				}
				if (docDataForCreate.getDocData().getDocCustomerData().getBankAccounts() != null) {
					for (BankAccount bankAccount : docDataForCreate .getDocData().getDocCustomerData().getBankAccounts()) {
						if (null != bankAccount) {
							if (bankAccount.getAccountNbr() != null) {
								businessInfo.append(" accountNbr=").append(
																		   bankAccount.getAccountNbr());
							} else {
								businessInfo.append(" accountNbr=null");
							}
							if (bankAccount.getBranchId() != null) {
								businessInfo.append(" branchId=").append(
																		 bankAccount.getBranchId());
							} else {
								businessInfo.append(" branchId=null");
							}
						}
					}
				} else {
					businessInfo.append(" accountNbr=null");
					businessInfo.append(" branchId=null");
				}
				businessInfo.append(" legacyDocumentEntryDttm=").append(docDetails.getLegacyDocumentEntryDttm());
			}
		}
		return businessInfo;
	}
}


file Read:C:\Users\AP068\git\documentum\duecmcustomerwrappers\BnhpWrapperDependencyModule\src\bnhp\infra\dfs\services\utils\ExceptionUtils.java
-----------------------------------------------------
package bnhp.infra.dfs.services.utils;

import bnhp.infra.dfs.exceptions.DFSDocumentumException;
import bnhp.infra.dfs.model.service.RequestDetails;
import bnhp.infra.dfs.services.exceptions.ECMDetailedException;
import bnhp.infra.dfs.services.exceptions.ECMException;
import bnhp.infra.dfs.utils.service.DfsRequestThreadAttributes;

public class ExceptionUtils {
	
	public static void throwECMException(DFSDocumentumException ex,
			RequestDetails details) throws ECMException, ECMDetailedException {
		if (null != details) {
			throw new ECMDetailedException(ex, details);
		} else {
			throw new ECMException(ex);
		}
	}

	public static void throwECMException(Exception ex, RequestDetails details)
			throws ECMException, ECMDetailedException {
		if (null != details) {
			throw new ECMDetailedException(ex, details);
		} else {
			throw new ECMException(ex);
		}
	}

	public static void throwECMException(Throwable ex, RequestDetails details)
			throws ECMException, ECMDetailedException {
		if (null != details) {
			throw new ECMDetailedException(ex, details);
		} else {
			throw new ECMException(ex);
		}
	}

	public static void throwECMException(DFSDocumentumException ex)
			throws ECMException, ECMDetailedException {
		if (null != DfsRequestThreadAttributes.isClentV2()
				&& DfsRequestThreadAttributes.isClentV2()) {
			throw new ECMDetailedException(ex);
		} else {
			throw new ECMException(ex);
		}
	}

	public static void throwECMException(Throwable ex) throws ECMException,
			ECMDetailedException {
		if (null != DfsRequestThreadAttributes.isClentV2()
				&& DfsRequestThreadAttributes.isClentV2()) {
			throw new ECMDetailedException(ex);
		} else {
			throw new ECMException(ex);
		}
	}

}


file Read:C:\Users\AP068\git\documentum\duecmcustomerwrappers\BnhpWrapperDependencyModule\src\bnhp\infra\dfs\services\utils\PermissionsUtils.java
-----------------------------------------------------
package bnhp.infra.dfs.services.utils;


public class PermissionsUtils {
	public PermissionsUtils() {
		
	}
}


file Read:C:\Users\AP068\git\documentum\duecmcustomerwrappers\BnhpWrapperDependencyModule\src\bnhp\infra\dfs\services\utils\ServiceUtils.java
-----------------------------------------------------
package bnhp.infra.dfs.services.utils;

import java.util.ArrayList;
import java.util.List;
import java.util.UUID;

import javax.xml.ws.Holder;

import bnhp.infra.dfs.exceptions.DFSDocumentumException;
import bnhp.infra.dfs.exceptions.DFSValidationException;
import bnhp.infra.dfs.model.business.SecurityContext;
import bnhp.infra.dfs.model.service.RequestDetails;
import bnhp.infra.dfs.services.exceptions.ECMValidationException;
import bnhp.infra.dfs.utils.basic.BnhpAudit;
import bnhp.infra.dfs.utils.basic.IsDataEmptyUtils;
import bnhp.infra.dfs.utils.basic.properties.PropertyLoader;

import com.documentum.fc.common.DfException;
import com.documentum.fc.impl.util.StringUtil;
import com.emc.documentum.fs.datamodel.core.content.ContentTransferMode;
import com.emc.documentum.fs.datamodel.core.context.RepositoryIdentity;
import com.emc.documentum.fs.datamodel.core.profiles.ContentTransferProfile;
import com.emc.documentum.fs.datamodel.core.profiles.SchemaProfile;
import com.emc.documentum.fs.rt.context.ContextFactory;
import com.emc.documentum.fs.rt.context.IServiceContext;

public final class ServiceUtils {
	private final static String DEFAULT_DOCBASE_PROP = "default_docbase";
	private final static String DOCBASE_OVERRIDE_PROP = "docbase_override";
	private final static String USER_OVERRIDE_PROP = "user_override";
	private final static String DEFAULT_USER_PROP = "default_user_name";
	private final static String DEFAULT_PASS_PROP = "default_user_pass";

	private ServiceUtils() {
	}

	public static SecurityContext applyDefaults(SecurityContext pContext)
			throws DFSValidationException, DFSDocumentumException {
		PropertyLoader loader = PropertyLoader.getInstance();

		if (loader.hasProperty(USER_OVERRIDE_PROP)
				&& loader.getBoolean(DOCBASE_OVERRIDE_PROP)) {
			if (null == pContext) {
				pContext = new SecurityContext();
			}
			pContext.setUserName(loader.getProperty(DEFAULT_USER_PROP));
			String encPass = loader.getProperty(DEFAULT_PASS_PROP);
			String pass = null;
			;
			try {
				pass = com.documentum.fc.tools.RegistryPasswordUtils
						.decrypt(encPass);
			} catch (DfException e) {
				throw new DFSDocumentumException(
						"failed to decrypt default user password", e);
			}
			pContext.setPassword(pass);
		}
		if (pContext == null) {
			// FIXME: after the PoalimFault is out, change this to throw the
			// fault with the code
			throw new DFSValidationException("SecurityContext must exist");
		}

		boolean docbaseOverride = loader.getBoolean(DOCBASE_OVERRIDE_PROP);
		if (docbaseOverride
				|| IsDataEmptyUtils.isEmptyOrNull(pContext.getRepositoryName())) {
			String defaultDocbase = loader.getProperty(DEFAULT_DOCBASE_PROP);
			if (!IsDataEmptyUtils.isEmptyOrNull(defaultDocbase)) {
				pContext.setRepositoryName(defaultDocbase);
			} else if (docbaseOverride) {
				throw new DFSDocumentumException(
						"Cannot assign default docbase: default_docbase is not set in the app. configuration");
			}
		}

		return pContext;
	}

	/**
	 * @param securityContext
	 * @return
	 * @throws ECMValidationException
	 */
	private static RepositoryIdentity createRepIdentity(
			SecurityContext securityContext) throws ECMValidationException {
		RepositoryIdentity repIdentity = new RepositoryIdentity();
		if (securityContext == null) {
			// FIXME: after the PoalimFault is out, change this to throw the
			// fault with the code
			throw new ECMValidationException("SecurityContext must exist");
		}
		repIdentity.setUserName(securityContext.getUserName());
		repIdentity.setPassword(securityContext.getPassword());
		repIdentity.setRepositoryName(securityContext.getRepositoryName());

		return repIdentity;
	}

	public static IServiceContext createTransactionalServiceContext(
			SecurityContext securityContext) throws ECMValidationException {
		IServiceContext context = createServiceContext(securityContext);
		context.setRuntimeProperty(IServiceContext.USER_TRANSACTION_HINT,
				IServiceContext.TRANSACTION_REQUIRED);
		return context;
	}

	/**
	 * @param securityContext
	 * @return
	 * @throws ECMValidationException
	 */
	public static IServiceContext createServiceContext(
			SecurityContext securityContext) throws ECMValidationException {
		RepositoryIdentity repIdentity = ServiceUtils
				.createRepIdentity(securityContext);
		IServiceContext serviceContext = ContextFactory.getInstance()
				.newContext();
		ContentTransferProfile transferProfile = new ContentTransferProfile();
		transferProfile.setTransferMode(ContentTransferMode.MTOM);
		serviceContext.setProfile(transferProfile);
		SchemaProfile schemaProfile = new SchemaProfile(
				StringUtil.EMPTY_STRING, true, true, true);
		serviceContext.setProfile(schemaProfile);
		serviceContext.addIdentity(repIdentity);
		return serviceContext;
	}

	public static RequestDetails buildRequestDetails(
			String requestId, String status, String auditedObjId, Holder<List<RequestDetails>> requestDetails) {
		RequestDetails details = null;
		if ((requestId != null) && (requestId.length() > 0)) {
			details = new RequestDetails();
			details.setRequestId(requestId);
			details.setRequestStatus(status);
			// if real auditing was not performed, return dummy id
			if (auditedObjId == null) {
				auditedObjId = UUID.randomUUID().toString().substring(0, 18)
						.replace("-", "");
			}
			details.setRequestObjectId(auditedObjId);
			requestDetails.value = new ArrayList<RequestDetails>(1);
			requestDetails.value.add(details);
		}
		return details;
	}

	public static void setRequestStatus(String requestId, boolean success,
			Holder<List<RequestDetails>> requestDetails) {
		if (requestId != null && requestId.trim().length() > 0) {
			String requestStatus = success == true ? BnhpAudit.STATUS_SUCCESS
					: BnhpAudit.STATUS_FAILED;
			requestDetails.value.get(0).setRequestStatus(requestStatus);
		}
	}
}


file Read:C:\Users\AP068\git\documentum\duecmcustomerwrappers\BnhpWrapperDependencyModule\target\classes\META-INF\maven\com.poalim.documentum\BnhpWrapperDependencyModule\pom.properties
-----------------------------------------------------
#Generated by Maven Integration for Eclipse
#Wed Jun 09 16:03:21 IDT 2021
m2e.projectLocation=C\:\\Users\\AP068\\git\\documentum\\duecmcustomerwrappers\\BnhpWrapperDependencyModule
m2e.projectName=BnhpWrapperDependencyModule
groupId=com.poalim.documentum
artifactId=BnhpWrapperDependencyModule
version=1.0-SNAPSHOT


file Read:C:\Users\AP068\git\documentum\duecmcustomerwrappers\BnhpWrapperDependencyModule\target\classes\META-INF\maven\com.poalim.documentum\BnhpWrapperDependencyModule\pom.xml
-----------------------------------------------------
<?xml version="1.0" encoding="UTF-8"?>

<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
	<modelVersion>4.0.0</modelVersion>
	
	<parent>
		<groupId>com.poalim.documentum</groupId>
		<artifactId>parent</artifactId>
		<version>1.0-SNAPSHOT</version>
	</parent>
	
	<artifactId>BnhpWrapperDependencyModule</artifactId>
	<packaging>jar</packaging>
	<name>BnhpWrapperDependencyModule</name>
	<description>BnhpWrapperDependencyModule</description>		
	
	<dependencies>					
														
			<dependency>
				<groupId>was</groupId>
				<artifactId>j2ee</artifactId>
				<scope>provided</scope>
			</dependency>
			
			<dependency>				
				<groupId>com.poalim.documentum</groupId>				
				<artifactId>BnhpInfraDFServices</artifactId>
				<classifier>basic</classifier>
				<exclusions>
					<exclusion>
						<groupId>*</groupId>
						<artifactId>*</artifactId>
					</exclusion>
				</exclusions>
			</dependency>
			
			<dependency>
				<groupId>com.poalim.dependencies</groupId>
				<artifactId>documentum-71-deps</artifactId>
				<type>pom</type>
				<scope>provided</scope>				
			</dependency>
			
			<dependency>
				<groupId>bnhp.infra.dfs.services</groupId>
				<artifactId>BHSearchContexts</artifactId>												
			</dependency>
			
			<dependency>
				<groupId>bnhp.infra.dfs.services</groupId>
				<artifactId>BHInputObjectContexts</artifactId>						
			</dependency>
			
			<dependency>
				<groupId>bnhp.infra.dfs.services</groupId>
				<artifactId>BHObjectContexts</artifactId>					
			</dependency>
		<dependency>
		    <groupId>org.dudinea.explang</groupId>
		    <artifactId>explang</artifactId>
		    <version>0.2</version>
		</dependency>			

	</dependencies>

	<build>						
			
		<resources>
			<resource>
				<directory>ejbModule</directory>
				<excludes>
					<exclude>**/*.java</exclude>
					<exclude>**/.copyarea.db</exclude>
				</excludes>
			</resource>
		</resources>				
		
	</build>

	

</project>


file Read:C:\Users\AP068\git\documentum\duecmcustomerwrappers\ESB\BnhpDFSWrapper\.settings\org.eclipse.wst.common.project.facet.core.xml
-----------------------------------------------------
<?xml version="1.0" encoding="UTF-8"?>
<faceted-project>
  <installed facet="java" version="1.6"/>
  <installed facet="jst.ejb" version="3.0"/>
</faceted-project>


file Read:C:\Users\AP068\git\documentum\duecmcustomerwrappers\ESB\BnhpDFSWrapper\ejbModule\bnhp\infra\dfs\services\DocumentumServicesJmsWrapper.java
-----------------------------------------------------
package bnhp.infra.dfs.services;

import java.util.List;

import javax.ejb.Stateless;
import javax.interceptor.Interceptors;
import javax.jws.HandlerChain;
import javax.jws.WebMethod;
import javax.jws.WebParam;
import javax.jws.WebResult;
import javax.jws.WebService;
import javax.xml.ws.Holder;

import bh.dfs.services.common.inputobjectcontext.BHPeulaPakidDataContext;
import bh.dfs.services.common.searchcontext.BHSearchDateRangeDataContext;
import bh.dfs.services.common.searchcontext.BHSearchDomainActivityDataContext;
import bh.dfs.services.common.searchcontext.BHSearchGeneralDataContext;
import bh.dfs.services.common.searchcontext.BHSearchOperationBranchDataContext;

import bnhp.infra.dfs.init.ApplicationInitializer;
import bnhp.infra.dfs.model.business.DocProperties;
import bnhp.infra.dfs.model.business.CodeTableDataContext;
import bnhp.infra.dfs.model.business.CurrencyDataContext;
import bnhp.infra.dfs.model.business.DocDataMfContext;
import bnhp.infra.dfs.model.business.DocData;
import bnhp.infra.dfs.model.business.BankAccount;
import bnhp.infra.dfs.model.business.CustomerKey;
import bnhp.infra.dfs.model.business.DocEventData;
import bnhp.infra.dfs.model.business.DocFile;
import bnhp.infra.dfs.model.business.EventFilter;
import bnhp.infra.dfs.model.business.ExecutorDetails;
import bnhp.infra.dfs.model.business.PensionFund;
import bnhp.infra.dfs.model.business.PropertyKeyValue;
import bnhp.infra.dfs.model.business.SecurityContext;
import bnhp.infra.dfs.model.business.descr.DocEventDataDescr;
import bnhp.infra.dfs.model.business.DocumentTikLave;
import bnhp.infra.dfs.model.query.prepared.NamedQueryParam;
import bnhp.infra.dfs.model.query.prepared.PreparedQuery;
import bnhp.infra.dfs.model.query.prepared.QueryParam;
import bnhp.infra.dfs.model.service.ClntV2;
import bnhp.infra.dfs.model.service.ClntV3;
import bnhp.infra.dfs.model.service.ClntV4;
import bnhp.infra.dfs.model.service.ClntV5;
import bnhp.infra.dfs.model.service.ClntV6;
import bnhp.infra.dfs.model.service.DocDataForCreate;
import bnhp.infra.dfs.model.service.DocDataForRetrieve;
import bnhp.infra.dfs.model.service.DocDataForUpdate;
import bnhp.infra.dfs.model.service.DocEventDataForCreate;
import bnhp.infra.dfs.model.service.DocIdData;
import bnhp.infra.dfs.model.service.DocIdsDataList;
import bnhp.infra.dfs.model.service.DocRetrievalFlags;
import bnhp.infra.dfs.model.service.FetchType;
import bnhp.infra.dfs.model.service.FetchTypeSet;
import bnhp.infra.dfs.model.service.RequestDetails;
import bnhp.infra.dfs.model.service.SearchDefinition;
import bnhp.infra.dfs.model.service.SearchResult;
import bnhp.infra.dfs.model.service.SearchStatus;
import bnhp.infra.dfs.services.exceptions.ECMDetailedException;
import bnhp.infra.dfs.services.exceptions.ECMException;
import bnhp.infra.dfs.utils.basic.LoggingUtils;
import bnhp.infra.dfs.utils.service.DfsRequestThreadAttributes;
import bnhp.infra.dfs.utils.service.OperatingMode;

/**
 * @author FON This class represents a collection of all the visible operations
 *         to manage documentum capabilities: Create, Update, Retrieve and
 *         Search of documents managed in documentum. These operations will be
 *         exposed through SAF (ESB infrastructure) as different services with
 *         subset of existing operations.
 * 
 */
@HandlerChain(file = "DocumentumServicesJmsWrapperHandlers.xml")
@WebService(targetNamespace = "http://bnhp.infra.services.com", name = "DocumentumServicesJmsWrapper")
@Stateless(mappedName = "DocumentumServicesJmsWrapper", name = "DocumentumServicesJmsWrapper")
@Interceptors(value = { MessageSizeValidatorInterceptor.class })
public class DocumentumServicesJmsWrapper {
	protected ApplicationInitializer appInit;
	
	public DocumentumServicesJmsWrapper() {
		// The dctmRequestId is generated in RequestHandler
		// WSSOAPHandler, but the constructor is not invoked as a WS, so
		// generate it here and then nullify it upon exit
		// Also, set the loggers (and leave them set)
		try {
			DfsRequestThreadAttributes.generateDctmRequestId();
			DfsRequestThreadAttributes.logger.set(new LoggingUtils(
					"wrapper_logger_id"));
			DfsRequestThreadAttributes.dfsLogger.set(new LoggingUtils(
					"dfs_logger_id"));
			DfsRequestThreadAttributes.logger.get().info(
					"DocumentumServicesJmsWrapper",
					"status=initDocumentumServicesJmsWrapperInstance");
			appInit = ApplicationInitializer.getInstance();
			appInit.initApplication();
		} finally {
			DfsRequestThreadAttributes.dctmRequestId.set(null);
		}
	}

	@WebMethod
	@WebResult(name = "docIdDataList")
	public List<DocIdData> createDocumentsFromURLAsync(
			@WebParam(name = "inputURL") String inputURL,
			@WebParam(name = "securityContext") SecurityContext securityContext,
			@WebParam(name = "inputOverride") List<DocDataForCreate> inputOverride,
			@WebParam(name = "requestId") String requestId,
			@WebParam(name = "requestDetails", mode = WebParam.Mode.OUT) Holder<List<RequestDetails>> requestDetails,
			@WebParam(name = "clntV2") ClntV2 clntV2,
			@WebParam(name = "clntV3") ClntV3 clntV3,
			@WebParam(name = "clntV4") ClntV4 clntV4,
			@WebParam(name = "clntV5") ClntV5 clntV5,
			@WebParam(name = "clntV6") ClntV6 clntV6) throws ECMException,
			ECMDetailedException {
		return CreateDocuments.createDocumentsFromURLAsync(inputURL,
				securityContext, inputOverride, requestId, requestDetails,
				clntV2);
	}

	@WebMethod
	@WebResult(name = "docIdData")
	public DocIdData updateDocumentVersionFromURLAsync(
			@WebParam(name = "inputURL") String inputURL,
			@WebParam(name = "inputOverride") DocDataForUpdate inputOverride,
			@WebParam(name = "securityContext") SecurityContext securityContext,
			@WebParam(name = "versionLabel") String versionLabel,
			@WebParam(name = "requestId") String requestId,
			@WebParam(name = "requestDetails", mode = WebParam.Mode.OUT) Holder<List<RequestDetails>> requestDetails,
			@WebParam(name = "clntV2") ClntV2 clntV2,
			@WebParam(name = "clntV3") ClntV3 clntV3,
			@WebParam(name = "clntV4") ClntV4 clntV4,
			@WebParam(name = "clntV5") ClntV5 clntV5,
			@WebParam(name = "clntV6") ClntV6 clntV6) throws ECMException,
			ECMDetailedException {
		return UpdateDocuments.updateDocumentVersionFromURLAsync(inputURL,
				inputOverride, securityContext, versionLabel, requestId,
				requestDetails, clntV2);
	}

	@WebMethod
	@WebResult(name = "docIdDataList")
	public List<DocIdData> createDocuments(
			@WebParam(name = "docDataForCreateList") List<DocDataForCreate> docData4CreateList,
			@WebParam(name = "securityContext") SecurityContext securityContext,
			@WebParam(name = "versionLabel") String versionLabel,
			@WebParam(name = "requestId") String requestId,
			@WebParam(name = "switchRelatedDocuments") Boolean switchRelatedDocuments,
			@WebParam(name = "requestDetails", mode = WebParam.Mode.OUT) Holder<List<RequestDetails>> requestDetails,
			@WebParam(name = "clntV2") ClntV2 clntV2,
			@WebParam(name = "clntV3") ClntV3 clntV3,
			@WebParam(name = "clntV4") ClntV4 clntV4,
			@WebParam(name = "clntV5") ClntV5 clntV5,
			@WebParam(name = "clntV6") ClntV6 clntV6) throws ECMException,
			ECMDetailedException {
		DfsRequestThreadAttributes.operatingMode.set(OperatingMode.SYNC);
		return CreateDocuments.doAuditedCreateDocuments("createDocuments",
				docData4CreateList, securityContext, versionLabel, requestId,
				switchRelatedDocuments, requestDetails);

	}

	@WebMethod
	@WebResult(name = "docIdData")
	public DocIdData createDocumentLT(@WebParam(name = "securityContext") SecurityContext securityContext,
									  @WebParam(name = "docProperties") DocProperties docProperties,
									  @WebParam(name = "executorDetails") ExecutorDetails executorDetails,
									  @WebParam(name = "legacyDocumentId")	String legacyDocumentId,
									  @WebParam(name = "versionLabel") String versionLabel,
									  @WebParam(name = "docFiles") List<DocFile> docFiles,
									  @WebParam(name = "customers") List<CustomerKey> customers,
									  @WebParam(name = "accounts") List<BankAccount> accounts,
									  @WebParam(name = "pensionFunds") List<PensionFund> pensionFunds,
									  @WebParam(name = "documentGroupIds") List<String> documentGroupIds,
									  @WebParam(name = "requestId") String requestId,                          
									  @WebParam(name = "requestDetails", mode = WebParam.Mode.OUT)Holder<List<RequestDetails>> requestDetails)
		throws ECMException,
			ECMDetailedException {
		DfsRequestThreadAttributes.operatingMode.set(OperatingMode.SYNC);
		return CreateDocuments.doAuditedCreateDocumentLT("createDocumentLT",
														 securityContext,
														 docProperties,
														 executorDetails,
														 legacyDocumentId,
														 versionLabel,
														 docFiles,
														 customers,
														 accounts,
														 pensionFunds,
														 documentGroupIds,
														 requestId,
														 requestDetails);
	}

	@WebMethod
	@WebResult(name = "docIdDataList")
	public List<DocIdData> createDocumentsAsync(
			@WebParam(name = "docDataForCreateList") List<DocDataForCreate> docData4CreateList,
			@WebParam(name = "securityContext") SecurityContext securityContext,
			@WebParam(name = "versionLabel") String versionLabel,
			@WebParam(name = "requestId") String requestId,
			@WebParam(name = "switchRelatedDocuments") Boolean switchRelatedDocuments,
			@WebParam(name = "requestDetails", mode = WebParam.Mode.OUT) Holder<List<RequestDetails>> requestDetails,
			@WebParam(name = "clntV2") ClntV2 clntV2,
			@WebParam(name = "clntV3") ClntV3 clntV3,
			@WebParam(name = "clntV4") ClntV4 clntV4,
			@WebParam(name = "clntV5") ClntV5 clntV5,
			@WebParam(name = "clntV6") ClntV6 clntV6) throws ECMException,
			ECMDetailedException {
		DfsRequestThreadAttributes.operatingMode.set(OperatingMode.ASYNC);
		return CreateDocuments.doAuditedCreateDocuments("createDocumentsAsync",
				docData4CreateList, securityContext, versionLabel, requestId,
				switchRelatedDocuments, requestDetails);
	}

	@WebMethod
	@WebResult(name = "docIdDataList")
	public List<DocIdData> updateDocumentsByDctmDocumentId(
			@WebParam(name = "docDataForUpdateList") List<DocDataForUpdate> docDataForUpdateList,
			@WebParam(name = "securityContext") SecurityContext securityContext,
			@WebParam(name = "requestId") String requestId,
			@WebParam(name = "requestDetails", mode = WebParam.Mode.OUT) Holder<List<RequestDetails>> requestDetails,
			@WebParam(name = "clntV2") ClntV2 clntV2,
			@WebParam(name = "clntV3") ClntV3 clntV3,
			@WebParam(name = "clntV4") ClntV4 clntV4,
			@WebParam(name = "clntV5") ClntV5 clntV5,
			@WebParam(name = "clntV6") ClntV6 clntV6) throws ECMException,
															 ECMDetailedException {
		DfsRequestThreadAttributes.operatingMode.set(OperatingMode.SYNC);
		return UpdateDocuments.doAuditedUpdateDocumentsByDocumentId(
				"updateDocumentsByDctmDocumentId", false, docDataForUpdateList,
				securityContext, requestId, requestDetails);
	}

	@WebMethod
	@WebResult(name = "docIdDataList")
	public List<DocIdData> updateDocumentsByDctmDocumentIdAsync(
			@WebParam(name = "docDataForUpdateList") List<DocDataForUpdate> docDataForUpdateList,
			@WebParam(name = "securityContext") SecurityContext securityContext,
			@WebParam(name = "requestId") String requestId,
			@WebParam(name = "requestDetails", mode = WebParam.Mode.OUT) Holder<List<RequestDetails>> requestDetails,
			@WebParam(name = "clntV2") ClntV2 clntV2,
			@WebParam(name = "clntV3") ClntV3 clntV3,
			@WebParam(name = "clntV4") ClntV4 clntV4,
			@WebParam(name = "clntV5") ClntV5 clntV5,
			@WebParam(name = "clntV6") ClntV6 clntV6) throws ECMException,
															 ECMDetailedException {
		DfsRequestThreadAttributes.operatingMode.set(OperatingMode.ASYNC);
		return UpdateDocuments.doAuditedUpdateDocumentsByDocumentId(
				"updateDocumentsByDctmDocumentIdAsync", false,
				docDataForUpdateList, securityContext, requestId,
				requestDetails);
	}

	@WebMethod
	@WebResult(name = "docIdDataList")
	public List<DocIdData> updateDocumentsByLegacyDocumentId(
			@WebParam(name = "docDataForUpdateList") List<DocDataForUpdate> docDataForUpdateList,
			@WebParam(name = "securityContext") SecurityContext securityContext,
			@WebParam(name = "requestId") String requestId,
			@WebParam(name = "requestDetails", mode = WebParam.Mode.OUT) Holder<List<RequestDetails>> requestDetails,
			@WebParam(name = "clntV2") ClntV2 clntV2,
			@WebParam(name = "clntV3") ClntV3 clntV3,
			@WebParam(name = "clntV4") ClntV4 clntV4,
			@WebParam(name = "clntV5") ClntV5 clntV5,
			@WebParam(name = "clntV6") ClntV6 clntV6) throws ECMException,
			ECMDetailedException {

		DfsRequestThreadAttributes.operatingMode.set(OperatingMode.SYNC);
		return UpdateDocuments.doAuditedUpdateDocumentsByDocumentId(
				"updateDocumentsByLegacyDocumentId", true,
				docDataForUpdateList, securityContext, requestId,
				requestDetails);
	}

	/**
	 * @param docDataForUpdateList
	 * @param securityContext
	 * @param versionLabel
	 * @param createVersion
	 * @return
	 * @throws ECMException
	 */
	@WebMethod
	@WebResult(name = "docIdDataList")
	public List<DocIdData> updateDocumentsByLegacyDocumentIdAsync(
			@WebParam(name = "docDataForUpdateList") List<DocDataForUpdate> docDataForUpdateList,
			@WebParam(name = "securityContext") SecurityContext securityContext,
			@WebParam(name = "requestId") String requestId,
			@WebParam(name = "requestDetails", mode = WebParam.Mode.OUT) Holder<List<RequestDetails>> requestDetails,
			@WebParam(name = "clntV2") ClntV2 clntV2,
			@WebParam(name = "clntV3") ClntV3 clntV3,
			@WebParam(name = "clntV4") ClntV4 clntV4,
			@WebParam(name = "clntV5") ClntV5 clntV5,
			@WebParam(name = "clntV6") ClntV6 clntV6) throws ECMException,
															 ECMDetailedException {
		DfsRequestThreadAttributes.operatingMode.set(OperatingMode.ASYNC);
		return UpdateDocuments.doAuditedUpdateDocumentsByDocumentId(
				"updateDocumentsByLegacyDocumentIdAsync", true,
				docDataForUpdateList, securityContext, requestId,
				requestDetails);
	}

	@WebMethod
	@WebResult(name = "docIdData")
	public DocIdData updateDocumentVersionByLegacyDocumentId(
			@WebParam(name = "docDataForUpdate") DocDataForUpdate docDataForUpdate,
			@WebParam(name = "securityContext") SecurityContext securityContext,
			@WebParam(name = "versionLabel") String versionLabel,
			@WebParam(name = "requestId") String requestId,
			@WebParam(name = "requestDetails", mode = WebParam.Mode.OUT) Holder<List<RequestDetails>> requestDetails,
			@WebParam(name = "clntV2") ClntV2 clntV2,
			@WebParam(name = "clntV3") ClntV3 clntV3,
			@WebParam(name = "clntV4") ClntV4 clntV4,
			@WebParam(name = "clntV5") ClntV5 clntV5,
			@WebParam(name = "clntV6") ClntV6 clntV6) throws ECMException,
															 ECMDetailedException {
		DfsRequestThreadAttributes.operatingMode.set(OperatingMode.SYNC);
		return UpdateDocuments.doAuditedUpdateDocumentVersionByDocumentId(
				"updateDocumentVersionByLegacyDocumentId", true,false,
				docDataForUpdate, securityContext, versionLabel, requestId,
				requestDetails);
	}

	@WebMethod
	@WebResult(name = "docIdData")
	public DocIdData updateDocumentVersionByLegacyDocumentIdAsync(
			@WebParam(name = "docDataForUpdate") DocDataForUpdate docDataForUpdate,
			@WebParam(name = "securityContext") SecurityContext securityContext,
			@WebParam(name = "versionLabel") String versionLabel,
			@WebParam(name = "requestId") String requestId,
			@WebParam(name = "requestDetails", mode = WebParam.Mode.OUT) Holder<List<RequestDetails>> requestDetails,
			@WebParam(name = "clntV2") ClntV2 clntV2,
			@WebParam(name = "clntV3") ClntV3 clntV3,
			@WebParam(name = "clntV4") ClntV4 clntV4,
			@WebParam(name = "clntV5") ClntV5 clntV5,
			@WebParam(name = "clntV6") ClntV6 clntV6) throws ECMException,
															 ECMDetailedException {
		DfsRequestThreadAttributes.operatingMode.set(OperatingMode.ASYNC);
		return UpdateDocuments.doAuditedUpdateDocumentVersionByDocumentId(
				"updateDocumentVersionByLegacyDocumentIdAsync", true, false,
				docDataForUpdate, securityContext, versionLabel, requestId,
				requestDetails);
	}
	
	@WebMethod
	@WebResult(name = "docIdData")
	public DocIdData putDocumentVersionByLegacyDocumentId(
			@WebParam(name = "docDataForUpdate") DocDataForUpdate docDataForUpdate,
			@WebParam(name = "securityContext") SecurityContext securityContext,
			@WebParam(name = "versionLabel") String versionLabel,
			@WebParam(name = "requestId") String requestId,
			@WebParam(name = "requestDetails", mode = WebParam.Mode.OUT) Holder<List<RequestDetails>> requestDetails,
			@WebParam(name = "clntV2") ClntV2 clntV2,
			@WebParam(name = "clntV3") ClntV3 clntV3,
			@WebParam(name = "clntV4") ClntV4 clntV4,
			@WebParam(name = "clntV5") ClntV5 clntV5,
			@WebParam(name = "clntV6") ClntV6 clntV6) throws ECMException,
															 ECMDetailedException {
		DfsRequestThreadAttributes.operatingMode.set(OperatingMode.SYNC);
		return UpdateDocuments.doAuditedUpdateDocumentVersionByDocumentId(
				"putDocumentVersionByLegacyDocumentId", true, true,
				docDataForUpdate, securityContext, versionLabel, requestId,
				requestDetails);
	}

	@WebMethod
	@WebResult(name = "docIdData")
	public DocIdData putDocumentVersionByLegacyDocumentIdAsync(
			@WebParam(name = "docDataForUpdate") DocDataForUpdate docDataForUpdate,
			@WebParam(name = "securityContext") SecurityContext securityContext,
			@WebParam(name = "versionLabel") String versionLabel,
			@WebParam(name = "requestId") String requestId,
			@WebParam(name = "requestDetails", mode = WebParam.Mode.OUT) Holder<List<RequestDetails>> requestDetails,
			@WebParam(name = "clntV2") ClntV2 clntV2,
			@WebParam(name = "clntV3") ClntV3 clntV3,
			@WebParam(name = "clntV4") ClntV4 clntV4,
			@WebParam(name = "clntV5") ClntV5 clntV5,
			@WebParam(name = "clntV6") ClntV6 clntV6) throws ECMException,
															 ECMDetailedException {
		DfsRequestThreadAttributes.operatingMode.set(OperatingMode.ASYNC);
		return UpdateDocuments.doAuditedUpdateDocumentVersionByDocumentId(
				"putDocumentVersionByLegacyDocumentIdAsync", true, true,
				docDataForUpdate, securityContext, versionLabel, requestId,
				requestDetails);
	}


	@WebMethod
	@WebResult(name = "docIdData")
	public DocIdData updateDocumentVersionByDctmDocumentId(
			@WebParam(name = "docDataForUpdate") DocDataForUpdate docDataForUpdate,
			@WebParam(name = "securityContext") SecurityContext securityContext,
			@WebParam(name = "versionLabel") String versionLabel,
			@WebParam(name = "requestId") String requestId,
			@WebParam(name = "requestDetails", mode = WebParam.Mode.OUT) Holder<List<RequestDetails>> requestDetails,
			@WebParam(name = "clntV2") ClntV2 clntV2,
			@WebParam(name = "clntV3") ClntV3 clntV3,
			@WebParam(name = "clntV4") ClntV4 clntV4,
			@WebParam(name = "clntV5") ClntV5 clntV5,
			@WebParam(name = "clntV6") ClntV6 clntV6) throws ECMException,
															 ECMDetailedException {
		DfsRequestThreadAttributes.operatingMode.set(OperatingMode.SYNC);
		return UpdateDocuments.doAuditedUpdateDocumentVersionByDocumentId(
				"updateDocumentVersionByDctmDocumentId", false, false,
				docDataForUpdate, securityContext, versionLabel, requestId,
				requestDetails);
	}

	@WebMethod
	@WebResult(name = "docIdData")
	public DocIdData updateDocumentVersionByDctmDocumentIdAsync(
			@WebParam(name = "docDataForUpdate") DocDataForUpdate docDataForUpdate,
			@WebParam(name = "securityContext") SecurityContext securityContext,
			@WebParam(name = "versionLabel") String versionLabel,
			@WebParam(name = "requestId") String requestId,
			@WebParam(name = "requestDetails", mode = WebParam.Mode.OUT) Holder<List<RequestDetails>> requestDetails,
			@WebParam(name = "clntV2") ClntV2 clntV2,
			@WebParam(name = "clntV3") ClntV3 clntV3,
			@WebParam(name = "clntV4") ClntV4 clntV4,
			@WebParam(name = "clntV5") ClntV5 clntV5,
			@WebParam(name = "clntV6") ClntV6 clntV6) throws ECMException,
															 ECMDetailedException {
		DfsRequestThreadAttributes.operatingMode.set(OperatingMode.SYNC);
		return UpdateDocuments.doAuditedUpdateDocumentVersionByDocumentId(
				"updateDocumentVersionByDctmDocumentIdAsync", false, false,
				docDataForUpdate, securityContext, versionLabel, requestId,
				requestDetails);
	}

	// OfflineExclude
	@WebMethod
	@WebResult(name = "docDataForRetrieve")
	public DocDataForRetrieve retrieveDocForLegacyDocumentId(
			@WebParam(name = "legacyDocumentId") String legacyDocumentId,
			@WebParam(name = "docFormat") String docFormat,
			@WebParam(name = "executorDetails") ExecutorDetails executorDetails,
			@WebParam(name = "securityContext") SecurityContext securityContext,
			@WebParam(name = "fetchTypeSet") FetchTypeSet fetchTypeSet,
			@WebParam(name = "docRetrievalFlags") DocRetrievalFlags flags,
			@WebParam(name = "versionLabel") String versionLabel,
			@WebParam(name = "docDataCheck") DocData  docDataCheck,
			@WebParam(name = "clntV2") ClntV2 clntV2,
			@WebParam(name = "clntV3") ClntV3 clntV3,
			@WebParam(name = "clntV4") ClntV4 clntV4,
			@WebParam(name = "clntV5") ClntV5 clntV5,
			@WebParam(name = "clntV6") ClntV6 clntV6) throws ECMException,
															 ECMDetailedException {
		return RetrieveDocuments.doRetrieveDoc(
				"retrieveDocForLegacyDocumentId", legacyDocumentId, true,
				docFormat, executorDetails, securityContext, fetchTypeSet,
				flags, versionLabel, docDataCheck);
	}

	// OfflineExcludeEnd

	// OfflineExclude
	@WebMethod
	@WebResult(name = "docDataForRetrieve")
	public DocDataForRetrieve retrieveDocForDctmDocumentId(
			@WebParam(name = "dctmDocumentId") String dctmDocumentId,
			@WebParam(name = "docFormat") String docFormat,
			@WebParam(name = "executorDetails") ExecutorDetails executorDetails,
			@WebParam(name = "securityContext") SecurityContext securityContext,
			@WebParam(name = "fetchTypeSet") FetchTypeSet fetchTypeSet,
			@WebParam(name = "docRetrievalFlags") DocRetrievalFlags flags,
			@WebParam(name = "versionLabel") String versionLabel,
			@WebParam(name = "docDataCheck") DocData  docDataCheck,
			@WebParam(name = "clntV2") ClntV2 clntV2,
			@WebParam(name = "clntV3") ClntV3 clntV3,
           @WebParam(name = "clntV4") ClntV4 clntV4,
			@WebParam(name = "clntV5") ClntV5 clntV5,
			@WebParam(name = "clntV6") ClntV6 clntV6) throws ECMException,
														 ECMDetailedException {
		return RetrieveDocuments.doRetrieveDoc("retrieveDocForDctmDocumentId",
				dctmDocumentId, false, docFormat, executorDetails,
											   securityContext, fetchTypeSet, flags, versionLabel, docDataCheck);
	}

	// OfflineExcludeEnd

	/**
	 * Find all Documents {@link DocumentData} according to the document type (
	 * that can be {@link BaseCustomDfs.BNHP_BASE_HEADER_TYPE} or it sub-types)
	 * , group_id and <br>
	 * the fetch type that can be one of: <li>meta data only</li> <li>document
	 * binary content</li> <li>both meta and binary</li>
	 * 
	 * 
	 * @param documentGroupId
	 *            - id of group union
	 * @param docType
	 *            - root type of document retrieve (all sub-types will be
	 *            fetched to)
	 * @param searchDefinition
	 *            - parameters of searched range
	 * @param securityContext
	 *            - authentication related data
	 * @param fetchTypeSet
	 *            - bean with one of {@link FetchType} sub-types , to determine
	 *            which data to retrieve
	 * 
	 * @return - status of search execution and list of {@link DocumentData}
	 *         describing found documents
	 */
	// OfflineExclude
	@WebMethod
	@WebResult(name = "searchResult")
	public SearchResult searchByDocumentGroupId(
			@WebParam(name = "documentGroupId") String documentGroupId,
			@WebParam(name = "docType") String docType,
			@WebParam(name = "searchDefinition") SearchDefinition searchDefinition,
			@WebParam(name = "securityContext") SecurityContext securityContext,
			@WebParam(name = "fetchTypeSet") FetchTypeSet fetchTypeSet,
			@WebParam(name = "docRetrievalFlags") DocRetrievalFlags flags,
			@WebParam(name = "domainContext") BHSearchDomainActivityDataContext domainContext,
			@WebParam(name = "oprBranchDataContext") BHSearchOperationBranchDataContext oprBranchDataContext,
			@WebParam(name = "dateDataContext") BHSearchDateRangeDataContext dateDataContext,
			@WebParam(name = "pakidDataContext") BHPeulaPakidDataContext pakidDataContext,
			@WebParam(name = "generalSearchDataContext") BHSearchGeneralDataContext generalSearchDataContext,
			@WebParam(name = "clntV2") ClntV2 clntV2,
			@WebParam(name = "clntV3") ClntV3 clntV3,
			@WebParam(name = "clntV4") ClntV4 clntV4,
			@WebParam(name = "clntV5") ClntV5 clntV5,
			@WebParam(name = "clntV6") ClntV6 clntV6) throws ECMException {

		return SearchDocuments.searchByDocumentGroupId(documentGroupId,
				docType, searchDefinition, securityContext, fetchTypeSet,
				flags, domainContext, oprBranchDataContext, dateDataContext,
				pakidDataContext, generalSearchDataContext, clntV2);
	}

	// OfflineExcludeEnd

	// OfflineExclude
	@WebMethod
	@WebResult(name = "searchResult")
	public SearchResult searchAllDocVersion(
			@WebParam(name = "documentId") String documentId,
			@WebParam(name = "securityContext") SecurityContext securityContext,
			@WebParam(name = "fetchTypeSet") FetchTypeSet fetchTypeSet,
			@WebParam(name = "docRetrievalFlags") DocRetrievalFlags flags,
			@WebParam(name = "searchDefinition") SearchDefinition searchDefinition,
			// @WebParam(name = "pakidDataContext") BHPeulaPakidDataContext
			// pakidDataContext,
			@WebParam(name = "executorDetails") ExecutorDetails executorDetails,
			@WebParam(name = "clntV2") ClntV2 clntV2,
			@WebParam(name = "clntV3") ClntV3 clntV3,
			@WebParam(name = "clntV4") ClntV4 clntV4,
			@WebParam(name = "clntV5") ClntV5 clntV5,
			@WebParam(name = "clntV6") ClntV6 clntV6) throws ECMException {
		return SearchDocuments.searchAllDocVersion(documentId, securityContext,
				fetchTypeSet, flags, searchDefinition, executorDetails, clntV2);
	}

	// OfflineExcludeEnd

	/**
	 * Find meta data of documents, according to the existing DQL query , that
	 * will be found by document type 'docType' and query name 'queryName'.By
	 * placing provided parameters to it.
	 * 
	 * @param queryName
	 *            - query name
	 * @param docType
	 *            - top level document type to query
	 * @param parameters
	 *            - list of parameters {@link QueryParam} to be placed in query
	 * @param searchDefinition
	 *            -
	 * @param securityContext
	 * 
	 * @return - status of search execution and list of {@link DocumentData}
	 *         describe found documents
	 */
	// OfflineExclude
	@WebMethod
	@WebResult(name = "searchResult")
	public SearchResult preparedQueryMetaSearch(
			@WebParam(name = "securityContext") SecurityContext securityContext,
			@WebParam(name = "fetchTypeSet") FetchTypeSet fetchTypeSet,
			@WebParam(name = "docRetrievalFlags") DocRetrievalFlags flags,
			@WebParam(name = "searchDefinition") SearchDefinition searchDefinition,
			@WebParam(name = "preparedQuery") PreparedQuery preparedQuery,
			@WebParam(name = "executorDetails") ExecutorDetails executorDetails,
			@WebParam(name = "clntV2") ClntV2 clntV2,
			@WebParam(name = "clntV3") ClntV3 clntV3,
			@WebParam(name = "clntV4") ClntV4 clntV4,
			@WebParam(name = "clntV5") ClntV5 clntV5,
			@WebParam(name = "clntV6") ClntV6 clntV6) throws ECMException {
		return SearchDocuments.preparedQueryMetaSearch(securityContext,
				fetchTypeSet, flags, searchDefinition, preparedQuery,
				executorDetails, clntV2);
	}


	/**
	 * Find meta data of documents, according to the existing DQL query , that
	 * will be found by document type 'docType' and query name 'queryName'.By
	 * placing provided parameters to it.
	 * 
	 * @param queryName
	 *            - query name
	 * @param docType
	 *            - top level document type to query
	 * @param parameters
	 *            - list of parameters {@link QueryParam} to be placed in query
	 * @param searchDefinition
	 *            -
	 * @param securityContext
	 * 
	 * @return - status of search execution and list of {@link DocumentData}
	 *         describe found documents
	 */
	// OfflineExclude
	@WebMethod
	@WebResult(name = "searchStatus")
	public SearchStatus preparedQueryMetaSearchLT(
			@WebParam(name = "securityContext") SecurityContext securityContext,
			@WebParam(name = "docRetrievalFlags") DocRetrievalFlags flags,
			@WebParam(name = "searchDefinition") SearchDefinition searchDefinition,
			@WebParam(name = "searchName") String searchName,
			@WebParam(name = "parameters") List<PropertyKeyValue> parameters,
			@WebParam(name = "executorDetails") ExecutorDetails executorDetails,
			@WebParam(name = "documentTikLave", mode = WebParam.Mode.OUT) Holder<List<DocumentTikLave>> documentList,
			@WebParam(name = "clntV2") ClntV2 clntV2,
			@WebParam(name = "clntV3") ClntV3 clntV3,
			@WebParam(name = "clntV4") ClntV4 clntV4,
			@WebParam(name = "clntV5") ClntV5 clntV5,
			@WebParam(name = "clntV6") ClntV6 clntV6) throws ECMException {
		return SearchDocuments.preparedQueryMetaSearchLT(securityContext,
														 flags, searchDefinition, searchName, parameters,
														 executorDetails,
														 documentList,
														 clntV2);
	}

	
	
	// OfflineExcludeEnd

	/**
	 * @param docEventDataForCreateList
	 * @param securityContext
	 * @return
	 * @throws ECMException
	 */
	@WebMethod
	@WebResult(name = "dctmDocumentIdList")
	public List<String> addDocEventDataToDocuments(
			@WebParam(name = "docEventDataForCreateList") List<DocEventDataForCreate> docEventDataForCreateList,
			@WebParam(name = "securityContext") SecurityContext securityContext,
			@WebParam(name = "clntV2") ClntV2 clntV2,
			@WebParam(name = "clntV3") ClntV3 clntV3,
			@WebParam(name = "clntV4") ClntV4 clntV4,
			@WebParam(name = "clntV5") ClntV5 clntV5,
			@WebParam(name = "clntV6") ClntV6 clntV6) throws ECMException {
		return AddDocEventData.addDocEventDataToDocuments(
				docEventDataForCreateList, securityContext, clntV2);
	}

	// OfflineExclude
	@WebMethod
	@WebResult(name = "docEventDataList")
	public List<DocEventData> retrieveDocEventDataListByLegacyDocumentId(
			@WebParam(name = "legacyDocumentId") String legacyDocumentId,
			@WebParam(name = "securityContext") SecurityContext securityContext,
			@WebParam(name = "executorDetails") ExecutorDetails executorDetails,
			@WebParam(name = "eventFilter") EventFilter eventFilter,
			@WebParam(name = "docEventDataDescrList", mode = WebParam.Mode.OUT) Holder<List<DocEventDataDescr>> docEventDataDescrList,
			@WebParam(name = "clntV2") ClntV2 clntV2,
			@WebParam(name = "clntV3") ClntV3 clntV3,
			@WebParam(name = "clntV4") ClntV4 clntV4,
			@WebParam(name = "clntV5") ClntV5 clntV5,
			@WebParam(name = "clntV6") ClntV6 clntV6) throws ECMException {
		return RetrieveDocuments.doRetrieveDocEventDataListByDocumentId(
				"retrieveDocEventDataListByLegacyDocumentId", true,
				legacyDocumentId, securityContext, executorDetails,
				eventFilter, docEventDataDescrList);
	}

	// OfflineExcludeEnd
	// OfflineExclude
	@WebMethod
	@WebResult(name = "docEventDataList")
	public List<DocEventData> retrieveDocEventDataListByDctmDocumentId(
			@WebParam(name = "dctmDocumentId") String dctmDocumentId,
			@WebParam(name = "securityContext") SecurityContext securityContext,
			@WebParam(name = "executorDetails") ExecutorDetails executorDetails,
			@WebParam(name = "eventsFilter") EventFilter eventFilter,
			@WebParam(name = "docEventDataDescrList", mode = WebParam.Mode.OUT) Holder<List<DocEventDataDescr>> docEventDataDescrList,
			@WebParam(name = "clntV2") ClntV2 clntV2,
			@WebParam(name = "clntV3") ClntV3 clntV3,
			@WebParam(name = "clntV4") ClntV4 clntV4,
			@WebParam(name = "clntV5") ClntV5 clntV5,
			@WebParam(name = "clntV6") ClntV6 clntV6) throws ECMException {
		return RetrieveDocuments.doRetrieveDocEventDataListByDocumentId(
				"retrieveDocEventDataListByLegacyDocumentId", false,
				dctmDocumentId, securityContext, executorDetails, eventFilter,
				docEventDataDescrList);

	}

	// OfflineExcludeEnd
	// OfflineExclude
	@WebMethod
	@WebResult(name = "codeTableDataContext")
	public List<CodeTableDataContext> getCodeTableEntries(
			@WebParam(name = "fetchAllCategories") Boolean fetchAllCategories,
			@WebParam(name = "codeCategory") Integer codeCategory,
			@WebParam(name = "securityContext") SecurityContext securityContext,
			@WebParam(name = "totalResult", mode = WebParam.Mode.OUT) Holder<Integer> totalResult,
			@WebParam(name = "clntV2") ClntV2 clntV2,
			@WebParam(name = "clntV3") ClntV3 clntV3,
			@WebParam(name = "clntV4") ClntV4 clntV4,
			@WebParam(name = "clntV5") ClntV5 clntV5,
			@WebParam(name = "clntV6") ClntV6 clntV6) throws ECMException {
		return TableEntries.getCodeTableEntries(fetchAllCategories,
				codeCategory, securityContext, totalResult, clntV2);
	}

	// OfflineExcludeEnd
	// OfflineExclude
	@WebMethod
	@WebResult(name = "docDataMfContext")
	public List<DocDataMfContext> getMfTablesEntries(
			@WebParam(name = "fetchAllCategories") Boolean fetchAllCategories,
			@WebParam(name = "documentFormId") String documentFormId,
			@WebParam(name = "securityContext") SecurityContext securityContext,
			@WebParam(name = "totalResult", mode = WebParam.Mode.OUT) Holder<Integer> totalResult,
			@WebParam(name = "clntV2") ClntV2 clntV2,
			@WebParam(name = "clntV3") ClntV3 clntV3,
			@WebParam(name = "clntV4") ClntV4 clntV4,
			@WebParam(name = "clntV5") ClntV5 clntV5,
			@WebParam(name = "clntV6") ClntV6 clntV6) throws ECMException {
		return TableEntries.getMfTablesEntries(fetchAllCategories,
				documentFormId, securityContext, totalResult, clntV2);
	}

	// OfflineExcludeEnd
	// OfflineExclude
	@WebMethod
	@WebResult(name = "currencyDataContext")
	public List<CurrencyDataContext> getMfTablesCurrencyEntries(
			@WebParam(name = "securityContext") SecurityContext securityContext,
			@WebParam(name = "totalResult", mode = WebParam.Mode.OUT) Holder<Integer> totalResult,
			@WebParam(name = "clntV2") ClntV2 clntV2,
			@WebParam(name = "clntV3") ClntV3 clntV3,
			@WebParam(name = "clntV4") ClntV4 clntV4,
			@WebParam(name = "clntV5") ClntV5 clntV5,
			@WebParam(name = "clntV6") ClntV6 clntV6) throws ECMException {
		return TableEntries.getMfTablesCurrencyEntries(securityContext,
				totalResult, clntV2);
	}

	// OfflineExcludeEnd
	// OfflineExclude
	@WebMethod
	@WebResult(name = "requestDetailsList")
	public List<RequestDetails> getRequestStatus(
			@WebParam(name = "securityContext") SecurityContext securityContext,
			@WebParam(name = "requestId") String requestId,
			@WebParam(name = "projectId") Integer projectId,
			@WebParam(name = "systemCode") Integer systemCode,
			@WebParam(name = "dataListListResult", mode = WebParam.Mode.OUT) Holder<List<DocIdsDataList>> dataListListResult,
			@WebParam(name = "faultResultList", mode = WebParam.Mode.OUT) Holder<List<String>> faultResultList,
			@WebParam(name = "clntV2") ClntV2 clntV2,
			@WebParam(name = "clntV3") ClntV3 clntV3,
			@WebParam(name = "clntV4") ClntV4 clntV4,
			@WebParam(name = "clntV5") ClntV5 clntV5,
			@WebParam(name = "clntV6") ClntV6 clntV6) throws ECMException {
		return RequestStatus.getRequestStatusList(securityContext, requestId,
				projectId, systemCode, dataListListResult, faultResultList,
				clntV2);
	}

	// OfflineExcludeEnd

	/**
	 * Performs arbitrary business transaction
	 */
	@WebMethod
	@WebResult(name = "requestResultsList")
	public List<NamedQueryParam> applicativeRequest(
			@WebParam(name = "securityContext") SecurityContext securityContext,
			@WebParam(name = "preparedQuery") PreparedQuery preparedQuery,
			@WebParam(name = "executorDetails") ExecutorDetails executorDetails,
			@WebParam(name = "requestId") String requestId,
			@WebParam(name = "requestDetails", mode = WebParam.Mode.OUT) Holder<List<RequestDetails>> requestDetails,
			@WebParam(name = "clntV2") ClntV2 clntV2,
			@WebParam(name = "clntV3") ClntV3 clntV3,
			@WebParam(name = "clntV4") ClntV4 clntV4,
			@WebParam(name = "clntV5") ClntV5 clntV5,
			@WebParam(name = "clntV6") ClntV6 clntV6) throws ECMException,
															 ECMDetailedException {
		DfsRequestThreadAttributes.operatingMode.set(OperatingMode.SYNC);
		return ApplicativeRequest.applicativeRequest(securityContext,
				preparedQuery, executorDetails, clntV2, requestId,
				requestDetails);
	}

	@WebMethod
	@WebResult(name = "requestResultsList")
	public List<NamedQueryParam> applicativeRequestAsync(
			@WebParam(name = "securityContext") SecurityContext securityContext,
			@WebParam(name = "preparedQuery") PreparedQuery preparedQuery,
			@WebParam(name = "executorDetails") ExecutorDetails executorDetails,
			@WebParam(name = "requestId") String requestId,
			@WebParam(name = "requestDetails", mode = WebParam.Mode.OUT) Holder<List<RequestDetails>> requestDetails,
			@WebParam(name = "clntV2") ClntV2 clntV2,
			@WebParam(name = "clntV3") ClntV3 clntV3,
			@WebParam(name = "clntV4") ClntV4 clntV4,
			@WebParam(name = "clntV5") ClntV5 clntV5,
			@WebParam(name = "clntV6") ClntV6 clntV6) throws ECMException,
															 ECMDetailedException {
		DfsRequestThreadAttributes.operatingMode.set(OperatingMode.ASYNC);
		return ApplicativeRequest.applicativeRequest(securityContext,
				preparedQuery, executorDetails, clntV2, requestId,
				requestDetails);
	}


	/**
	 * Performs arbitrary business transaction
	 */
	@WebMethod
	@WebResult(name = "requestResultsList")
	public List<PropertyKeyValue> applicativeRequestLT(
			@WebParam(name = "securityContext") SecurityContext securityContext,
			@WebParam(name = "requestName") String requestName,
			@WebParam(name = "parameters") List<PropertyKeyValue> parameters,
			@WebParam(name = "executorDetails") ExecutorDetails executorDetails,
			@WebParam(name = "requestId") String requestId,
			@WebParam(name = "requestDetails", mode = WebParam.Mode.OUT)
			Holder<List<RequestDetails>> requestDetails,
			//@WebParam(name = "results", mode = WebParam.Mode.OUT) > results,
			@WebParam(name = "clntV5") ClntV5 clntV5,
			@WebParam(name = "clntV6") ClntV6 clntV6) 
		throws ECMException,  ECMDetailedException {
		DfsRequestThreadAttributes.operatingMode.set(OperatingMode.SYNC);
		return ApplicativeRequest.applicativeRequestLT(
	   												   securityContext,
													   requestName,
													   parameters,
													   executorDetails,
													   requestDetails,
													   requestId
													   );
	}

	
	@WebMethod
	@WebResult(name = "docIdData")
	public DocIdData cancelDocumentByLegacyDocumentId(
		    @WebParam(name = "legacyDocumentId") String legacyDocumentId,
			@WebParam(name = "securityContext") SecurityContext securityContext,
			@WebParam(name = "executorDetails") ExecutorDetails executorDetails,
			@WebParam(name = "requestId") String requestId,
			@WebParam(name = "requestDetails", mode = WebParam.Mode.OUT)
			Holder<List<RequestDetails>> requestDetails,
			@WebParam(name = "clntV2") ClntV2 clntV2,
			@WebParam(name = "clntV3") ClntV3 clntV3,
			@WebParam(name = "clntV4") ClntV4 clntV4,
			@WebParam(name = "clntV5") ClntV5 clntV5,
			@WebParam(name = "clntV6") ClntV6 clntV6) throws ECMException,
															 ECMDetailedException {
		DfsRequestThreadAttributes.operatingMode.set(OperatingMode.SYNC);
		return CancelDocument.cancelDocument(legacyDocumentId,
									  true,
									  securityContext,
									  executorDetails,
									  null,
									  requestId,
									  requestDetails);
	}

	@WebMethod
	@WebResult(name = "docIdData")
	public DocIdData cancelDocumentByDctmDocumentId(
		    @WebParam(name = "dctmDocumentId") String dctmDocumentId,
			@WebParam(name = "securityContext") SecurityContext securityContext,
			@WebParam(name = "executorDetails") ExecutorDetails executorDetails,
			@WebParam(name = "requestId") String requestId,
			@WebParam(name = "requestDetails", mode = WebParam.Mode.OUT)
			Holder<List<RequestDetails>> requestDetails,
			@WebParam(name = "clntV2") ClntV2 clntV2,
			@WebParam(name = "clntV3") ClntV3 clntV3,
			@WebParam(name = "clntV4") ClntV4 clntV4,
			@WebParam(name = "clntV5") ClntV5 clntV5,
			@WebParam(name = "clntV6") ClntV6 clntV6) throws ECMException,
															 ECMDetailedException {
		DfsRequestThreadAttributes.operatingMode.set(OperatingMode.SYNC);
		return CancelDocument.cancelDocument(dctmDocumentId,
									  false,
									  securityContext,
									  executorDetails,
									  null,
									  requestId,
									  requestDetails);
	}


	@WebMethod
	@WebResult(name = "docIdData")
	public DocIdData cancelDocumentByLegacyDocumentIdAsync(
		    @WebParam(name = "legacyDocumentId") String legacyDocumentId,
			@WebParam(name = "securityContext") SecurityContext securityContext,
			@WebParam(name = "executorDetails") ExecutorDetails executorDetails,
			@WebParam(name = "requestId") String requestId,
			@WebParam(name = "requestDetails", mode = WebParam.Mode.OUT)
			Holder<List<RequestDetails>> requestDetails,
			@WebParam(name = "clntV2") ClntV2 clntV2,
			@WebParam(name = "clntV3") ClntV3 clntV3,
			@WebParam(name = "clntV4") ClntV4 clntV4,
			@WebParam(name = "clntV5") ClntV5 clntV5,
			@WebParam(name = "clntV6") ClntV6 clntV6) throws ECMException,
															 ECMDetailedException {
		DfsRequestThreadAttributes.operatingMode.set(OperatingMode.SYNC);
		return CancelDocument.cancelDocument(legacyDocumentId,
									  true,
									  securityContext,
									  executorDetails,
									  null,
									  requestId,
									  requestDetails);
	}

	
	@WebMethod
	@WebResult(name = "docIdData")
	public DocIdData cancelDocumentByDctmDocumentIdAsync(
		    @WebParam(name = "dctmDocumentId") String dctmDocumentId,
			@WebParam(name = "securityContext") SecurityContext securityContext,
			@WebParam(name = "executorDetails") ExecutorDetails executorDetails,
			@WebParam(name = "requestId") String requestId,
			@WebParam(name = "requestDetails", mode = WebParam.Mode.OUT)
			Holder<List<RequestDetails>> requestDetails,
			@WebParam(name = "clntV2") ClntV2 clntV2,
			@WebParam(name = "clntV3") ClntV3 clntV3,
			@WebParam(name = "clntV4") ClntV4 clntV4,
			@WebParam(name = "clntV5") ClntV5 clntV5,
			@WebParam(name = "clntV6") ClntV6 clntV6) throws ECMException,
															 ECMDetailedException {
		DfsRequestThreadAttributes.operatingMode.set(OperatingMode.SYNC);
		return CancelDocument.cancelDocument(dctmDocumentId,
									  false,
									  securityContext,
									  executorDetails,
									  null,
									  requestId,
									  requestDetails);
	}

}


file Read:C:\Users\AP068\git\documentum\duecmcustomerwrappers\ESB\BnhpDFSWrapper\ejbModule\bnhp\infra\dfs\services\DocumentumServicesJmsWrapperHandlers.xml
-----------------------------------------------------
<?xml version="1.0" encoding="UTF-8"?>
<jws:handler-chains xmlns:jws="http://java.sun.com/xml/ns/javaee">
<!-- Note:  The '*" denotes a wildcard. -->
	<jws:handler-chain name="DocumentumServicesJmsWrapperHandlersChain">
		<!--jws:protocol-bindings>##SOAP11_HTTP ##ANOTHER_BINDING</jws:protocol-bindings>
		<jws:port-name-pattern 
              xmlns:ns1="http://handlersample.samples.ibm.com/">ns1:MySampl*</jws:port-name-pattern>
        <jws:service-name-pattern 
              xmlns:ns1="http://handlersample.samples.ibm.com/">ns1:*</jws:service-name-pattern-->
		<jws:handler>
			<jws:handler-class>bnhp.infra.dfs.services.HackHandler</jws:handler-class>
		</jws:handler>
		<jws:handler>
			<jws:handler-class>bnhp.infra.dfs.services.SAFVersionHandler</jws:handler-class>
		</jws:handler>
		<jws:handler>
			<jws:handler-class>bnhp.infra.dfs.services.RequestHandler</jws:handler-class>
		</jws:handler>
		<jws:handler>
			<jws:handler-class>bnhp.infra.dfs.services.DctmRequestIdHandler</jws:handler-class>
		</jws:handler>
		<jws:handler>
			<jws:handler-class>bnhp.infra.dfs.services.JMSHandler</jws:handler-class>
		</jws:handler>
		
		
	</jws:handler-chain>
	
</jws:handler-chains>


file Read:C:\Users\AP068\git\documentum\duecmcustomerwrappers\ESB\BnhpDFSWrapper\ejbModule\bnhp\infra\dfs\services\TableEntries.java
-----------------------------------------------------
package bnhp.infra.dfs.services;

import java.util.List;

import javax.xml.ws.Holder;

import bnhp.infra.dfs.model.business.CodeTableDataContext;
import bnhp.infra.dfs.model.business.CurrencyDataContext;
import bnhp.infra.dfs.model.business.DocDataMfContext;
import bnhp.infra.dfs.model.business.SecurityContext;
import bnhp.infra.dfs.model.service.ClntV2;
import bnhp.infra.dfs.services.exceptions.ECMException;
import bnhp.infra.dfs.services.utils.AuditUtils;
import bnhp.infra.dfs.services.utils.ServiceUtils;

import com.emc.documentum.fs.rt.context.IServiceContext;
import com.emc.documentum.fs.rt.context.ServiceFactory;
import com.services.infra.bnhp.client.IGetEntriesService;

public class TableEntries {
	protected static List<CodeTableDataContext> getCodeTableEntries(
			Boolean fetchAllCategories, Integer codeCategory,
			SecurityContext securityContext, Holder<Integer> totalResult,
			ClntV2 clntV2) throws ECMException {
		long startTS = System.currentTimeMillis();
		boolean success = false;
		String serviceName = "getCodeTableEntries";
		List<CodeTableDataContext> result = null;

		String moreInfo = " fetchAllCategories= " + fetchAllCategories
				+ " codeCategory= " + codeCategory;
		AuditUtils.logDetailedEnterStatus(serviceName, securityContext,
				moreInfo);

		try {
			ServiceUtils.applyDefaults(securityContext);
			IServiceContext context = ServiceUtils
					.createServiceContext(securityContext);
			IGetEntriesService tablesService = ServiceFactory.getInstance()
					.getLocalService(IGetEntriesService.class, context);
			result = tablesService.getCodeTablesEntries(fetchAllCategories,
					codeCategory, securityContext, totalResult);
			success = true;
			return result;
		} catch (Exception e) {
			AuditUtils.logDetailedError(e, serviceName);
			throw new ECMException(e);
		} finally {
			AuditUtils.logDetailedFinishStatus(serviceName, success, startTS,
					(Object) result);
		}
	}

	protected static List<DocDataMfContext> getMfTablesEntries(
			Boolean fetchAllCategories, String documentFormId,
			SecurityContext securityContext, Holder<Integer> totalResult,
			ClntV2 clntV2) throws ECMException {
		long startTS = System.currentTimeMillis();
		boolean success = false;
		String serviceName = "getMfTablesEntries";
		List<DocDataMfContext> result = null;

		String moreInfo = " fetchAllCategories= " + fetchAllCategories
				+ " zihuyKtlgTofes=" + documentFormId;
		AuditUtils.logDetailedEnterStatus(serviceName, securityContext,
				moreInfo);
		try {
			ServiceUtils.applyDefaults(securityContext);
			IServiceContext context = ServiceUtils
					.createServiceContext(securityContext);
			IGetEntriesService tablesService = ServiceFactory.getInstance()
					.getLocalService(IGetEntriesService.class, context);
			result = tablesService.getMfTablesEntries(fetchAllCategories,
					documentFormId, securityContext, totalResult);
			success = true;
			return result;
		} catch (Exception e) {
			AuditUtils.logDetailedError(e, serviceName);
			throw new ECMException(e);
		} finally {
			AuditUtils.logDetailedFinishStatus(serviceName, success, startTS,
					(Object) result);
		}
	}

	protected static List<CurrencyDataContext> getMfTablesCurrencyEntries(
			SecurityContext securityContext, Holder<Integer> totalResult,
			ClntV2 clntV2) throws ECMException {
		long startTS = System.currentTimeMillis();
		boolean success = false;
		String serviceName = "getMfTablesCurrencyEntries";
		List<CurrencyDataContext> result = null;

		String moreInfo = "";
		AuditUtils.logDetailedEnterStatus(serviceName, securityContext,
				moreInfo);
		try {
			ServiceUtils.applyDefaults(securityContext);
			IServiceContext context = ServiceUtils
					.createServiceContext(securityContext);
			IGetEntriesService tablesService = ServiceFactory.getInstance()
					.getLocalService(IGetEntriesService.class, context);
			result = tablesService.getMFTablesCurrencyEntries(securityContext,
					totalResult);
			success = true;
			return result;
		} catch (Exception e) {
			AuditUtils.logDetailedError(e, serviceName);
			throw new ECMException(e);
		} finally {
			AuditUtils.logDetailedFinishStatus(serviceName, success, startTS,
					(Object) result);
		}
	}
}


file Read:C:\Users\AP068\git\documentum\duecmcustomerwrappers\ESB\BnhpDFSWrapper\ejbModule\META-INF\ejb-jar.xml
-----------------------------------------------------
<?xml version="1.0" encoding="UTF-8"?>
<ejb-jar version="3.1" xmlns="http://java.sun.com/xml/ns/javaee" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/ejb-jar_3_1.xsd">
  <display-name>BnhpDFSWrapper</display-name>
  <enterprise-beans >
  	<session>
  		<ejb-name>DocumentumServicesJmsWrapper</ejb-name>
  		<ejb-class>bnhp.infra.dfs.services.DocumentumServicesJmsWrapper</ejb-class>
  		<session-type>Stateless</session-type>
  		<transaction-type>Container</transaction-type>
  		<env-entry>
  			<description />
  			<env-entry-name>mqMessageSize</env-entry-name>
  			<env-entry-type>java.lang.Long</env-entry-type>
  			<env-entry-value>4096</env-entry-value>
  		</env-entry>
  	</session>
  	
</enterprise-beans>
</ejb-jar>


file Read:C:\Users\AP068\git\documentum\duecmcustomerwrappers\ESB\BnhpDFSWrapper\ejbModule\META-INF\ibm-ejb-jar-ext.xml
-----------------------------------------------------
<?xml version="1.0" encoding="UTF-8"?>
<ejb-jar-ext
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns="http://websphere.ibm.com/xml/ns/javaee"
    xsi:schemaLocation="http://websphere.ibm.com/xml/ns/javaee http://websphere.ibm.com/xml/ns/javaee/ibm-ejb-jar-ext_1_1.xsd" version="1.1">
  <session name="DocumentumServicesJmsWrapper">
    <start-at-app-start value="true"/>
  </session>

</ejb-jar-ext>



file Read:C:\Users\AP068\git\documentum\duecmcustomerwrappers\ESB\BnhpDFSWrapper\ejbModule\META-INF\webservices.xml
-----------------------------------------------------
<?xml version="1.0" encoding="UTF-8"?>
<webservices xmlns="http://java.sun.com/xml/ns/javaee" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/javaee_web_services_1_3.xsd" version="1.3">
	<webservice-description>
		<webservice-description-name>DocumentumServicesJmsWrapperService</webservice-description-name>
		<port-component>
			<port-component-name>DocumentumServicesJmsWrapper</port-component-name>
			<wsdl-service xmlns:pfx="http://bnhp.infra.services.com">
			pfx:DocumentumServicesJmsWrapperService</wsdl-service>
			<wsdl-port xmlns:pfx="http://bnhp.infra.services.com">
			pfx:DocumentumServicesJmsWrapperPort</wsdl-port>
			<enable-mtom>false</enable-mtom>
			<service-impl-bean>
				<ejb-link>
				DocumentumServicesJmsWrapper</ejb-link>
			</service-impl-bean>
		</port-component>
	</webservice-description>
</webservices>


file Read:C:\Users\AP068\git\documentum\duecmcustomerwrappers\ESB\BnhpDFSWrapper\pom.xml
-----------------------------------------------------
<?xml version="1.0" encoding="UTF-8"?>

<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
	<modelVersion>4.0.0</modelVersion>

	<parent>
		<groupId>com.poalim.documentum</groupId>
		<artifactId>parent</artifactId>
		<version>1.0-SNAPSHOT</version>
	</parent>

	<artifactId>BnhpDFSWrapper</artifactId>
	<packaging>ejb</packaging>
	<name>BnhpDFSWrapper</name>
	<description>BnhpDFSWrapper</description>

	<dependencies>

		<dependency>
			<groupId>was</groupId>
			<artifactId>j2ee</artifactId>
			<scope>provided</scope>
		</dependency>

		<dependency>
			<groupId>com.poalim.dependencies</groupId>
			<artifactId>documentum-71-deps</artifactId>
			<type>pom</type>
			<scope>provided</scope>
		</dependency>

		<dependency>
			<groupId>com.poalim.documentum</groupId>
			<artifactId>BnhpInfraDFServices</artifactId>
			<classifier>basic</classifier>
			<exclusions>
				<exclusion>
					<groupId>*</groupId>
					<artifactId>*</artifactId>
				</exclusion>
			</exclusions>
		</dependency>

		<dependency>
			<groupId>com.poalim.documentum</groupId>
			<artifactId>BnhpWrapperDependencyModule</artifactId>
			<exclusions>
				<exclusion>
					<groupId>*</groupId>
					<artifactId>*</artifactId>
				</exclusion>
			</exclusions>
		</dependency>

		<dependency>
			<groupId>bnhp.infra.dfs.services</groupId>
			<artifactId>BHObjectContexts</artifactId>
		</dependency>

		<dependency>
			<groupId>bnhp.infra.dfs.services</groupId>
			<artifactId>BHInputObjectContexts</artifactId>
		</dependency>

		<dependency>
			<groupId>bnhp.infra.dfs.services</groupId>
			<artifactId>BHSearchContexts</artifactId>
		</dependency>
	</dependencies>

	<build>

		<sourceDirectory>ejbModule</sourceDirectory>
		<resources>
			<resource>
				<directory>ejbModule</directory>
				<excludes>
					<exclude>**/*.java</exclude>
					<exclude>**/.copyarea.db</exclude>
				</excludes>
			</resource>
		</resources>

	</build>


</project>


file Read:C:\Users\AP068\git\documentum\duecmcustomerwrappers\ESB\BnhpDFSWrapper\target\classes\bnhp\infra\dfs\services\DocumentumServicesJmsWrapperHandlers.xml
-----------------------------------------------------
<?xml version="1.0" encoding="UTF-8"?>
<jws:handler-chains xmlns:jws="http://java.sun.com/xml/ns/javaee">
<!-- Note:  The '*" denotes a wildcard. -->
	<jws:handler-chain name="DocumentumServicesJmsWrapperHandlersChain">
		<!--jws:protocol-bindings>##SOAP11_HTTP ##ANOTHER_BINDING</jws:protocol-bindings>
		<jws:port-name-pattern 
              xmlns:ns1="http://handlersample.samples.ibm.com/">ns1:MySampl*</jws:port-name-pattern>
        <jws:service-name-pattern 
              xmlns:ns1="http://handlersample.samples.ibm.com/">ns1:*</jws:service-name-pattern-->
		<jws:handler>
			<jws:handler-class>bnhp.infra.dfs.services.HackHandler</jws:handler-class>
		</jws:handler>
		<jws:handler>
			<jws:handler-class>bnhp.infra.dfs.services.SAFVersionHandler</jws:handler-class>
		</jws:handler>
		<jws:handler>
			<jws:handler-class>bnhp.infra.dfs.services.RequestHandler</jws:handler-class>
		</jws:handler>
		<jws:handler>
			<jws:handler-class>bnhp.infra.dfs.services.DctmRequestIdHandler</jws:handler-class>
		</jws:handler>
		<jws:handler>
			<jws:handler-class>bnhp.infra.dfs.services.JMSHandler</jws:handler-class>
		</jws:handler>
		
		
	</jws:handler-chain>
	
</jws:handler-chains>


file Read:C:\Users\AP068\git\documentum\duecmcustomerwrappers\ESB\BnhpDFSWrapper\target\classes\META-INF\ejb-jar.xml
-----------------------------------------------------
<?xml version="1.0" encoding="UTF-8"?>
<ejb-jar version="3.1" xmlns="http://java.sun.com/xml/ns/javaee" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/ejb-jar_3_1.xsd">
  <display-name>BnhpDFSWrapper</display-name>
  <enterprise-beans >
  	<session>
  		<ejb-name>DocumentumServicesJmsWrapper</ejb-name>
  		<ejb-class>bnhp.infra.dfs.services.DocumentumServicesJmsWrapper</ejb-class>
  		<session-type>Stateless</session-type>
  		<transaction-type>Container</transaction-type>
  		<env-entry>
  			<description />
  			<env-entry-name>mqMessageSize</env-entry-name>
  			<env-entry-type>java.lang.Long</env-entry-type>
  			<env-entry-value>4096</env-entry-value>
  		</env-entry>
  	</session>
  	
</enterprise-beans>
</ejb-jar>


file Read:C:\Users\AP068\git\documentum\duecmcustomerwrappers\ESB\BnhpDFSWrapper\target\classes\META-INF\ibm-ejb-jar-ext.xml
-----------------------------------------------------
<?xml version="1.0" encoding="UTF-8"?>
<ejb-jar-ext
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns="http://websphere.ibm.com/xml/ns/javaee"
    xsi:schemaLocation="http://websphere.ibm.com/xml/ns/javaee http://websphere.ibm.com/xml/ns/javaee/ibm-ejb-jar-ext_1_1.xsd" version="1.1">
  <session name="DocumentumServicesJmsWrapper">
    <start-at-app-start value="true"/>
  </session>

</ejb-jar-ext>



file Read:C:\Users\AP068\git\documentum\duecmcustomerwrappers\ESB\BnhpDFSWrapper\target\classes\META-INF\maven\com.poalim.documentum\BnhpDFSWrapper\pom.properties
-----------------------------------------------------
#Generated by Maven Integration for Eclipse
#Wed Jun 09 16:03:22 IDT 2021
m2e.projectLocation=C\:\\Users\\AP068\\git\\documentum\\duecmcustomerwrappers\\ESB\\BnhpDFSWrapper
m2e.projectName=BnhpDFSWrapper
groupId=com.poalim.documentum
artifactId=BnhpDFSWrapper
version=1.0-SNAPSHOT


file Read:C:\Users\AP068\git\documentum\duecmcustomerwrappers\ESB\BnhpDFSWrapper\target\classes\META-INF\maven\com.poalim.documentum\BnhpDFSWrapper\pom.xml
-----------------------------------------------------
<?xml version="1.0" encoding="UTF-8"?>

<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
	<modelVersion>4.0.0</modelVersion>

	<parent>
		<groupId>com.poalim.documentum</groupId>
		<artifactId>parent</artifactId>
		<version>1.0-SNAPSHOT</version>
	</parent>

	<artifactId>BnhpDFSWrapper</artifactId>
	<packaging>ejb</packaging>
	<name>BnhpDFSWrapper</name>
	<description>BnhpDFSWrapper</description>

	<dependencies>

		<dependency>
			<groupId>was</groupId>
			<artifactId>j2ee</artifactId>
			<scope>provided</scope>
		</dependency>

		<dependency>
			<groupId>com.poalim.dependencies</groupId>
			<artifactId>documentum-71-deps</artifactId>
			<type>pom</type>
			<scope>provided</scope>
		</dependency>

		<dependency>
			<groupId>com.poalim.documentum</groupId>
			<artifactId>BnhpInfraDFServices</artifactId>
			<classifier>basic</classifier>
			<exclusions>
				<exclusion>
					<groupId>*</groupId>
					<artifactId>*</artifactId>
				</exclusion>
			</exclusions>
		</dependency>

		<dependency>
			<groupId>com.poalim.documentum</groupId>
			<artifactId>BnhpWrapperDependencyModule</artifactId>
			<exclusions>
				<exclusion>
					<groupId>*</groupId>
					<artifactId>*</artifactId>
				</exclusion>
			</exclusions>
		</dependency>

		<dependency>
			<groupId>bnhp.infra.dfs.services</groupId>
			<artifactId>BHObjectContexts</artifactId>
		</dependency>

		<dependency>
			<groupId>bnhp.infra.dfs.services</groupId>
			<artifactId>BHInputObjectContexts</artifactId>
		</dependency>

		<dependency>
			<groupId>bnhp.infra.dfs.services</groupId>
			<artifactId>BHSearchContexts</artifactId>
		</dependency>
	</dependencies>

	<build>

		<sourceDirectory>ejbModule</sourceDirectory>
		<resources>
			<resource>
				<directory>ejbModule</directory>
				<excludes>
					<exclude>**/*.java</exclude>
					<exclude>**/.copyarea.db</exclude>
				</excludes>
			</resource>
		</resources>

	</build>


</project>


file Read:C:\Users\AP068\git\documentum\duecmcustomerwrappers\ESB\BnhpDFSWrapper\target\classes\META-INF\webservices.xml
-----------------------------------------------------
<?xml version="1.0" encoding="UTF-8"?>
<webservices xmlns="http://java.sun.com/xml/ns/javaee" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/javaee_web_services_1_3.xsd" version="1.3">
	<webservice-description>
		<webservice-description-name>DocumentumServicesJmsWrapperService</webservice-description-name>
		<port-component>
			<port-component-name>DocumentumServicesJmsWrapper</port-component-name>
			<wsdl-service xmlns:pfx="http://bnhp.infra.services.com">
			pfx:DocumentumServicesJmsWrapperService</wsdl-service>
			<wsdl-port xmlns:pfx="http://bnhp.infra.services.com">
			pfx:DocumentumServicesJmsWrapperPort</wsdl-port>
			<enable-mtom>false</enable-mtom>
			<service-impl-bean>
				<ejb-link>
				DocumentumServicesJmsWrapper</ejb-link>
			</service-impl-bean>
		</port-component>
	</webservice-description>
</webservices>


file Read:C:\Users\AP068\git\documentum\duecmcustomerwrappers\ESB\BnhpDFSWrapperEAR\ear-generator\.settings\org.eclipse.wst.common.project.facet.core.xml
-----------------------------------------------------
<?xml version="1.0" encoding="UTF-8"?>
<faceted-project>
  <installed facet="jst.ear" version="1.3"/>
</faceted-project>


file Read:C:\Users\AP068\git\documentum\duecmcustomerwrappers\ESB\BnhpDFSWrapperEAR\ear-generator\maven-assembly-conf-async.xml
-----------------------------------------------------
<!-- The following code copies all the async conf resource files to the corresponding 
	ENV_NAME directory. For example, DEV_INFRA_ASYNC content will be copied to DEV_INFRA 
	in the created zip. This is in order for the TPM installation to succeed 
	on APP servers, where WrapperOffline and WrapperAsync coexist -->

<assembly>
	<id>conf-async</id>
	<formats>
		<format>zip</format>
	</formats>
	<includeBaseDirectory>false</includeBaseDirectory>
	<fileSets>
		<fileSet>
			<directory>../resources/DEV_INFRA_ASYNC</directory>
			<includes>
				<include>*</include>
			</includes>
			<outputDirectory>resources/DEV_INFRA</outputDirectory>
		</fileSet>
		<fileSet>
			<directory>../resources/DEV_INFRA_ASYNC/templates</directory>
			<includes>
				<include>*</include>
			</includes>
			<outputDirectory>resources/DEV_INFRA/templates</outputDirectory>
		</fileSet>
		<fileSet>
			<directory>../resources/DEV_INFRA_ASYNC/dfc_config</directory>
			<includes>
				<include>*</include>
			</includes>
			<outputDirectory>resources/DEV_INFRA/dfc_config</outputDirectory>
		</fileSet>

		<fileSet>
			<directory>../resources/DEV_VANILLA_ASYNC</directory>
			<includes>
				<include>*</include>
			</includes>
			<outputDirectory>resources/DEV_VANILLA</outputDirectory>
		</fileSet>
		<fileSet>
			<directory>../resources/DEV_VANILLA_ASYNC/templates</directory>
			<includes>
				<include>*</include>
			</includes>
			<outputDirectory>resources/DEV_VANILLA/templates</outputDirectory>
		</fileSet>
		<fileSet>
			<directory>../resources/DEV_VANILLA_ASYNC/dfc_config</directory>
			<includes>
				<include>*</include>
			</includes>
			<outputDirectory>resources/DEV_VANILLA/dfc_config</outputDirectory>
		</fileSet>

		<fileSet>
			<directory>../resources/ST_ASYNC</directory>
			<includes>
				<include>*</include>
			</includes>
			<outputDirectory>resources/ST</outputDirectory>
		</fileSet>
		<fileSet>
			<directory>../resources/ST_ASYNC/templates</directory>
			<includes>
				<include>*</include>
			</includes>
			<outputDirectory>resources/ST/templates</outputDirectory>
		</fileSet>

		<fileSet>
			<directory>../resources/ST_ASYNC/dfc_config</directory>
			<includes>
				<include>*</include>
			</includes>
			<outputDirectory>resources/ST/dfc_config</outputDirectory>
		</fileSet>

		<fileSet>
			<directory>../resources/PRE_PROD_ASYNC</directory>
			<includes>
				<include>*</include>
			</includes>
			<outputDirectory>resources/PRE_PROD</outputDirectory>
		</fileSet>
		<fileSet>
			<directory>../resources/PRE_PROD_ASYNC/templates</directory>
			<includes>
				<include>*</include>
			</includes>
			<outputDirectory>resources/PRE_PROD/templates</outputDirectory>
		</fileSet>
		<fileSet>
			<directory>../resources/PRE_PROD_ASYNC/dfc_config</directory>
			<includes>
				<include>*</include>
			</includes>
			<outputDirectory>resources/PRE_PROD/dfc_config</outputDirectory>
		</fileSet>
		<fileSet>
			<directory>../resources/PROD_ASYNC</directory>
			<includes>
				<include>*</include>
			</includes>
			<outputDirectory>resources/PROD</outputDirectory>
		</fileSet>
		<fileSet>
			<directory>../resources/PROD_ASYNC/templates</directory>
			<includes>
				<include>*</include>
			</includes>
			<outputDirectory>resources/PROD/templates</outputDirectory>
		</fileSet>

		<fileSet>
			<directory>../resources/PROD_ASYNC/dfc_config</directory>
			<includes>
				<include>*</include>
			</includes>
			<outputDirectory>resources/PROD/dfc_config</outputDirectory>
		</fileSet>




	</fileSets>

</assembly>


file Read:C:\Users\AP068\git\documentum\duecmcustomerwrappers\ESB\BnhpDFSWrapperEAR\ear-generator\maven-assembly-conf.xml
-----------------------------------------------------
<assembly>
  <id>conf</id>
  <formats>
		<format>zip</format>
  </formats>
  <includeBaseDirectory>false</includeBaseDirectory>  
  <fileSets>
    <fileSet>      
	  <directory>../resources</directory>
	  <excludes>
		<exclude>*ASYNC/**</exclude>
	  </excludes>	  
	  <outputDirectory>resources</outputDirectory>
    </fileSet>
  </fileSets>    

</assembly>


file Read:C:\Users\AP068\git\documentum\duecmcustomerwrappers\ESB\BnhpDFSWrapperEAR\ear-generator\pom.xml
-----------------------------------------------------
<?xml version="1.0" encoding="UTF-8"?>

<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
	<modelVersion>4.0.0</modelVersion>
	
	<parent>
		<groupId>com.poalim.documentum</groupId>
		<artifactId>BnhpDFSWrapperEAR-parent</artifactId>
		<version>1.0</version>
	</parent>
	
	<artifactId>BnhpDFSWrapperEAR</artifactId>
	<version>1.0-SNAPSHOT</version>
	<packaging>ear</packaging>
	<name>BnhpDFSWrapperEAR</name>
	<description>BnhpDFSWrapperEAR project</description>	

	<dependencies>
		
		<dependency>
			<groupId>bnhp.infra.dfs.services</groupId>
			<artifactId>BHSearchContexts</artifactId>							
		</dependency>
		
		<dependency>
			<groupId>bnhp.infra.dfs.services</groupId>
			<artifactId>BHAuthorization</artifactId>			
		</dependency>
		
		<dependency>
			<groupId>bnhp.infra.dfs.services</groupId>
			<artifactId>BHGeneralUtil</artifactId>				
		</dependency>						
		
		<dependency>
			<groupId>bnhp.infra.dfs.services</groupId>
			<artifactId>BHInputObjectContexts</artifactId>							
		</dependency>
		
		<dependency>
			<groupId>bnhp.infra.dfs.services</groupId>
			<artifactId>BHObjectContexts</artifactId>				
		</dependency>
		
		<dependency>
			<groupId>bnhp.infra.dfs.services</groupId>
			<artifactId>BHPeulaException</artifactId>				
		</dependency>
		
		<dependency>
			<groupId>com.poalim.documentum</groupId>
			<artifactId>BnhpDFSWrapper</artifactId>
			<type>ejb</type>			
		</dependency>
		
		<dependency>
			<groupId>com.poalim.documentum</groupId>
			<artifactId>BnhpDFSWrapper_JMSRouter</artifactId>
			<type>ejb</type>		
		</dependency>
		
	</dependencies>
	
	<build>
		<plugins>
			
			<plugin>
				<groupId>org.apache.maven.plugins</groupId>
				<artifactId>maven-ear-plugin</artifactId>				
				<configuration>		

					<modules>
						<ejbModule>
							<groupId>com.poalim.documentum</groupId>
							<artifactId>BnhpDFSWrapper</artifactId>
						</ejbModule>
						
						<ejbModule>
							<groupId>com.poalim.documentum</groupId>
							<artifactId>BnhpDFSWrapper_JMSRouter</artifactId>
							<bundleFileName>BnhpDFSWrapper_JMSRouter.jar</bundleFileName>
						</ejbModule>
					</modules>					
				
					<archive>
						<manifestEntries>
							<Build-Version>${project.version}</Build-Version>
							<Build-Time>${maven.build.timestamp}</Build-Time>
						</manifestEntries>						
					</archive>		
				</configuration>
			</plugin>
			
			<!-- plugin>
								
				<groupId>org.apache.maven.plugins</groupId>
				<artifactId>maven-assembly-plugin</artifactId>	
				<version>2.4</version>
				
				<configuration>					
					<descriptors>
						<descriptor>maven-assembly-conf.xml</descriptor>
						<descriptor>maven-assembly-conf-async.xml</descriptor>
					</descriptors>
				</configuration>								
				
				<executions>
					<execution>
						<id>make-assembly</id>
						<phase>package</phase>
						<goals>
							<goal>single</goal>
						</goals>												
					</execution>
				</executions>
				
			</plugin-->	
		</plugins>
	</build>


</project>


file Read:C:\Users\AP068\git\documentum\duecmcustomerwrappers\ESB\BnhpDFSWrapperEAR\ear-generator\target\m2e-wtp\ear-resources\META-INF\application.xml
-----------------------------------------------------
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE application PUBLIC
	"-//Sun Microsystems, Inc.//DTD J2EE Application 1.3//EN"
	"http://java.sun.com/dtd/application_1_3.dtd">
<application>
  <display-name>BnhpDFSWrapperEAR</display-name>
  <description>BnhpDFSWrapperEAR project</description>
  <module>
    <ejb>BnhpDFSWrapper-1.0-SNAPSHOT.jar</ejb>
  </module>
  <module>
    <ejb>BnhpDFSWrapper_JMSRouter.jar</ejb>
  </module>
</application>


file Read:C:\Users\AP068\git\documentum\duecmcustomerwrappers\ESB\BnhpDFSWrapperEAR\ear-generator\target\m2e-wtp\ear-resources\META-INF\maven\com.poalim.documentum\BnhpDFSWrapperEAR\pom.properties
-----------------------------------------------------
#Generated by Maven Integration for Eclipse
#Thu May 20 19:17:16 IDT 2021
m2e.projectLocation=C\:\\Users\\AP068\\git\\documentum\\duecmcustomerwrappers\\ESB\\BnhpDFSWrapperEAR\\ear-generator
m2e.projectName=BnhpDFSWrapperEAR
groupId=com.poalim.documentum
artifactId=BnhpDFSWrapperEAR
version=1.0-SNAPSHOT


file Read:C:\Users\AP068\git\documentum\duecmcustomerwrappers\ESB\BnhpDFSWrapperEAR\ear-generator\target\m2e-wtp\ear-resources\META-INF\maven\com.poalim.documentum\BnhpDFSWrapperEAR\pom.xml
-----------------------------------------------------
<?xml version="1.0" encoding="UTF-8"?>

<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
	<modelVersion>4.0.0</modelVersion>
	
	<parent>
		<groupId>com.poalim.documentum</groupId>
		<artifactId>BnhpDFSWrapperEAR-parent</artifactId>
		<version>1.0</version>
	</parent>
	
	<artifactId>BnhpDFSWrapperEAR</artifactId>
	<version>1.0-SNAPSHOT</version>
	<packaging>ear</packaging>
	<name>BnhpDFSWrapperEAR</name>
	<description>BnhpDFSWrapperEAR project</description>	

	<dependencies>
		
		<dependency>
			<groupId>bnhp.infra.dfs.services</groupId>
			<artifactId>BHSearchContexts</artifactId>							
		</dependency>
		
		<dependency>
			<groupId>bnhp.infra.dfs.services</groupId>
			<artifactId>BHAuthorization</artifactId>			
		</dependency>
		
		<dependency>
			<groupId>bnhp.infra.dfs.services</groupId>
			<artifactId>BHGeneralUtil</artifactId>				
		</dependency>						
		
		<dependency>
			<groupId>bnhp.infra.dfs.services</groupId>
			<artifactId>BHInputObjectContexts</artifactId>							
		</dependency>
		
		<dependency>
			<groupId>bnhp.infra.dfs.services</groupId>
			<artifactId>BHObjectContexts</artifactId>				
		</dependency>
		
		<dependency>
			<groupId>bnhp.infra.dfs.services</groupId>
			<artifactId>BHPeulaException</artifactId>				
		</dependency>
		
		<dependency>
			<groupId>com.poalim.documentum</groupId>
			<artifactId>BnhpDFSWrapper</artifactId>
			<type>ejb</type>			
		</dependency>
		
		<dependency>
			<groupId>com.poalim.documentum</groupId>
			<artifactId>BnhpDFSWrapper_JMSRouter</artifactId>
			<type>ejb</type>		
		</dependency>
		
	</dependencies>
	
	<build>
		<plugins>
			
			<plugin>
				<groupId>org.apache.maven.plugins</groupId>
				<artifactId>maven-ear-plugin</artifactId>				
				<configuration>		

					<modules>
						<ejbModule>
							<groupId>com.poalim.documentum</groupId>
							<artifactId>BnhpDFSWrapper</artifactId>
						</ejbModule>
						
						<ejbModule>
							<groupId>com.poalim.documentum</groupId>
							<artifactId>BnhpDFSWrapper_JMSRouter</artifactId>
							<bundleFileName>BnhpDFSWrapper_JMSRouter.jar</bundleFileName>
						</ejbModule>
					</modules>					
				
					<archive>
						<manifestEntries>
							<Build-Version>${project.version}</Build-Version>
							<Build-Time>${maven.build.timestamp}</Build-Time>
						</manifestEntries>						
					</archive>		
				</configuration>
			</plugin>
			
			<!-- plugin>
								
				<groupId>org.apache.maven.plugins</groupId>
				<artifactId>maven-assembly-plugin</artifactId>	
				<version>2.4</version>
				
				<configuration>					
					<descriptors>
						<descriptor>maven-assembly-conf.xml</descriptor>
						<descriptor>maven-assembly-conf-async.xml</descriptor>
					</descriptors>
				</configuration>								
				
				<executions>
					<execution>
						<id>make-assembly</id>
						<phase>package</phase>
						<goals>
							<goal>single</goal>
						</goals>												
					</execution>
				</executions>
				
			</plugin-->	
		</plugins>
	</build>


</project>


file Read:C:\Users\AP068\git\documentum\duecmcustomerwrappers\ESB\BnhpDFSWrapperEAR\META-INF\application.xml
-----------------------------------------------------
<?xml version="1.0" encoding="UTF-8"?>
<application id="Application_ID" version="5" xmlns="http://java.sun.com/xml/ns/javaee" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/application_5.xsd">
 <display-name>BnhpDFSWrapperEAR</display-name>
 <module id="Module_1350407232370">
 	<ejb>BnhpDFSWrapper.jar</ejb>
 </module>
 <module id="Module_1378040725233">
 	<ejb>BnhpDFSWrapper_JMSRouter.jar</ejb>
 </module>

 
</application> 


file Read:C:\Users\AP068\git\documentum\duecmcustomerwrappers\ESB\BnhpDFSWrapperEAR\pom.xml
-----------------------------------------------------
<?xml version="1.0" encoding="UTF-8"?>

<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
	<modelVersion>4.0.0</modelVersion>
	
	<parent>
		<groupId>com.poalim.documentum</groupId>
		<artifactId>parent</artifactId>
		<version>1.0-SNAPSHOT</version>
	</parent>
	
	<artifactId>BnhpDFSWrapperEAR-parent</artifactId>
	<version>1.0</version>
	<packaging>pom</packaging>
	<name>BnhpDFSWrapperEAR parent</name>
	<description>BnhpDFSWrapperEAR parent</description>	
	
	<modules>	
		<module>ear-generator</module>
		<module>../BnhpDFSWrapper_JMSRouter</module>
		<module>../BnhpDFSWrapper</module>		
	</modules>
	
	
</project>


file Read:C:\Users\AP068\git\documentum\duecmcustomerwrappers\ESB\BnhpDFSWrapper_JMSRouter\.settings\org.eclipse.wst.common.project.facet.core.xml
-----------------------------------------------------
<?xml version="1.0" encoding="UTF-8"?>
<faceted-project>
  <installed facet="java" version="1.6"/>
  <installed facet="jst.ejb" version="3.0"/>
</faceted-project>


file Read:C:\Users\AP068\git\documentum\duecmcustomerwrappers\ESB\BnhpDFSWrapper_JMSRouter\ejbModule\META-INF\ejb-jar.xml
-----------------------------------------------------
<?xml version="1.0" encoding="UTF-8"?>
<ejb-jar xmlns="http://java.sun.com/xml/ns/javaee" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/ejb-jar_3_1.xsd" version="3.1">
	<display-name>
	BnhpDFSWrapper_JMSRouter</display-name>
	<enterprise-beans>
		<message-driven>
			<ejb-name>WebServicesJMSRouter</ejb-name>
			<ejb-class>com.ibm.ws.websvcs.transport.jms.JMSListenerMDB</ejb-class>
			<transaction-type>Container</transaction-type>
			<message-destination-type>javax.jms.Queue</message-destination-type>
			<activation-config>
				<activation-config-property>
					<activation-config-property-name>destinationType</activation-config-property-name>
					<activation-config-property-value>javax.jms.Queue</activation-config-property-value>
				</activation-config-property>
				
			</activation-config>
			<resource-env-ref>
				<resource-env-ref-name>jms/WebServicesReplyQCF</resource-env-ref-name>
				<resource-env-ref-type>javax.jms.QueueConnectionFactory</resource-env-ref-type>
			</resource-env-ref>
		</message-driven>
	</enterprise-beans>
</ejb-jar>


file Read:C:\Users\AP068\git\documentum\duecmcustomerwrappers\ESB\BnhpDFSWrapper_JMSRouter\ejbModule\META-INF\ibm-ejb-jar-bnd.xml
-----------------------------------------------------
<?xml version="1.0" encoding="UTF-8"?>
<ejb-jar-bnd
        xmlns="http://websphere.ibm.com/xml/ns/javaee"
        xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
        xsi:schemaLocation="http://websphere.ibm.com/xml/ns/javaee http://websphere.ibm.com/xml/ns/javaee/ibm-ejb-jar-bnd_1_0.xsd"
        version="1.0">

	<message-driven name="WebServicesJMSRouter">
		<jca-adapter activation-spec-binding-name="jms/duEcmListener" />
		<resource-env-ref name="jms/WebServicesReplyQCF"
			binding-name="jms/WebServicesReplyQCF" />
	</message-driven>
</ejb-jar-bnd>


file Read:C:\Users\AP068\git\documentum\duecmcustomerwrappers\ESB\BnhpDFSWrapper_JMSRouter\ejbModule\META-INF\ibm-ejb-jar-ext.xml
-----------------------------------------------------
<?xml version="1.0" encoding="UTF-8"?>
<ejb-jar-ext
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns="http://websphere.ibm.com/xml/ns/javaee"
    xsi:schemaLocation="http://websphere.ibm.com/xml/ns/javaee http://websphere.ibm.com/xml/ns/javaee/ibm-ejb-jar-ext_1_0.xsd" version="1.0">
  <message-driven name="WebServicesJMSRouter">
    <start-at-app-start value="true"/>
  </message-driven>

</ejb-jar-ext>



file Read:C:\Users\AP068\git\documentum\duecmcustomerwrappers\ESB\BnhpDFSWrapper_JMSRouter\pom.xml
-----------------------------------------------------
<?xml version="1.0" encoding="UTF-8"?>

<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
	<modelVersion>4.0.0</modelVersion>
	
	<parent>
		<groupId>com.poalim.documentum</groupId>
		<artifactId>parent</artifactId>
		<version>1.0-SNAPSHOT</version>
	</parent>
	
	<artifactId>BnhpDFSWrapper_JMSRouter</artifactId>
	<packaging>ejb</packaging>
	<name>BnhpDFSWrapper_JMSRouter</name>
	<description>BnhpDFSWrapper_JMSRouter</description>					
	
	<build>						
		
		<sourceDirectory>ejbModule</sourceDirectory>
		<resources>
			<resource>
				<directory>ejbModule</directory>
				<excludes>	
				<exclude>**/.copyarea.db</exclude>
				</excludes>			
			</resource>
		</resources>				
		
	</build>


</project>


file Read:C:\Users\AP068\git\documentum\duecmcustomerwrappers\ESB\BnhpDFSWrapper_JMSRouter\target\classes\META-INF\ejb-jar.xml
-----------------------------------------------------
<?xml version="1.0" encoding="UTF-8"?>
<ejb-jar xmlns="http://java.sun.com/xml/ns/javaee" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/ejb-jar_3_1.xsd" version="3.1">
	<display-name>
	BnhpDFSWrapper_JMSRouter</display-name>
	<enterprise-beans>
		<message-driven>
			<ejb-name>WebServicesJMSRouter</ejb-name>
			<ejb-class>com.ibm.ws.websvcs.transport.jms.JMSListenerMDB</ejb-class>
			<transaction-type>Container</transaction-type>
			<message-destination-type>javax.jms.Queue</message-destination-type>
			<activation-config>
				<activation-config-property>
					<activation-config-property-name>destinationType</activation-config-property-name>
					<activation-config-property-value>javax.jms.Queue</activation-config-property-value>
				</activation-config-property>
				
			</activation-config>
			<resource-env-ref>
				<resource-env-ref-name>jms/WebServicesReplyQCF</resource-env-ref-name>
				<resource-env-ref-type>javax.jms.QueueConnectionFactory</resource-env-ref-type>
			</resource-env-ref>
		</message-driven>
	</enterprise-beans>
</ejb-jar>


file Read:C:\Users\AP068\git\documentum\duecmcustomerwrappers\ESB\BnhpDFSWrapper_JMSRouter\target\classes\META-INF\ibm-ejb-jar-bnd.xml
-----------------------------------------------------
<?xml version="1.0" encoding="UTF-8"?>
<ejb-jar-bnd
        xmlns="http://websphere.ibm.com/xml/ns/javaee"
        xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
        xsi:schemaLocation="http://websphere.ibm.com/xml/ns/javaee http://websphere.ibm.com/xml/ns/javaee/ibm-ejb-jar-bnd_1_0.xsd"
        version="1.0">

	<message-driven name="WebServicesJMSRouter">
		<jca-adapter activation-spec-binding-name="jms/duEcmListener" />
		<resource-env-ref name="jms/WebServicesReplyQCF"
			binding-name="jms/WebServicesReplyQCF" />
	</message-driven>
</ejb-jar-bnd>


file Read:C:\Users\AP068\git\documentum\duecmcustomerwrappers\ESB\BnhpDFSWrapper_JMSRouter\target\classes\META-INF\ibm-ejb-jar-ext.xml
-----------------------------------------------------
<?xml version="1.0" encoding="UTF-8"?>
<ejb-jar-ext
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns="http://websphere.ibm.com/xml/ns/javaee"
    xsi:schemaLocation="http://websphere.ibm.com/xml/ns/javaee http://websphere.ibm.com/xml/ns/javaee/ibm-ejb-jar-ext_1_0.xsd" version="1.0">
  <message-driven name="WebServicesJMSRouter">
    <start-at-app-start value="true"/>
  </message-driven>

</ejb-jar-ext>



file Read:C:\Users\AP068\git\documentum\duecmcustomerwrappers\ESB\BnhpDFSWrapper_JMSRouter\target\classes\META-INF\maven\com.poalim.documentum\BnhpDFSWrapper_JMSRouter\pom.properties
-----------------------------------------------------
#Generated by Maven Integration for Eclipse
#Mon May 24 13:41:52 IDT 2021
m2e.projectLocation=C\:\\Users\\AP068\\git\\documentum\\duecmcustomerwrappers\\ESB\\BnhpDFSWrapper_JMSRouter
m2e.projectName=BnhpDFSWrapper_JMSRouter
groupId=com.poalim.documentum
artifactId=BnhpDFSWrapper_JMSRouter
version=1.0-SNAPSHOT


file Read:C:\Users\AP068\git\documentum\duecmcustomerwrappers\ESB\BnhpDFSWrapper_JMSRouter\target\classes\META-INF\maven\com.poalim.documentum\BnhpDFSWrapper_JMSRouter\pom.xml
-----------------------------------------------------
<?xml version="1.0" encoding="UTF-8"?>

<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
	<modelVersion>4.0.0</modelVersion>
	
	<parent>
		<groupId>com.poalim.documentum</groupId>
		<artifactId>parent</artifactId>
		<version>1.0-SNAPSHOT</version>
	</parent>
	
	<artifactId>BnhpDFSWrapper_JMSRouter</artifactId>
	<packaging>ejb</packaging>
	<name>BnhpDFSWrapper_JMSRouter</name>
	<description>BnhpDFSWrapper_JMSRouter</description>					
	
	<build>						
		
		<sourceDirectory>ejbModule</sourceDirectory>
		<resources>
			<resource>
				<directory>ejbModule</directory>
				<excludes>	
				<exclude>**/.copyarea.db</exclude>
				</excludes>			
			</resource>
		</resources>				
		
	</build>


</project>


file Read:C:\Users\AP068\git\documentum\duecmcustomerwrappers\OFFLINE\BnhpDFSWrapperOffline\.settings\org.eclipse.wst.common.project.facet.core.xml
-----------------------------------------------------
<?xml version="1.0" encoding="UTF-8"?>
<faceted-project>
  <installed facet="java" version="1.6"/>
  <installed facet="jst.ejb" version="3.0"/>
</faceted-project>


file Read:C:\Users\AP068\git\documentum\duecmcustomerwrappers\OFFLINE\BnhpDFSWrapperOffline\ejbModule\bnhp\infra\dfs\services\DocumentumServicesJmsWrapper.java
-----------------------------------------------------
package bnhp.infra.dfs.services;

import java.util.List;

import javax.ejb.Stateless;
import javax.interceptor.Interceptors;
import javax.jws.HandlerChain;
import javax.jws.WebMethod;
import javax.jws.WebParam;
import javax.jws.WebResult;
import javax.jws.WebService;
import javax.xml.ws.Holder;

import bh.dfs.services.common.inputobjectcontext.BHPeulaPakidDataContext;
import bh.dfs.services.common.searchcontext.BHSearchDateRangeDataContext;
import bh.dfs.services.common.searchcontext.BHSearchDomainActivityDataContext;
import bh.dfs.services.common.searchcontext.BHSearchGeneralDataContext;
import bh.dfs.services.common.searchcontext.BHSearchOperationBranchDataContext;
import bnhp.infra.dfs.init.ApplicationInitializer;
import bnhp.infra.dfs.model.business.CodeTableDataContext;
import bnhp.infra.dfs.model.business.CurrencyDataContext;
import bnhp.infra.dfs.model.business.DocDataMfContext;
import bnhp.infra.dfs.model.business.DocEventData;
import bnhp.infra.dfs.model.business.EventFilter;
import bnhp.infra.dfs.model.business.ExecutorDetails;
import bnhp.infra.dfs.model.business.SecurityContext;
import bnhp.infra.dfs.model.business.descr.DocEventDataDescr;
import bnhp.infra.dfs.model.query.prepared.NamedQueryParam;
import bnhp.infra.dfs.model.query.prepared.PreparedQuery;
import bnhp.infra.dfs.model.query.prepared.QueryParam;
import bnhp.infra.dfs.model.service.ClntV2;
import bnhp.infra.dfs.model.service.ClntV3;
import bnhp.infra.dfs.model.service.DocDataForCreate;
import bnhp.infra.dfs.model.service.DocDataForRetrieve;
import bnhp.infra.dfs.model.service.DocDataForUpdate;
import bnhp.infra.dfs.model.service.DocEventDataForCreate;
import bnhp.infra.dfs.model.service.DocIdData;
import bnhp.infra.dfs.model.service.DocIdsDataList;
import bnhp.infra.dfs.model.service.DocRetrievalFlags;
import bnhp.infra.dfs.model.service.FetchType;
import bnhp.infra.dfs.model.service.FetchTypeSet;
import bnhp.infra.dfs.model.service.RequestDetails;
import bnhp.infra.dfs.model.service.SearchDefinition;
import bnhp.infra.dfs.model.service.SearchResult;
import bnhp.infra.dfs.services.exceptions.ECMDetailedException;
import bnhp.infra.dfs.services.exceptions.ECMException;
import bnhp.infra.dfs.utils.basic.LoggingUtils;
import bnhp.infra.dfs.utils.service.DfsRequestThreadAttributes;
import bnhp.infra.dfs.utils.service.OperatingMode;

/**
 * @author FON This class represents a collection of all the visible operations
 *         to manage documentum capabilities: Create, Update, Retrieve and
 *         Search of documents managed in documentum. These operations will be
 *         exposed through SAF (ESB infrastructure) as different services with
 *         subset of existing operations.
 * 
 */
@HandlerChain(file = "DocumentumServicesJmsWrapperHandlers.xml")
@WebService(targetNamespace = "http://bnhp.infra.services.com", name = "DocumentumServicesJmsWrapper")
@Stateless(mappedName = "DocumentumServicesJmsWrapper", name = "DocumentumServicesJmsWrapper")
@Interceptors(value = { MessageSizeValidatorInterceptor.class })
public class DocumentumServicesJmsWrapper {
	public DocumentumServicesJmsWrapper() {
		// The dctmRequestId is generated in RequestHandler
		// WSSOAPHandler, but the constructor is not invoked as a WS, so
		// generate it here and then nullify it upon exit
		// Also, set the loggers (and leave them set)
		try {
			DfsRequestThreadAttributes.generateDctmRequestId();
			DfsRequestThreadAttributes.logger.set(new LoggingUtils(
					"wrapper_logger_id"));
			DfsRequestThreadAttributes.dfsLogger.set(new LoggingUtils(
					"dfs_logger_id"));
			DfsRequestThreadAttributes.logger.get().info(
					"DocumentumServicesJmsWrapper",
					"status=initDocumentumServicesJmsWrapperInstance");
			ApplicationInitializer ai = ApplicationInitializer.getInstance();
			ai.initApplication();
		} finally {
			DfsRequestThreadAttributes.dctmRequestId.set(null);
		}
	}

	@WebMethod
	@WebResult(name = "docIdDataList")
	public List<DocIdData> createDocumentsFromURLAsync(
			@WebParam(name = "inputURL") String inputURL,
			@WebParam(name = "securityContext") SecurityContext securityContext,
			@WebParam(name = "inputOverride") List<DocDataForCreate> inputOverride,
			@WebParam(name = "requestId") String requestId,
			@WebParam(name = "requestDetails", mode = WebParam.Mode.OUT) Holder<List<RequestDetails>> requestDetails,
			@WebParam(name = "clntV2") ClntV2 clntV2,
			@WebParam(name = "clntV3") ClntV3 clntV3) throws ECMException,
			ECMDetailedException {
		return CreateDocuments.createDocumentsFromURLAsync(inputURL,
				securityContext, inputOverride, requestId, requestDetails,
				clntV2);
	}

	@WebMethod
	@WebResult(name = "docIdData")
	public DocIdData updateDocumentVersionFromURLAsync(
			@WebParam(name = "inputURL") String inputURL,
			@WebParam(name = "inputOverride") DocDataForUpdate inputOverride,
			@WebParam(name = "securityContext") SecurityContext securityContext,
			@WebParam(name = "versionLabel") String versionLabel,
			@WebParam(name = "requestId") String requestId,
			@WebParam(name = "requestDetails", mode = WebParam.Mode.OUT) Holder<List<RequestDetails>> requestDetails,
			@WebParam(name = "clntV2") ClntV2 clntV2,
			@WebParam(name = "clntV3") ClntV3 clntV3) throws ECMException,
			ECMDetailedException {
		return UpdateDocuments.updateDocumentVersionFromURLAsync(inputURL,
				inputOverride, securityContext, versionLabel, requestId,
				requestDetails, clntV2);
	}

	@WebMethod
	@WebResult(name = "docIdDataList")
	public List<DocIdData> createDocuments(
			@WebParam(name = "docDataForCreateList") List<DocDataForCreate> docData4CreateList,
			@WebParam(name = "securityContext") SecurityContext securityContext,
			@WebParam(name = "versionLabel") String versionLabel,
			@WebParam(name = "requestId") String requestId,
			@WebParam(name = "switchRelatedDocuments") Boolean switchRelatedDocuments,
			@WebParam(name = "requestDetails", mode = WebParam.Mode.OUT) Holder<List<RequestDetails>> requestDetails,
			@WebParam(name = "clntV2") ClntV2 clntV2,
			@WebParam(name = "clntV3") ClntV3 clntV3) throws ECMException,
			ECMDetailedException {
		DfsRequestThreadAttributes.operatingMode.set(OperatingMode.SYNC);
		return CreateDocuments.doAuditedCreateDocuments("createDocuments",
				docData4CreateList, securityContext, versionLabel, requestId,
				switchRelatedDocuments, requestDetails);

	}

	@WebMethod
	@WebResult(name = "docIdDataList")
	public List<DocIdData> createDocumentsAsync(
			@WebParam(name = "docDataForCreateList") List<DocDataForCreate> docData4CreateList,
			@WebParam(name = "securityContext") SecurityContext securityContext,
			@WebParam(name = "versionLabel") String versionLabel,
			@WebParam(name = "requestId") String requestId,
			@WebParam(name = "switchRelatedDocuments") Boolean switchRelatedDocuments,
			@WebParam(name = "requestDetails", mode = WebParam.Mode.OUT) Holder<List<RequestDetails>> requestDetails,
			@WebParam(name = "clntV2") ClntV2 clntV2,
			@WebParam(name = "clntV3") ClntV3 clntV3) throws ECMException,
			ECMDetailedException {
		DfsRequestThreadAttributes.operatingMode.set(OperatingMode.ASYNC);
		return CreateDocuments.doAuditedCreateDocuments("createDocumentsAsync",
				docData4CreateList, securityContext, versionLabel, requestId,
				switchRelatedDocuments, requestDetails);
	}

	@WebMethod
	@WebResult(name = "docIdDataList")
	public List<DocIdData> updateDocumentsByDctmDocumentId(
			@WebParam(name = "docDataForUpdateList") List<DocDataForUpdate> docDataForUpdateList,
			@WebParam(name = "securityContext") SecurityContext securityContext,
			@WebParam(name = "requestId") String requestId,
			@WebParam(name = "requestDetails", mode = WebParam.Mode.OUT) Holder<List<RequestDetails>> requestDetails,
			@WebParam(name = "clntV2") ClntV2 clntV2,
			@WebParam(name = "clntV3") ClntV3 clntV3) throws ECMException,
			ECMDetailedException {
		DfsRequestThreadAttributes.operatingMode.set(OperatingMode.SYNC);
		return UpdateDocuments.doAuditedUpdateDocumentsByDocumentId(
				"updateDocumentsByDctmDocumentId", false, docDataForUpdateList,
				securityContext, requestId, requestDetails);
	}

	@WebMethod
	@WebResult(name = "docIdDataList")
	public List<DocIdData> updateDocumentsByDctmDocumentIdAsync(
			@WebParam(name = "docDataForUpdateList") List<DocDataForUpdate> docDataForUpdateList,
			@WebParam(name = "securityContext") SecurityContext securityContext,
			@WebParam(name = "requestId") String requestId,
			@WebParam(name = "requestDetails", mode = WebParam.Mode.OUT) Holder<List<RequestDetails>> requestDetails,
			@WebParam(name = "clntV2") ClntV2 clntV2,
			@WebParam(name = "clntV3") ClntV3 clntV3) throws ECMException,
			ECMDetailedException {
		DfsRequestThreadAttributes.operatingMode.set(OperatingMode.ASYNC);
		return UpdateDocuments.doAuditedUpdateDocumentsByDocumentId(
				"updateDocumentsByDctmDocumentIdAsync", false,
				docDataForUpdateList, securityContext, requestId,
				requestDetails);
	}

	@WebMethod
	@WebResult(name = "docIdDataList")
	public List<DocIdData> updateDocumentsByLegacyDocumentId(
			@WebParam(name = "docDataForUpdateList") List<DocDataForUpdate> docDataForUpdateList,
			@WebParam(name = "securityContext") SecurityContext securityContext,
			@WebParam(name = "requestId") String requestId,
			@WebParam(name = "requestDetails", mode = WebParam.Mode.OUT) Holder<List<RequestDetails>> requestDetails,
			@WebParam(name = "clntV2") ClntV2 clntV2,
			@WebParam(name = "clntV3") ClntV3 clntV3) throws ECMException,
			ECMDetailedException {

		DfsRequestThreadAttributes.operatingMode.set(OperatingMode.SYNC);
		return UpdateDocuments.doAuditedUpdateDocumentsByDocumentId(
				"updateDocumentsByLegacyDocumentId", true,
				docDataForUpdateList, securityContext, requestId,
				requestDetails);
	}

	/**
	 * @param docDataForUpdateList
	 * @param securityContext
	 * @param versionLabel
	 * @param createVersion
	 * @return
	 * @throws ECMException
	 */
	@WebMethod
	@WebResult(name = "docIdDataList")
	public List<DocIdData> updateDocumentsByLegacyDocumentIdAsync(
			@WebParam(name = "docDataForUpdateList") List<DocDataForUpdate> docDataForUpdateList,
			@WebParam(name = "securityContext") SecurityContext securityContext,
			@WebParam(name = "requestId") String requestId,
			@WebParam(name = "requestDetails", mode = WebParam.Mode.OUT) Holder<List<RequestDetails>> requestDetails,
			@WebParam(name = "clntV2") ClntV2 clntV2,
			@WebParam(name = "clntV3") ClntV3 clntV3) throws ECMException,
			ECMDetailedException {
		DfsRequestThreadAttributes.operatingMode.set(OperatingMode.ASYNC);
		return UpdateDocuments.doAuditedUpdateDocumentsByDocumentId(
				"updateDocumentsByLegacyDocumentIdAsync", true,
				docDataForUpdateList, securityContext, requestId,
				requestDetails);
	}

	@WebMethod
	@WebResult(name = "docIdData")
	public DocIdData updateDocumentVersionByLegacyDocumentId(
			@WebParam(name = "docDataForUpdate") DocDataForUpdate docDataForUpdate,
			@WebParam(name = "securityContext") SecurityContext securityContext,
			@WebParam(name = "versionLabel") String versionLabel,
			@WebParam(name = "requestId") String requestId,
			@WebParam(name = "requestDetails", mode = WebParam.Mode.OUT) Holder<List<RequestDetails>> requestDetails,
			@WebParam(name = "clntV2") ClntV2 clntV2,
			@WebParam(name = "clntV3") ClntV3 clntV3) throws ECMException,
			ECMDetailedException {
		DfsRequestThreadAttributes.operatingMode.set(OperatingMode.SYNC);
		return UpdateDocuments.doAuditedUpdateDocumentVersionByDocumentId(
				"updateDocumentVersionByLegacyDocumentId", true,false,
				docDataForUpdate, securityContext, versionLabel, requestId,
				requestDetails);
	}

	@WebMethod
	@WebResult(name = "docIdData")
	public DocIdData updateDocumentVersionByLegacyDocumentIdAsync(
			@WebParam(name = "docDataForUpdate") DocDataForUpdate docDataForUpdate,
			@WebParam(name = "securityContext") SecurityContext securityContext,
			@WebParam(name = "versionLabel") String versionLabel,
			@WebParam(name = "requestId") String requestId,
			@WebParam(name = "requestDetails", mode = WebParam.Mode.OUT) Holder<List<RequestDetails>> requestDetails,
			@WebParam(name = "clntV2") ClntV2 clntV2,
			@WebParam(name = "clntV3") ClntV3 clntV3) throws ECMException,
			ECMDetailedException {
		DfsRequestThreadAttributes.operatingMode.set(OperatingMode.ASYNC);
		return UpdateDocuments.doAuditedUpdateDocumentVersionByDocumentId(
				"updateDocumentVersionByLegacyDocumentIdAsync", true, false,
				docDataForUpdate, securityContext, versionLabel, requestId,
				requestDetails);
	}
	
	@WebMethod
	@WebResult(name = "docIdData")
	public DocIdData putDocumentVersionByLegacyDocumentId(
			@WebParam(name = "docDataForUpdate") DocDataForUpdate docDataForUpdate,
			@WebParam(name = "securityContext") SecurityContext securityContext,
			@WebParam(name = "versionLabel") String versionLabel,
			@WebParam(name = "requestId") String requestId,
			@WebParam(name = "requestDetails", mode = WebParam.Mode.OUT) Holder<List<RequestDetails>> requestDetails,
			@WebParam(name = "clntV2") ClntV2 clntV2,
			@WebParam(name = "clntV3") ClntV3 clntV3) throws ECMException,
			ECMDetailedException {
		DfsRequestThreadAttributes.operatingMode.set(OperatingMode.SYNC);
		return UpdateDocuments.doAuditedUpdateDocumentVersionByDocumentId(
				"putDocumentVersionByLegacyDocumentId", true, true,
				docDataForUpdate, securityContext, versionLabel, requestId,
				requestDetails);
	}

	@WebMethod
	@WebResult(name = "docIdData")
	public DocIdData putDocumentVersionByLegacyDocumentIdAsync(
			@WebParam(name = "docDataForUpdate") DocDataForUpdate docDataForUpdate,
			@WebParam(name = "securityContext") SecurityContext securityContext,
			@WebParam(name = "versionLabel") String versionLabel,
			@WebParam(name = "requestId") String requestId,
			@WebParam(name = "requestDetails", mode = WebParam.Mode.OUT) Holder<List<RequestDetails>> requestDetails,
			@WebParam(name = "clntV2") ClntV2 clntV2,
			@WebParam(name = "clntV3") ClntV3 clntV3) throws ECMException,
			ECMDetailedException {
		DfsRequestThreadAttributes.operatingMode.set(OperatingMode.ASYNC);
		return UpdateDocuments.doAuditedUpdateDocumentVersionByDocumentId(
				"putDocumentVersionByLegacyDocumentIdAsync", true, true,
				docDataForUpdate, securityContext, versionLabel, requestId,
				requestDetails);
	}


	@WebMethod
	@WebResult(name = "docIdData")
	public DocIdData updateDocumentVersionByDctmDocumentId(
			@WebParam(name = "docDataForUpdate") DocDataForUpdate docDataForUpdate,
			@WebParam(name = "securityContext") SecurityContext securityContext,
			@WebParam(name = "versionLabel") String versionLabel,
			@WebParam(name = "requestId") String requestId,
			@WebParam(name = "requestDetails", mode = WebParam.Mode.OUT) Holder<List<RequestDetails>> requestDetails,
			@WebParam(name = "clntV2") ClntV2 clntV2,
			@WebParam(name = "clntV3") ClntV3 clntV3) throws ECMException,
			ECMDetailedException {
		DfsRequestThreadAttributes.operatingMode.set(OperatingMode.SYNC);
		return UpdateDocuments.doAuditedUpdateDocumentVersionByDocumentId(
				"updateDocumentVersionByDctmDocumentId", false, false,
				docDataForUpdate, securityContext, versionLabel, requestId,
				requestDetails);
	}

	@WebMethod
	@WebResult(name = "docIdData")
	public DocIdData updateDocumentVersionByDctmDocumentIdAsync(
			@WebParam(name = "docDataForUpdate") DocDataForUpdate docDataForUpdate,
			@WebParam(name = "securityContext") SecurityContext securityContext,
			@WebParam(name = "versionLabel") String versionLabel,
			@WebParam(name = "requestId") String requestId,
			@WebParam(name = "requestDetails", mode = WebParam.Mode.OUT) Holder<List<RequestDetails>> requestDetails,
			@WebParam(name = "clntV2") ClntV2 clntV2,
			@WebParam(name = "clntV3") ClntV3 clntV3) throws ECMException,
			ECMDetailedException {
		DfsRequestThreadAttributes.operatingMode.set(OperatingMode.SYNC);
		return UpdateDocuments.doAuditedUpdateDocumentVersionByDocumentId(
				"updateDocumentVersionByDctmDocumentIdAsync", false, false,
				docDataForUpdate, securityContext, versionLabel, requestId,
				requestDetails);
	}

	/*@WebMethod
	@WebResult(name = "docDataForRetrieve")
	public DocDataForRetrieve retrieveDocForLegacyDocumentId(
			@WebParam(name = "legacyDocumentId") String legacyDocumentId,
			@WebParam(name = "docFormat") String docFormat,
			@WebParam(name = "executorDetails") ExecutorDetails executorDetails,
			@WebParam(name = "securityContext") SecurityContext securityContext,
			@WebParam(name = "fetchTypeSet") FetchTypeSet fetchTypeSet,
			@WebParam(name = "docRetrievalFlags") DocRetrievalFlags flags,
			@WebParam(name = "versionLabel") String versionLabel,
			@WebParam(name = "clntV2") ClntV2 clntV2,
			@WebParam(name = "clntV3") ClntV3 clntV3) throws ECMException,
			ECMDetailedException {
		return RetrieveDocuments.doRetrieveDoc(
				"retrieveDocForLegacyDocumentId", legacyDocumentId, true,
				docFormat, executorDetails, securityContext, fetchTypeSet,
				flags, versionLabel);
	}

	*/

	/*@WebMethod
	@WebResult(name = "docDataForRetrieve")
	public DocDataForRetrieve retrieveDocForDctmDocumentId(
			@WebParam(name = "dctmDocumentId") String dctmDocumentId,
			@WebParam(name = "docFormat") String docFormat,
			@WebParam(name = "executorDetails") ExecutorDetails executorDetails,
			@WebParam(name = "securityContext") SecurityContext securityContext,
			@WebParam(name = "fetchTypeSet") FetchTypeSet fetchTypeSet,
			@WebParam(name = "docRetrievalFlags") DocRetrievalFlags flags,
			@WebParam(name = "versionLabel") String versionLabel,
			@WebParam(name = "clntV2") ClntV2 clntV2,
			@WebParam(name = "clntV3") ClntV3 clntV3) throws ECMException,
			ECMDetailedException {
		return RetrieveDocuments.doRetrieveDoc("retrieveDocForDctmDocumentId",
				dctmDocumentId, false, docFormat, executorDetails,
				securityContext, fetchTypeSet, flags, versionLabel);
	}

	*/

	/**
	 * Find all Documents {@link DocumentData} according to the document type (
	 * that can be {@link BaseCustomDfs.BNHP_BASE_HEADER_TYPE} or it sub-types)
	 * , group_id and <br>
	 * the fetch type that can be one of: <li>meta data only</li> <li>document
	 * binary content</li> <li>both meta and binary</li>
	 * 
	 * 
	 * @param documentGroupId
	 *            - id of group union
	 * @param docType
	 *            - root type of document retrieve (all sub-types will be
	 *            fetched to)
	 * @param searchDefinition
	 *            - parameters of searched range
	 * @param securityContext
	 *            - authentication related data
	 * @param fetchTypeSet
	 *            - bean with one of {@link FetchType} sub-types , to determine
	 *            which data to retrieve
	 * 
	 * @return - status of search execution and list of {@link DocumentData}
	 *         describing found documents
	 */
	/*@WebMethod
	@WebResult(name = "searchResult")
	public SearchResult searchByDocumentGroupId(
			@WebParam(name = "documentGroupId") String documentGroupId,
			@WebParam(name = "docType") String docType,
			@WebParam(name = "searchDefinition") SearchDefinition searchDefinition,
			@WebParam(name = "securityContext") SecurityContext securityContext,
			@WebParam(name = "fetchTypeSet") FetchTypeSet fetchTypeSet,
			@WebParam(name = "docRetrievalFlags") DocRetrievalFlags flags,
			@WebParam(name = "domainContext") BHSearchDomainActivityDataContext domainContext,
			@WebParam(name = "oprBranchDataContext") BHSearchOperationBranchDataContext oprBranchDataContext,
			@WebParam(name = "dateDataContext") BHSearchDateRangeDataContext dateDataContext,
			@WebParam(name = "pakidDataContext") BHPeulaPakidDataContext pakidDataContext,
			@WebParam(name = "generalSearchDataContext") BHSearchGeneralDataContext generalSearchDataContext,
			@WebParam(name = "clntV2") ClntV2 clntV2,
			@WebParam(name = "clntV3") ClntV3 clntV3) throws ECMException {

		return SearchDocuments.searchByDocumentGroupId(documentGroupId,
				docType, searchDefinition, securityContext, fetchTypeSet,
				flags, domainContext, oprBranchDataContext, dateDataContext,
				pakidDataContext, generalSearchDataContext, clntV2);
	}

	*/

	/*@WebMethod
	@WebResult(name = "searchResult")
	public SearchResult searchAllDocVersion(
			@WebParam(name = "documentId") String documentId,
			@WebParam(name = "securityContext") SecurityContext securityContext,
			@WebParam(name = "fetchTypeSet") FetchTypeSet fetchTypeSet,
			@WebParam(name = "docRetrievalFlags") DocRetrievalFlags flags,
			@WebParam(name = "searchDefinition") SearchDefinition searchDefinition,
			// @WebParam(name = "pakidDataContext") BHPeulaPakidDataContext
			// pakidDataContext,
			@WebParam(name = "executorDetails") ExecutorDetails executorDetails,
			@WebParam(name = "clntV2") ClntV2 clntV2,
			@WebParam(name = "clntV3") ClntV3 clntV3) throws ECMException {
		return SearchDocuments.searchAllDocVersion(documentId, securityContext,
				fetchTypeSet, flags, searchDefinition, executorDetails, clntV2);
	}

	*/

	/**
	 * Find meta data of documents, according to the existing DQL query , that
	 * will be found by document type 'docType' and query name 'queryName'.By
	 * placing provided parameters to it.
	 * 
	 * @param queryName
	 *            - query name
	 * @param docType
	 *            - top level document type to query
	 * @param parameters
	 *            - list of parameters {@link QueryParam} to be placed in query
	 * @param searchDefinition
	 *            -
	 * @param securityContext
	 * 
	 * @return - status of search execution and list of {@link DocumentData}
	 *         describe found documents
	 */
	/*@WebMethod
	@WebResult(name = "searchResult")
	public SearchResult preparedQueryMetaSearch(
			@WebParam(name = "securityContext") SecurityContext securityContext,
			@WebParam(name = "fetchTypeSet") FetchTypeSet fetchTypeSet,
			@WebParam(name = "docRetrievalFlags") DocRetrievalFlags flags,
			@WebParam(name = "searchDefinition") SearchDefinition searchDefinition,
			@WebParam(name = "preparedQuery") PreparedQuery preparedQuery,
			@WebParam(name = "executorDetails") ExecutorDetails executorDetails,
			@WebParam(name = "clntV2") ClntV2 clntV2,
			@WebParam(name = "clntV3") ClntV3 clntV3) throws ECMException {
		return SearchDocuments.preparedQueryMetaSearch(securityContext,
				fetchTypeSet, flags, searchDefinition, preparedQuery,
				executorDetails, clntV2);
	}

	*/

	/**
	 * @param docEventDataForCreateList
	 * @param securityContext
	 * @return
	 * @throws ECMException
	 */
	@WebMethod
	@WebResult(name = "dctmDocumentIdList")
	public List<String> addDocEventDataToDocuments(
			@WebParam(name = "docEventDataForCreateList") List<DocEventDataForCreate> docEventDataForCreateList,
			@WebParam(name = "securityContext") SecurityContext securityContext,
			@WebParam(name = "clntV2") ClntV2 clntV2,
			@WebParam(name = "clntV3") ClntV3 clntV3) throws ECMException {
		return AddDocEventData.addDocEventDataToDocuments(
				docEventDataForCreateList, securityContext, clntV2);
	}

	/*@WebMethod
	@WebResult(name = "docEventDataList")
	public List<DocEventData> retrieveDocEventDataListByLegacyDocumentId(
			@WebParam(name = "legacyDocumentId") String legacyDocumentId,
			@WebParam(name = "securityContext") SecurityContext securityContext,
			@WebParam(name = "executorDetails") ExecutorDetails executorDetails,
			@WebParam(name = "eventFilter") EventFilter eventFilter,
			@WebParam(name = "docEventDataDescrList", mode = WebParam.Mode.OUT) Holder<List<DocEventDataDescr>> docEventDataDescrList,
			@WebParam(name = "clntV2") ClntV2 clntV2,
			@WebParam(name = "clntV3") ClntV3 clntV3) throws ECMException {
		return RetrieveDocuments.doRetrieveDocEventDataListByDocumentId(
				"retrieveDocEventDataListByLegacyDocumentId", true,
				legacyDocumentId, securityContext, executorDetails,
				eventFilter, docEventDataDescrList);
	}

	*/
	/*@WebMethod
	@WebResult(name = "docEventDataList")
	public List<DocEventData> retrieveDocEventDataListByDctmDocumentId(
			@WebParam(name = "dctmDocumentId") String dctmDocumentId,
			@WebParam(name = "securityContext") SecurityContext securityContext,
			@WebParam(name = "executorDetails") ExecutorDetails executorDetails,
			@WebParam(name = "eventsFilter") EventFilter eventFilter,
			@WebParam(name = "docEventDataDescrList", mode = WebParam.Mode.OUT) Holder<List<DocEventDataDescr>> docEventDataDescrList,
			@WebParam(name = "clntV2") ClntV2 clntV2,
			@WebParam(name = "clntV3") ClntV3 clntV3) throws ECMException {
		return RetrieveDocuments.doRetrieveDocEventDataListByDocumentId(
				"retrieveDocEventDataListByLegacyDocumentId", false,
				dctmDocumentId, securityContext, executorDetails, eventFilter,
				docEventDataDescrList);

	}

	*/
	/*@WebMethod
	@WebResult(name = "codeTableDataContext")
	public List<CodeTableDataContext> getCodeTableEntries(
			@WebParam(name = "fetchAllCategories") Boolean fetchAllCategories,
			@WebParam(name = "codeCategory") Integer codeCategory,
			@WebParam(name = "securityContext") SecurityContext securityContext,
			@WebParam(name = "totalResult", mode = WebParam.Mode.OUT) Holder<Integer> totalResult,
			@WebParam(name = "clntV2") ClntV2 clntV2,
			@WebParam(name = "clntV3") ClntV3 clntV3) throws ECMException {
		return TableEntries.getCodeTableEntries(fetchAllCategories,
				codeCategory, securityContext, totalResult, clntV2);
	}

	*/
	/*@WebMethod
	@WebResult(name = "docDataMfContext")
	public List<DocDataMfContext> getMfTablesEntries(
			@WebParam(name = "fetchAllCategories") Boolean fetchAllCategories,
			@WebParam(name = "documentFormId") String documentFormId,
			@WebParam(name = "securityContext") SecurityContext securityContext,
			@WebParam(name = "totalResult", mode = WebParam.Mode.OUT) Holder<Integer> totalResult,
			@WebParam(name = "clntV2") ClntV2 clntV2,
			@WebParam(name = "clntV3") ClntV3 clntV3) throws ECMException {
		return TableEntries.getMfTablesEntries(fetchAllCategories,
				documentFormId, securityContext, totalResult, clntV2);
	}

	*/
	/*@WebMethod
	@WebResult(name = "currencyDataContext")
	public List<CurrencyDataContext> getMfTablesCurrencyEntries(
			@WebParam(name = "securityContext") SecurityContext securityContext,
			@WebParam(name = "totalResult", mode = WebParam.Mode.OUT) Holder<Integer> totalResult,
			@WebParam(name = "clntV2") ClntV2 clntV2,
			@WebParam(name = "clntV3") ClntV3 clntV3) throws ECMException {
		return TableEntries.getMfTablesCurrencyEntries(securityContext,
				totalResult, clntV2);
	}

	*/
	/*@WebMethod
	@WebResult(name = "requestDetailsList")
	public List<RequestDetails> getRequestStatus(
			@WebParam(name = "securityContext") SecurityContext securityContext,
			@WebParam(name = "requestId") String requestId,
			@WebParam(name = "projectId") Integer projectId,
			@WebParam(name = "systemCode") Integer systemCode,
			@WebParam(name = "dataListListResult", mode = WebParam.Mode.OUT) Holder<List<DocIdsDataList>> dataListListResult,
			@WebParam(name = "faultResultList", mode = WebParam.Mode.OUT) Holder<List<String>> faultResultList,
			@WebParam(name = "clntV2") ClntV2 clntV2,
			@WebParam(name = "clntV3") ClntV3 clntV3) throws ECMException {
		return RequestStatus.getRequestStatusList(securityContext, requestId,
				projectId, systemCode, dataListListResult, faultResultList,
				clntV2);
	}

	*/

	/**
	 * Performs arbitrary business transaction
	 */
	@WebMethod
	@WebResult(name = "requestResultsList")
	public List<NamedQueryParam> applicativeRequest(
			@WebParam(name = "securityContext") SecurityContext securityContext,
			@WebParam(name = "preparedQuery") PreparedQuery preparedQuery,
			@WebParam(name = "executorDetails") ExecutorDetails executorDetails,
			@WebParam(name = "requestId") String requestId,
			@WebParam(name = "requestDetails", mode = WebParam.Mode.OUT) Holder<List<RequestDetails>> requestDetails,
			@WebParam(name = "clntV2") ClntV2 clntV2,
			@WebParam(name = "clntV3") ClntV3 clntV3) throws ECMException,
			ECMDetailedException {
		DfsRequestThreadAttributes.operatingMode.set(OperatingMode.SYNC);
		return ApplicativeRequest.applicativeRequest(securityContext,
				preparedQuery, executorDetails, clntV2, requestId,
				requestDetails);
	}

	@WebMethod
	@WebResult(name = "requestResultsList")
	public List<NamedQueryParam> applicativeRequestAsync(
			@WebParam(name = "securityContext") SecurityContext securityContext,
			@WebParam(name = "preparedQuery") PreparedQuery preparedQuery,
			@WebParam(name = "executorDetails") ExecutorDetails executorDetails,
			@WebParam(name = "requestId") String requestId,
			@WebParam(name = "requestDetails", mode = WebParam.Mode.OUT) Holder<List<RequestDetails>> requestDetails,
			@WebParam(name = "clntV2") ClntV2 clntV2,
			@WebParam(name = "clntV3") ClntV3 clntV3) throws ECMException,
			ECMDetailedException {
		DfsRequestThreadAttributes.operatingMode.set(OperatingMode.ASYNC);
		return ApplicativeRequest.applicativeRequest(securityContext,
				preparedQuery, executorDetails, clntV2, requestId,
				requestDetails);
	}

}


file Read:C:\Users\AP068\git\documentum\duecmcustomerwrappers\OFFLINE\BnhpDFSWrapperOffline\ejbModule\bnhp\infra\dfs\services\DocumentumServicesJmsWrapperHandlers.xml
-----------------------------------------------------
<?xml version="1.0" encoding="UTF-8"?>
<jws:handler-chains xmlns:jws="http://java.sun.com/xml/ns/javaee">
<!-- Note:  The '*" denotes a wildcard. -->
	<jws:handler-chain name="DocumentumServicesJmsWrapperHandlersChain">
		<!--jws:protocol-bindings>##SOAP11_HTTP ##ANOTHER_BINDING</jws:protocol-bindings>
		<jws:port-name-pattern 
              xmlns:ns1="http://handlersample.samples.ibm.com/">ns1:MySampl*</jws:port-name-pattern>
        <jws:service-name-pattern 
              xmlns:ns1="http://handlersample.samples.ibm.com/">ns1:*</jws:service-name-pattern-->
		<jws:handler>
			<jws:handler-class>bnhp.infra.dfs.services.SAFVersionHandler</jws:handler-class>
		</jws:handler>
		<jws:handler>
			<jws:handler-class>bnhp.infra.dfs.services.InputAttributesHandler</jws:handler-class>
		</jws:handler>
		<jws:handler>
			<jws:handler-class>bnhp.infra.dfs.services.RequestHandler</jws:handler-class>
		</jws:handler>
	</jws:handler-chain>
	
</jws:handler-chains>


file Read:C:\Users\AP068\git\documentum\duecmcustomerwrappers\OFFLINE\BnhpDFSWrapperOffline\ejbModule\bnhp\infra\dfs\services\InputAttributesHandler.java
-----------------------------------------------------
package bnhp.infra.dfs.services;

import java.util.Set;

import javax.xml.namespace.QName;
import javax.xml.ws.handler.MessageContext;
import javax.xml.ws.handler.soap.SOAPMessageContext;

import bnhp.infra.dfs.utils.service.DfsRequestThreadAttributes;

public class InputAttributesHandler implements
		javax.xml.ws.handler.soap.SOAPHandler<SOAPMessageContext> {

	@Override
	public void close(MessageContext messagecontext) {
	}

	@Override
	public Set<QName> getHeaders() {
		return null;
	}

	@Override
	public boolean handleFault(SOAPMessageContext messagecontext) {
		return true;
	}

	@Override
	public boolean handleMessage(SOAPMessageContext messagecontext) {
		Boolean outbound = (Boolean) messagecontext.get(MessageContext.MESSAGE_OUTBOUND_PROPERTY);
		if (!outbound) {
			// org.apache.axis2.jaxws.handler.SoapMessageContext c;
			// System.out.println("InputAttributesHandler.handleMessage(): "+messagecontext);
			String offlineMessagePath = (String) messagecontext.get("BNHP_OFFLINE_MESSAGE_PATH");
			// System.out.println("InputAttributesHandler.handleMessage(): Offline message path: "+offlineMessagePath);
			DfsRequestThreadAttributes.offlineInputPath.set(offlineMessagePath);
		}
		return true;
	}

}


file Read:C:\Users\AP068\git\documentum\duecmcustomerwrappers\OFFLINE\BnhpDFSWrapperOffline\ejbModule\bnhp\infra\dfs\services\MainTest.java
-----------------------------------------------------
package bnhp.infra.dfs.services;

public class MainTest {
	public static void main(String argv[]) {
		System.out.println(System.getProperty("java.class.path").replace(";", "\n"));
	}
}


file Read:C:\Users\AP068\git\documentum\duecmcustomerwrappers\OFFLINE\BnhpDFSWrapperOffline\ejbModule\META-INF\ejb-jar.xml
-----------------------------------------------------
<?xml version="1.0" encoding="UTF-8"?>
<ejb-jar version="3.1" xmlns="http://java.sun.com/xml/ns/javaee" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/ejb-jar_3_1.xsd">
  <display-name>BnhpDFSWrapper</display-name>
  <enterprise-beans >
  	<session>
  		<ejb-name>DocumentumServicesJmsWrapper</ejb-name>
  		<ejb-class>bnhp.infra.dfs.services.DocumentumServicesJmsWrapper</ejb-class>
  		<session-type>Stateless</session-type>
  		<transaction-type>Bean</transaction-type>
  	</session>
  	
</enterprise-beans>
</ejb-jar>


file Read:C:\Users\AP068\git\documentum\duecmcustomerwrappers\OFFLINE\BnhpDFSWrapperOffline\ejbModule\META-INF\ibm-ejb-jar-ext.xml
-----------------------------------------------------
<?xml version="1.0" encoding="UTF-8"?>
<ejb-jar-ext
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns="http://websphere.ibm.com/xml/ns/javaee"
    xsi:schemaLocation="http://websphere.ibm.com/xml/ns/javaee http://websphere.ibm.com/xml/ns/javaee/ibm-ejb-jar-ext_1_1.xsd" version="1.1">
  <session name="DocumentumServicesJmsWrapper">
    <start-at-app-start value="true"/>
  </session>

</ejb-jar-ext>



file Read:C:\Users\AP068\git\documentum\duecmcustomerwrappers\OFFLINE\BnhpDFSWrapperOffline\ejbModule\META-INF\webservices.xml
-----------------------------------------------------
<?xml version="1.0" encoding="UTF-8"?>
<webservices xmlns="http://java.sun.com/xml/ns/javaee" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/javaee_web_services_1_2.xsd" version="1.2">
	<webservice-description>
		<webservice-description-name>DocumentumServicesJmsWrapperService</webservice-description-name>
		<port-component>
			<port-component-name>DocumentumServicesJmsWrapper</port-component-name>
			<wsdl-service xmlns:pfx="http://bnhp.infra.services.com">
			pfx:DocumentumServicesJmsWrapperService</wsdl-service>
			<wsdl-port xmlns:pfx="http://bnhp.infra.services.com">
			pfx:DocumentumServicesJmsWrapperPort</wsdl-port>
			<enable-mtom>false</enable-mtom>
			<service-impl-bean>
				<ejb-link>
				DocumentumServicesJmsWrapper</ejb-link>
			</service-impl-bean>
		</port-component>
	</webservice-description>
</webservices>


file Read:C:\Users\AP068\git\documentum\duecmcustomerwrappers\OFFLINE\BnhpDFSWrapperOffline\OfflineLoaderCreator.xml
-----------------------------------------------------
<?xml version="1.0" encoding="UTF-8"?>
<project name="OfflineLoaderCreator" default="createOfflineLoader">
	<target name="createOfflineLoader">
		<property name="servicesDir" value="ejbModule/bnhp/infra/dfs/services" />
		<echo message="${basedir}" />
		<!-- echoproperties/ -->
		<copy
			file="../../ESB/BnhpDFSWrapper/${servicesDir}/DocumentumServicesJmsWrapper.java"
			tofile="${servicesDir}/DocumentumServicesJmsWrapper.java" overwrite="true"
			failonerror="true" />
		<replace file="${servicesDir}/DocumentumServicesJmsWrapper.java"
			token="BnhpDFSWrapperErr" value="BnhpOfflineLoader" />
		<replace file="${servicesDir}/DocumentumServicesJmsWrapper.java"
			token="BnhpDFSWrapper" value="BnhpOfflineLoader" />
		<replaceregexp file="${servicesDir}/DocumentumServicesJmsWrapper.java"
			match="// OfflineExclude\s*(.*?)// OfflineExcludeEnd"
			replace="/*\1*/" flags="sg"/>
	</target>
</project>


file Read:C:\Users\AP068\git\documentum\duecmcustomerwrappers\OFFLINE\BnhpDFSWrapperOffline\pom.xml
-----------------------------------------------------
<?xml version="1.0" encoding="UTF-8"?>

<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
	<modelVersion>4.0.0</modelVersion>
	
	<parent>
		<groupId>com.poalim.documentum</groupId>
		<artifactId>parent</artifactId>
		<version>1.0-SNAPSHOT</version>
	</parent>
	
	<artifactId>BnhpDFSWrapperOffline</artifactId>
	<packaging>ejb</packaging>
	<name>BnhpDFSWrapperOffline</name>
	<description>BnhpDFSWrapperOffline</description>		
	
	<dependencies>					
														
			<dependency>
				<groupId>was</groupId>
				<artifactId>j2ee</artifactId>
				<scope>provided</scope>
			</dependency>
		
			<!-- >dependency>
				<groupId>com.poalim.ht</groupId>
				<artifactId>Logger</artifactId>					
				<scope>provided</scope>
			</dependency-->

			<dependency>
				<groupId>com.poalim.dependencies</groupId>
				<artifactId>documentum-71-deps</artifactId>
				<type>pom</type>
				<scope>provided</scope>
			</dependency>

			<dependency>
				<groupId>bnhp.infra.dfs.services</groupId>
				<artifactId>BHInputObjectContexts</artifactId>						
			</dependency>
			
			<dependency>
				<groupId>bnhp.infra.dfs.services</groupId>
				<artifactId>BHSearchContexts</artifactId>												
			</dependency>
		
			<dependency>				
				<groupId>com.poalim.documentum</groupId>				
				<artifactId>BnhpInfraDFServices</artifactId>
				<classifier>basic</classifier>
				<exclusions>
					<exclusion>
						<groupId>*</groupId>
						<artifactId>*</artifactId>
					</exclusion>
				</exclusions>
			</dependency>
		
			<dependency>
				<groupId>com.poalim.documentum</groupId>
				<artifactId>BnhpWrapperDependencyModule</artifactId>
				<exclusions>
					<exclusion>
						<groupId>*</groupId>
						<artifactId>*</artifactId>
					</exclusion>
				</exclusions>
			</dependency>
		
	</dependencies>						
	
	<build>						
	
		<sourceDirectory>ejbModule</sourceDirectory>
		<resources>
			<resource>
				<directory>ejbModule</directory>
				<excludes>
					<exclude>**/*.java</exclude>
					<exclude>**/.copyarea.db</exclude>
				</excludes>
			</resource>
		</resources>				
		</build>
</project>


file Read:C:\Users\AP068\git\documentum\duecmcustomerwrappers\OFFLINE\BnhpDFSWrapperOffline\target\classes\bnhp\infra\dfs\services\DocumentumServicesJmsWrapperHandlers.xml
-----------------------------------------------------
<?xml version="1.0" encoding="UTF-8"?>
<jws:handler-chains xmlns:jws="http://java.sun.com/xml/ns/javaee">
<!-- Note:  The '*" denotes a wildcard. -->
	<jws:handler-chain name="DocumentumServicesJmsWrapperHandlersChain">
		<!--jws:protocol-bindings>##SOAP11_HTTP ##ANOTHER_BINDING</jws:protocol-bindings>
		<jws:port-name-pattern 
              xmlns:ns1="http://handlersample.samples.ibm.com/">ns1:MySampl*</jws:port-name-pattern>
        <jws:service-name-pattern 
              xmlns:ns1="http://handlersample.samples.ibm.com/">ns1:*</jws:service-name-pattern-->
		<jws:handler>
			<jws:handler-class>bnhp.infra.dfs.services.SAFVersionHandler</jws:handler-class>
		</jws:handler>
		<jws:handler>
			<jws:handler-class>bnhp.infra.dfs.services.InputAttributesHandler</jws:handler-class>
		</jws:handler>
		<jws:handler>
			<jws:handler-class>bnhp.infra.dfs.services.RequestHandler</jws:handler-class>
		</jws:handler>
	</jws:handler-chain>
	
</jws:handler-chains>


file Read:C:\Users\AP068\git\documentum\duecmcustomerwrappers\OFFLINE\BnhpDFSWrapperOffline\target\classes\META-INF\ejb-jar.xml
-----------------------------------------------------
<?xml version="1.0" encoding="UTF-8"?>
<ejb-jar version="3.1" xmlns="http://java.sun.com/xml/ns/javaee" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/ejb-jar_3_1.xsd">
  <display-name>BnhpDFSWrapper</display-name>
  <enterprise-beans >
  	<session>
  		<ejb-name>DocumentumServicesJmsWrapper</ejb-name>
  		<ejb-class>bnhp.infra.dfs.services.DocumentumServicesJmsWrapper</ejb-class>
  		<session-type>Stateless</session-type>
  		<transaction-type>Bean</transaction-type>
  	</session>
  	
</enterprise-beans>
</ejb-jar>


file Read:C:\Users\AP068\git\documentum\duecmcustomerwrappers\OFFLINE\BnhpDFSWrapperOffline\target\classes\META-INF\ibm-ejb-jar-ext.xml
-----------------------------------------------------
<?xml version="1.0" encoding="UTF-8"?>
<ejb-jar-ext
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns="http://websphere.ibm.com/xml/ns/javaee"
    xsi:schemaLocation="http://websphere.ibm.com/xml/ns/javaee http://websphere.ibm.com/xml/ns/javaee/ibm-ejb-jar-ext_1_1.xsd" version="1.1">
  <session name="DocumentumServicesJmsWrapper">
    <start-at-app-start value="true"/>
  </session>

</ejb-jar-ext>



file Read:C:\Users\AP068\git\documentum\duecmcustomerwrappers\OFFLINE\BnhpDFSWrapperOffline\target\classes\META-INF\maven\com.poalim.documentum\BnhpDFSWrapperOffline\pom.properties
-----------------------------------------------------
#Generated by Maven Integration for Eclipse
#Wed Jun 09 16:03:22 IDT 2021
m2e.projectLocation=C\:\\Users\\AP068\\git\\documentum\\duecmcustomerwrappers\\OFFLINE\\BnhpDFSWrapperOffline
m2e.projectName=BnhpDFSWrapperOffline
groupId=com.poalim.documentum
artifactId=BnhpDFSWrapperOffline
version=1.0-SNAPSHOT


file Read:C:\Users\AP068\git\documentum\duecmcustomerwrappers\OFFLINE\BnhpDFSWrapperOffline\target\classes\META-INF\maven\com.poalim.documentum\BnhpDFSWrapperOffline\pom.xml
-----------------------------------------------------
<?xml version="1.0" encoding="UTF-8"?>

<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
	<modelVersion>4.0.0</modelVersion>
	
	<parent>
		<groupId>com.poalim.documentum</groupId>
		<artifactId>parent</artifactId>
		<version>1.0-SNAPSHOT</version>
	</parent>
	
	<artifactId>BnhpDFSWrapperOffline</artifactId>
	<packaging>ejb</packaging>
	<name>BnhpDFSWrapperOffline</name>
	<description>BnhpDFSWrapperOffline</description>		
	
	<dependencies>					
														
			<dependency>
				<groupId>was</groupId>
				<artifactId>j2ee</artifactId>
				<scope>provided</scope>
			</dependency>
		
			<!-- >dependency>
				<groupId>com.poalim.ht</groupId>
				<artifactId>Logger</artifactId>					
				<scope>provided</scope>
			</dependency-->

			<dependency>
				<groupId>com.poalim.dependencies</groupId>
				<artifactId>documentum-71-deps</artifactId>
				<type>pom</type>
				<scope>provided</scope>
			</dependency>

			<dependency>
				<groupId>bnhp.infra.dfs.services</groupId>
				<artifactId>BHInputObjectContexts</artifactId>						
			</dependency>
			
			<dependency>
				<groupId>bnhp.infra.dfs.services</groupId>
				<artifactId>BHSearchContexts</artifactId>												
			</dependency>
		
			<dependency>				
				<groupId>com.poalim.documentum</groupId>				
				<artifactId>BnhpInfraDFServices</artifactId>
				<classifier>basic</classifier>
				<exclusions>
					<exclusion>
						<groupId>*</groupId>
						<artifactId>*</artifactId>
					</exclusion>
				</exclusions>
			</dependency>
		
			<dependency>
				<groupId>com.poalim.documentum</groupId>
				<artifactId>BnhpWrapperDependencyModule</artifactId>
				<exclusions>
					<exclusion>
						<groupId>*</groupId>
						<artifactId>*</artifactId>
					</exclusion>
				</exclusions>
			</dependency>
		
	</dependencies>						
	
	<build>						
	
		<sourceDirectory>ejbModule</sourceDirectory>
		<resources>
			<resource>
				<directory>ejbModule</directory>
				<excludes>
					<exclude>**/*.java</exclude>
					<exclude>**/.copyarea.db</exclude>
				</excludes>
			</resource>
		</resources>				
		</build>
</project>


file Read:C:\Users\AP068\git\documentum\duecmcustomerwrappers\OFFLINE\BnhpDFSWrapperOffline\target\classes\META-INF\webservices.xml
-----------------------------------------------------
<?xml version="1.0" encoding="UTF-8"?>
<webservices xmlns="http://java.sun.com/xml/ns/javaee" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/javaee_web_services_1_2.xsd" version="1.2">
	<webservice-description>
		<webservice-description-name>DocumentumServicesJmsWrapperService</webservice-description-name>
		<port-component>
			<port-component-name>DocumentumServicesJmsWrapper</port-component-name>
			<wsdl-service xmlns:pfx="http://bnhp.infra.services.com">
			pfx:DocumentumServicesJmsWrapperService</wsdl-service>
			<wsdl-port xmlns:pfx="http://bnhp.infra.services.com">
			pfx:DocumentumServicesJmsWrapperPort</wsdl-port>
			<enable-mtom>false</enable-mtom>
			<service-impl-bean>
				<ejb-link>
				DocumentumServicesJmsWrapper</ejb-link>
			</service-impl-bean>
		</port-component>
	</webservice-description>
</webservices>


file Read:C:\Users\AP068\git\documentum\duecmcustomerwrappers\OFFLINE\BnhpDFSWrapperOfflineEAR\ear-generator\.settings\org.eclipse.wst.common.project.facet.core.xml
-----------------------------------------------------
<?xml version="1.0" encoding="UTF-8"?>
<faceted-project>
  <installed facet="jst.ear" version="1.3"/>
</faceted-project>


file Read:C:\Users\AP068\git\documentum\duecmcustomerwrappers\OFFLINE\BnhpDFSWrapperOfflineEAR\ear-generator\maven-assembly-conf.xml
-----------------------------------------------------
<assembly>
  <id>conf</id>
  <formats>
		<format>zip</format>
  </formats>
  <includeBaseDirectory>false</includeBaseDirectory>  
  <fileSets>
    <fileSet>      
	  <directory>../resources</directory>
      <includes>
		<include>**/*</include>
	  </includes>
	  <outputDirectory>resources</outputDirectory>
    </fileSet>
  </fileSets>  
</assembly>


file Read:C:\Users\AP068\git\documentum\duecmcustomerwrappers\OFFLINE\BnhpDFSWrapperOfflineEAR\ear-generator\pom.xml
-----------------------------------------------------
<?xml version="1.0" encoding="UTF-8"?>

<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
	<modelVersion>4.0.0</modelVersion>
	
	<parent>
		<groupId>com.poalim.documentum</groupId>
		<artifactId>BnhpDFSWrapperOfflineEAR-parent</artifactId>
		<version>1.0</version>
	</parent>
	
	<artifactId>BnhpDFSWrapperOfflineEAR</artifactId>
	<version>1.0-SNAPSHOT</version>
	<packaging>ear</packaging>
	<name>BnhpDFSWrapperOfflineEAR</name>
	<description>BnhpDFSWrapperOfflineEAR project</description>	

	<dependencies>
		
		<dependency>
			<groupId>bnhp.infra.dfs.services</groupId>
			<artifactId>BHSearchContexts</artifactId>							
		</dependency>
		
		<dependency>
			<groupId>bnhp.infra.dfs.services</groupId>
			<artifactId>BHAuthorization</artifactId>			
		</dependency>
		
		<dependency>
			<groupId>bnhp.infra.dfs.services</groupId>
			<artifactId>BHGeneralUtil</artifactId>				
		</dependency>						
		
		<dependency>
			<groupId>bnhp.infra.dfs.services</groupId>
			<artifactId>BHInputObjectContexts</artifactId>							
		</dependency>
		
		<dependency>
			<groupId>bnhp.infra.dfs.services</groupId>
			<artifactId>BHObjectContexts</artifactId>				
		</dependency>
		
		<dependency>
			<groupId>bnhp.infra.dfs.services</groupId>
			<artifactId>BHPeulaException</artifactId>				
		</dependency>
		
		<dependency>
			<groupId>com.poalim.documentum</groupId>
			<artifactId>BnhpDFSWrapperOffline</artifactId>
			<type>ejb</type>			
		</dependency>	

		<dependency>
			<groupId>com.poalim.documentum</groupId>
			<artifactId>BnhpDFSWrapperOffline_JC2Router</artifactId>
			<exclusions>
				<exclusion>
					<groupId>*</groupId>
					<artifactId>*</artifactId>
				</exclusion>
			</exclusions>
			<type>ejb</type>
		</dependency>
		
	</dependencies>
	
	<build>
		<plugins>
			
			<plugin>
				<groupId>org.apache.maven.plugins</groupId>
				<artifactId>maven-ear-plugin</artifactId>				
				<configuration>		

					<modules>
					<ejbModule>
							<groupId>com.poalim.documentum</groupId>
							<artifactId>BnhpDFSWrapperOffline</artifactId>
						</ejbModule>
						<ejbModule>
							<groupId>com.poalim.documentum</groupId>
							<artifactId>BnhpDFSWrapperOffline_JC2Router</artifactId>
							<bundleFileName>BnhpDFSWrapperOffline_JC2Router.jar</bundleFileName>
						</ejbModule>
												
					</modules>					
				
					<archive>
						<manifestEntries>
							<Build-Version>${project.version}</Build-Version>
							<Build-Time>${maven.build.timestamp}</Build-Time>
						</manifestEntries>						
					</archive>		
				</configuration>
			</plugin>
			
			<!-- plugin>
								
				<groupId>org.apache.maven.plugins</groupId>
				<artifactId>maven-assembly-plugin</artifactId>	
				<version>2.4</version>
				
				<configuration>					
					<descriptors>
						<descriptor>maven-assembly-conf.xml</descriptor>
					</descriptors>
				</configuration>								
				
				<executions>
					<execution>
						<id>make-assembly</id>
						<phase>package</phase>
						<goals>
							<goal>single</goal>
						</goals>												
					</execution>
				</executions>
				
			</plugin-->	
		</plugins>
	</build>
</project>


file Read:C:\Users\AP068\git\documentum\duecmcustomerwrappers\OFFLINE\BnhpDFSWrapperOfflineEAR\ear-generator\target\m2e-wtp\ear-resources\META-INF\application.xml
-----------------------------------------------------
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE application PUBLIC
	"-//Sun Microsystems, Inc.//DTD J2EE Application 1.3//EN"
	"http://java.sun.com/dtd/application_1_3.dtd">
<application>
  <display-name>BnhpDFSWrapperOfflineEAR</display-name>
  <description>BnhpDFSWrapperOfflineEAR project</description>
  <module>
    <ejb>BnhpDFSWrapperOffline-1.0-SNAPSHOT.jar</ejb>
  </module>
  <module>
    <ejb>BnhpDFSWrapperOffline_JC2Router.jar</ejb>
  </module>
</application>


file Read:C:\Users\AP068\git\documentum\duecmcustomerwrappers\OFFLINE\BnhpDFSWrapperOfflineEAR\ear-generator\target\m2e-wtp\ear-resources\META-INF\maven\com.poalim.documentum\BnhpDFSWrapperOfflineEAR\pom.properties
-----------------------------------------------------
#Generated by Maven Integration for Eclipse
#Thu May 20 19:17:17 IDT 2021
m2e.projectLocation=C\:\\Users\\AP068\\git\\documentum\\duecmcustomerwrappers\\OFFLINE\\BnhpDFSWrapperOfflineEAR\\ear-generator
m2e.projectName=BnhpDFSWrapperOfflineEAR
groupId=com.poalim.documentum
artifactId=BnhpDFSWrapperOfflineEAR
version=1.0-SNAPSHOT


file Read:C:\Users\AP068\git\documentum\duecmcustomerwrappers\OFFLINE\BnhpDFSWrapperOfflineEAR\ear-generator\target\m2e-wtp\ear-resources\META-INF\maven\com.poalim.documentum\BnhpDFSWrapperOfflineEAR\pom.xml
-----------------------------------------------------
<?xml version="1.0" encoding="UTF-8"?>

<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
	<modelVersion>4.0.0</modelVersion>
	
	<parent>
		<groupId>com.poalim.documentum</groupId>
		<artifactId>BnhpDFSWrapperOfflineEAR-parent</artifactId>
		<version>1.0</version>
	</parent>
	
	<artifactId>BnhpDFSWrapperOfflineEAR</artifactId>
	<version>1.0-SNAPSHOT</version>
	<packaging>ear</packaging>
	<name>BnhpDFSWrapperOfflineEAR</name>
	<description>BnhpDFSWrapperOfflineEAR project</description>	

	<dependencies>
		
		<dependency>
			<groupId>bnhp.infra.dfs.services</groupId>
			<artifactId>BHSearchContexts</artifactId>							
		</dependency>
		
		<dependency>
			<groupId>bnhp.infra.dfs.services</groupId>
			<artifactId>BHAuthorization</artifactId>			
		</dependency>
		
		<dependency>
			<groupId>bnhp.infra.dfs.services</groupId>
			<artifactId>BHGeneralUtil</artifactId>				
		</dependency>						
		
		<dependency>
			<groupId>bnhp.infra.dfs.services</groupId>
			<artifactId>BHInputObjectContexts</artifactId>							
		</dependency>
		
		<dependency>
			<groupId>bnhp.infra.dfs.services</groupId>
			<artifactId>BHObjectContexts</artifactId>				
		</dependency>
		
		<dependency>
			<groupId>bnhp.infra.dfs.services</groupId>
			<artifactId>BHPeulaException</artifactId>				
		</dependency>
		
		<dependency>
			<groupId>com.poalim.documentum</groupId>
			<artifactId>BnhpDFSWrapperOffline</artifactId>
			<type>ejb</type>			
		</dependency>	

		<dependency>
			<groupId>com.poalim.documentum</groupId>
			<artifactId>BnhpDFSWrapperOffline_JC2Router</artifactId>
			<exclusions>
				<exclusion>
					<groupId>*</groupId>
					<artifactId>*</artifactId>
				</exclusion>
			</exclusions>
			<type>ejb</type>
		</dependency>
		
	</dependencies>
	
	<build>
		<plugins>
			
			<plugin>
				<groupId>org.apache.maven.plugins</groupId>
				<artifactId>maven-ear-plugin</artifactId>				
				<configuration>		

					<modules>
					<ejbModule>
							<groupId>com.poalim.documentum</groupId>
							<artifactId>BnhpDFSWrapperOffline</artifactId>
						</ejbModule>
						<ejbModule>
							<groupId>com.poalim.documentum</groupId>
							<artifactId>BnhpDFSWrapperOffline_JC2Router</artifactId>
							<bundleFileName>BnhpDFSWrapperOffline_JC2Router.jar</bundleFileName>
						</ejbModule>
												
					</modules>					
				
					<archive>
						<manifestEntries>
							<Build-Version>${project.version}</Build-Version>
							<Build-Time>${maven.build.timestamp}</Build-Time>
						</manifestEntries>						
					</archive>		
				</configuration>
			</plugin>
			
			<!-- plugin>
								
				<groupId>org.apache.maven.plugins</groupId>
				<artifactId>maven-assembly-plugin</artifactId>	
				<version>2.4</version>
				
				<configuration>					
					<descriptors>
						<descriptor>maven-assembly-conf.xml</descriptor>
					</descriptors>
				</configuration>								
				
				<executions>
					<execution>
						<id>make-assembly</id>
						<phase>package</phase>
						<goals>
							<goal>single</goal>
						</goals>												
					</execution>
				</executions>
				
			</plugin-->	
		</plugins>
	</build>
</project>


file Read:C:\Users\AP068\git\documentum\duecmcustomerwrappers\OFFLINE\BnhpDFSWrapperOfflineEAR\META-INF\application.xml
-----------------------------------------------------
<?xml version="1.0" encoding="UTF-8"?>
<application id="Application_ID" version="5" xmlns="http://java.sun.com/xml/ns/javaee" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://java.sun.com/xml/ns/javaee/application_5.xsd">
 <display-name>BnhpDFSWrapperOfflineEAR</display-name>
 <module id="Module_1402929824759">
 	<ejb>BnhpDFSWrapper_JC2Router.jar</ejb>
 </module>
 <module id="Module_1402995636708">
 	<ejb>BnhpDFSWrapperOffline.jar</ejb>
 </module>
</application> 


file Read:C:\Users\AP068\git\documentum\duecmcustomerwrappers\OFFLINE\BnhpDFSWrapperOfflineEAR\pom.xml
-----------------------------------------------------
<?xml version="1.0" encoding="UTF-8"?>

<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
	<modelVersion>4.0.0</modelVersion>
	
	<parent>
		<groupId>com.poalim.documentum</groupId>
		<artifactId>parent</artifactId>
		<version>1.0-SNAPSHOT</version>
	</parent>
	
	<artifactId>BnhpDFSWrapperOfflineEAR-parent</artifactId>
	<version>1.0</version>
	<packaging>pom</packaging>
	<name>BnhpDFSWrapperOfflineEAR parent</name>
	<description>BnhpDFSWrapperOfflineEAR parent</description>	
	
	<modules>	
		<module>ear-generator</module>		
		<module>../BnhpDFSWrapperOffline</module>
		<module>../BnhpDFSWrapperOffline_JC2Router</module>		
	</modules>
	
	
</project>


file Read:C:\Users\AP068\git\documentum\duecmcustomerwrappers\OFFLINE\BnhpDFSWrapperOffline_JC2Router\.settings\org.eclipse.wst.common.project.facet.core.xml
-----------------------------------------------------
<?xml version="1.0" encoding="UTF-8"?>
<faceted-project>
  <installed facet="java" version="1.6"/>
  <installed facet="jst.ejb" version="3.0"/>
</faceted-project>


file Read:C:\Users\AP068\git\documentum\duecmcustomerwrappers\OFFLINE\BnhpDFSWrapperOffline_JC2Router\ejbModule\bnhp\infra\dfs\services\BnhpInboundMessageListener.java
-----------------------------------------------------
package bnhp.infra.dfs.services;

import java.io.ByteArrayInputStream;
import java.io.ByteArrayOutputStream;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.UnsupportedEncodingException;
import java.nio.channels.FileChannel;
import java.security.PrivilegedAction;
import java.text.SimpleDateFormat;
import java.util.Arrays;
import java.util.Date;
import java.util.Enumeration;
import java.util.HashMap;
import java.util.Map;
import java.util.Properties;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

import javax.annotation.Resource;
import javax.ejb.MessageDrivenContext;
import javax.naming.InitialContext;
import javax.resource.ResourceException;
import javax.resource.cci.Record;
import javax.xml.parsers.FactoryConfigurationError;
import javax.xml.stream.Location;
import javax.xml.stream.XMLInputFactory;
import javax.xml.stream.XMLStreamException;
import javax.xml.stream.events.XMLEvent;

import org.apache.axiom.om.OMException;
import org.apache.axiom.soap.SOAPEnvelope;
import org.apache.axis2.AxisFault;
import org.apache.axis2.addressing.AddressingConstants;
import org.apache.axis2.addressing.EndpointReference;
import org.apache.axis2.context.ConfigurationContext;
import org.apache.axis2.context.MessageContext;
import org.apache.axis2.engine.AxisConfiguration;
import org.apache.axis2.engine.AxisEngine;
import org.apache.axis2.transport.TransportUtils;

import bnhp.infra.dfs.services.exceptions.ECMTemporaryFailure;
import bnhp.infra.dfs.services.exceptions.ECMValidationException;
import bnhp.infra.dfs.utils.basic.LoggingUtils;
import bnhp.infra.dfs.utils.service.DfsRequestThreadAttributes;

import com.ibm.j2ca.flatfile.FlatFileInputStreamRecord;
import com.ibm.websphere.security.WSSecurityException;
import com.ibm.ws.security.core.ContextManagerFactory;
import com.ibm.ws.security.util.AccessController;
import com.ibm.ws.webservices.management.Endpoint;
import com.ibm.ws.websvcs.metadata.ServerModuleMetaData;
import com.ibm.ws.websvcs.utils.Axis2Utils;
import com.ibm.wsspi.runtime.service.WsServiceRegistry;
import com.ibm.wsspi.security.context.ContextManager;
import com.ibm.wsspi.webservices.management.EndpointManagerMBean;
import com.ibm.wsspi.websvcs.WASAxis2Service;

//@TransactionManagement(TransactionManagementType.BEAN)
public class BnhpInboundMessageListener implements
		commonj.connector.runtime.InboundListener {

	// configuration resource for properties file
	@Resource(name = "propertiesFileName")
	public String propertiesFileName;

	public String getPropertiesFileName() {
		return propertiesFileName;
	}

	public void setPropertiesFileName(String propertiesFileName) {
		this.propertiesFileName = propertiesFileName;
	}

	boolean isInitialized = false;
	String loggerName = null;
	// configuration properties
	protected String instanceName = "BnhpInboundMessageListener-"
			+ this.toString();

	public static final String OFFLINE_TARGET_SERVICE_PROP = "offline_target_service";

	// temporary, will be loaded from the control table
	public static final String OFFLINE_INPUT_DIRS_PROP = "offline_input_dirs";
	public static final String OFFLINE_ARCHIVE_DIRS_PROP = "offline_archive_dirs";
	public static final String OFFLINE_ERRORS_DIRS_PROP = "offline_errors_dirs";

	// public static final String
	// OFFLINE_ARCHIVE_FILE_PATTERN="offline_archivefile_pattern";
	public static final String OFFLINE_ERROR_FILE_PATTERN = "offline_errorfile_pattern";

	public static final String OFFLINE_SUCCESS_ACTION_PROP = "offline_success_action";
	public static final String OFFLINE_APP_ERROR_ACTION_PROP = "offline_app_error_action";
	public static final String OFFLINE_GEN_ERROR_ACTION_PROP = "offline_gen_error_action";
	public static final String OFFLINE_LOG_SERVICE_PROP = "offline_log_service";
	public static final String OFFLINE_INSTANCE_NAME = "offline_instance_name";
	public static final String OFFLINE_SOAP_ENVELOPE_ACTION_PROP = "offline_soap_envelope_action";

	// option is like offline_def_namespace_methodName=xmlns="http://something"
	public static final String OFFLINE_DEF_NAMESPACE_PROP_PREFIX = "offline_def_namespace_";

	protected ErrorAction successAction = ErrorAction.SAVE;
	protected ErrorAction appErrorAction = ErrorAction.SAVE;
	protected ErrorAction genErrorAction = ErrorAction.SAVE;

	// what to do with soap envelope
	protected SOAPEnvelopeAction soapEnvelopeAction = SOAPEnvelopeAction.ADD_IF_MISSING;
	protected byte[] soapPrefix;
	protected byte[] soapSuffix;

	// configuration parameters
	protected String targetService = null;
	protected File[] inputDirs;
	protected File[] archiveDirs;
	protected File[] errorDirs;

	// pattern for filename creation
	protected String errorFilePattern = "~ROOT~/~DATE~/~HOUR~/~FILENAME~.failure.~TIMESTAMP~";
	protected String archiveFilePattern = "~ROOT~/~DATE~/~HOUR~/~FILENAME~.success.~TIMESTAMP~";

	protected Map<String, byte[]> defNamespaces = null;
	protected Map<String, byte[]> defPrefixes = null;

	// intialized at first message
	protected ConfigurationContext configContext = null;

	public BnhpInboundMessageListener() {
		super();
		initDctmRequestId();
		debug("status=creatingInstance " + this);
	}

	private void initDctmRequestId() {
		if (DfsRequestThreadAttributes.dctmRequestId == null
				|| DfsRequestThreadAttributes.dctmRequestId.get() == null) {
			DfsRequestThreadAttributes.generateDctmRequestId();
		}
	}

	/**
	 * This is the entry point of the MDB, called for each input file (record in
	 * the JC2 terminology)
	 */
	@Override
	public void onNotification(Record inputData) throws ResourceException {
		// There are four possible outcomes of this method:
		// 1. hard exception - one that causes transaction rollback
		// and handled by the websphere infrastructure (which can
		// be configured to perform retries)
		// 2. Application exception - one that is known to be caused
		// by bad applicational input data, usually identified
		// by code inside the called web service (like incorrect
		// value in a field, missing field values, etc). Such
		// an exception usually causes service to delete input
		// data since there is no use in retrying
		// 3. General exception - none of the above, usually should
		// be saved into ERRORS dir for further analysis.
		// 4. Success
		String errMsg = "Offline operation failed with a HARD exception: ";
		ResourceException errEx = null;
		initDctmRequestId();
		initLogger();
		// FIXME: must be called by container!
		if (!isInitialized) {
			initialize();
		}

		MessageDrivenContext ctx = getMDBContext();
		ErrorAction action = this.successAction;
		Date startDate = new Date();
		File inputFile = null;

		File archiveDir = null;
		File errorDir = null;
		try {

			FlatFileInputStreamRecord isr = this.getInputRecord(inputData);
			inputFile = new File(isr.getDirectoryPath() + File.separator
					+ isr.getFilename());
			log("status=processingInput record=" + inputFile);

			archiveDir = this.matchOutputDir(inputFile, this.archiveDirs);
			debug("archiveDir=" + archiveDir);
			errorDir = this.matchOutputDir(inputFile, this.errorDirs);
			debug("errorDir=" + errorDir);

			debug("status=gettingRecordContent");
			byte[] contentBytes = isr.getBytes();
			debug("inputContentSize=" + contentBytes.length + " bytes");
			String content = new String(contentBytes);
			debug("content=\n" + content);
			contentBytes = handleSOAPEnvelope(contentBytes);

			if (null == this.configContext) {
				getConfigContext();
			}

			ByteArrayOutputStream responseOstrm = new ByteArrayOutputStream();
			MessageContext msgContext = createMessageContext(contentBytes,
					responseOstrm);
			// this custom property is use to pass location to wrapper
			msgContext.setProperty("BNHP_OFFLINE_MESSAGE_PATH",
					inputFile.getAbsolutePath());
			msgContext.setMessageID(System.currentTimeMillis() + "_"
					+ inputFile.getAbsolutePath());
			log(" status=callingAxisEngine");
			AxisEngine.receive(msgContext);
			log(" status=AxisEngineFinished");

			/* does not really produce output for some reason! */
			responseOstrm.flush();
			byte[] outArray = responseOstrm.toByteArray();
			if (null != outArray) {
				debug(" AxisEngineOutput="
						+ new String(responseOstrm.toByteArray()));
			} else {
				error("AxisEngine returned null");
			}
			log("status=SUCCESS, action=" + action);
			if (ErrorAction.SAVE.equals(this.successAction)) {
				try {
					moveToDir(inputFile, startDate, archiveDir,
							archiveFilePattern);
				} catch (Exception ex) {
					error("failed to archive success file to " + archiveDir
							+ ": " + ex);
				}
			}
		} catch (org.apache.axis2.AxisFault ax) {
			error("got  org.apache.axis2.AxisFault: " + ax);
			Throwable cause = null;
			if (null != (cause = drillToCause(ax, ECMValidationException.class))) {
				errMsg = "Offline operation failed with an APPLICATION exception: ";
				action = this.appErrorAction;
				errEx = new ResourceException(cause);
			} else if (null != (cause = drillToCause(ax,
					ECMTemporaryFailure.class))) {
				// kind of HARD exception
				action = ErrorAction.GIVEUP;
				errEx = new ResourceException(cause);
			} else {
				errMsg = "Offline operation failed with a GENERAL exception: ";
				if (null != ax.getCause()) {
					debug("got  org.apache.axis2.AxisFault because of "
							+ ax.getCause());
					errEx = new ResourceException(ax.getCause());
				} else {
					errEx = new ResourceException(ax);
				}
				action = this.genErrorAction;
			}
			log("errorAction=" + action);
			if (ErrorAction.SAVE.equals(action)) {
				// save input to error dir and signal transaction as commited
				try {
					moveToDir(inputFile, startDate, errorDir, errorFilePattern);
				} catch (Exception ex) {
					// throws ResourceException
					giveUp(ctx, "failed to perform save action because of "
							+ ex + ", giving up", errEx);
				}
			} else if (ErrorAction.GIVEUP.equals(action)) {
				// throws ResourceException
				giveUp(ctx, "giving up processing because of exception", errEx);
			} else {
				// Ignore
				log("Finishing handling without saving input " + ax.getCause());
			}
		} catch (ResourceException rex) {
			// HARD exception because of unexpected processing error (non- axis)
			// throws ResourceException
			error("got ResourceExceptionException: " + rex);
			giveUp(ctx, "giving up processing because of exception", rex);
		} catch (Exception ex) {
			// HARD exception because of unexpected processing error (non- axis)
			// throws ResourceException
			error("got Exception: " + ex);
			giveUp(ctx, "giving up processing because of exception",
					(errEx = (new ResourceException(ex))));
		} finally {
			long elapsed = System.currentTimeMillis() - startDate.getTime();
			if (null != errEx) {
				error(errMsg + errEx + ": " + errEx.getMessage()
						+ ", elapsedTime=" + elapsed);
			} else {
				log("Offline operation succeeded, elapsedTime=" + elapsed);
			}
			DfsRequestThreadAttributes.dctmRequestId.set(null);
		}
	}

	private void initLogger() {
		if (DfsRequestThreadAttributes.logger == null
				|| null == DfsRequestThreadAttributes.logger.get()) {
			log("logging will continue to Logger(" + loggerName + ")");
			DfsRequestThreadAttributes.logger.set(new LoggingUtils(loggerName,
					false));
		}
	}

	protected class DataAnalysis {
		boolean hasEnvelope = false;
		int startDocumentOffset = -1;
		int endFirstElementOffset = -1;
		int startLastElementOffset = -1;
		boolean methodHasXMLNS = false;
		boolean success = false;
		String startElementName = null;

		public String toString() {
			return "[hasEnvelope=" + hasEnvelope + ", startDocumentOffset="
					+ startDocumentOffset + ", endFirstElementOffset="
					+ endFirstElementOffset + ", startLastElementOffset="
					+ startLastElementOffset + ", methodHasXMLNS="
					+ methodHasXMLNS + ", startElementName='"
					+ startElementName + "'" + ", success=" + success + "]";
		}
	}

	/**
	 * Adds/strips/ignores SOAP envelope according to configured SOAP Envelope
	 * Action
	 * 
	 * @param contentBytes
	 * @return
	 */
	protected byte[] handleSOAPEnvelope(byte[] contentBytes) {
		if (SOAPEnvelopeAction.AS_IS.equals(soapEnvelopeAction)) {
			log("soapEnvelopeAction=AS_IS inputStatus=notChangingFileContent");
			return contentBytes;
		} else if (SOAPEnvelopeAction.ADD_IF_MISSING.equals(soapEnvelopeAction)) {
			log("soapEnvelopeAction=ADD_IF_MISSING inputStatus=checkingEnvelopePresence");
			DataAnalysis analysis = analyzeData(contentBytes);
			if (analysis.success) {
				log("analysisStatus=success analysis=" + analysis);
				if (analysis.hasEnvelope) {
					log("inputStatus=notChangingFileContent");
				} else {
					log("inputStatus=addingEnvelope");
					contentBytes = addSoapEnvelope(contentBytes, analysis);
					String content = new String(contentBytes);
					debug("contentAfterEnvelopeWrapping=\n" + content);
				}
			} else {
				log("analysisStatus=failure action=willPassInputAsIs");
			}
		} else {
			error("unknown soap envelope action: " + soapEnvelopeAction);
		}
		return contentBytes;
	}

	protected XMLInputFactory xmlInputFactory = null;

	protected DataAnalysis analyzeData(byte[] contentBytes) {
		DataAnalysis result = new DataAnalysis();
		ByteArrayInputStream is = new ByteArrayInputStream(contentBytes);
		javax.xml.stream.XMLStreamReader reader = null;
		try {
			reader = xmlInputFactory.createXMLStreamReader(is, "UTF-8");
			String name = null;
			boolean stopParsing = false;
			while (!stopParsing) {
				int eventType = reader.getEventType();
				switch (eventType) {
				case XMLEvent.START_ELEMENT:
					name = reader.getLocalName();
					// System.out.println("name="+name);
					int colonPos = name.indexOf(':');
					if (colonPos >= 0 && (colonPos < name.length() - 1)) {
						name = name.substring(colonPos + 1);
					}
					result.hasEnvelope = "Envelope".equalsIgnoreCase(name);
					result.startElementName = name;
					// this requires namespace aware parsing
					// but we cannot be sure that all our inputs are
					// namespace correct
					// result.methodHasXMLNS = null != reader.getNamespaceURI();
					// info("NAMESPACE URI: "+reader.getNamespaceURI());
					int attrCount = reader.getAttributeCount();
					for (int i = 0; i < attrCount; i++) {
						String attrName = reader.getAttributeLocalName(i);
						if (attrName.equals("xmlns")
								|| attrName.startsWith("xmlns:")) {
							result.methodHasXMLNS = true;
							break;
						}
					}
					result.success = true;
					// envelope must be the first element
					stopParsing = true;
					continue;
				case XMLEvent.START_DOCUMENT:
					Location location = reader.getLocation();
					if (null != location) {
						result.startDocumentOffset = location
								.getCharacterOffset();
						if (result.startDocumentOffset < 0) {
							warn("firstXmlElementInvalidLocation="
									+ result.startDocumentOffset);
						}
					} else {
						warn("firstXmlElementInvalidLocation=undefined");
					}
					// location.getCharacterOffset() does not have to be
					// implemented by reader
					if (result.startDocumentOffset < 0) {
						result.startDocumentOffset = fallbackGetStartDocumentOffset(contentBytes);
					}
					break; // end of switch
				}
				if (!reader.hasNext()) {
					break; // end of loop
				}
				reader.next();
			}
			if (null == name) {
				error("state=noXmlElementsInInput");
			}
			if (!result.hasEnvelope) {
				result.endFirstElementOffset = findEndFirstElementOffset(
						contentBytes, result.startDocumentOffset);
				result.startLastElementOffset = findStartLastElementOffset(
						contentBytes, result.endFirstElementOffset);
			}
		} catch (XMLStreamException e) {
			error("failed to analyze input stream: " + e.getMessage());
		} finally {
			if (null != reader) {
				try {
					reader.close();
				} catch (XMLStreamException ex) {
					error("failed to close xml reader: " + ex.getMessage());
				}
			}
			try {
				is.close();
			} catch (IOException ex) {
				error("failed to close input stream whyle analyzing content: "
						+ ex.getMessage());
			}
		}
		return result;
	}

	protected int findEndFirstElementOffset(byte[] contentBytes, int startOffset) {
		int result = -1;
		if (startOffset >= 0) {
			for (int i = startOffset; i < contentBytes.length - 1; i++) {
				char chr = (char) contentBytes[i];
				if (chr == '>') {
					result = i;
					break;
				}
			}
		}
		return result;
	}

	protected int findStartLastElementOffset(byte[] contentBytes,
			int startOffset) {
		int result = -1;
		for (int i = contentBytes.length - 2; i > 0 && i > startOffset + 1; i--) {
			if (((char) contentBytes[i]) == '/'
					&& ((char) contentBytes[i - 1]) == '<') {
				result = i;
				break;
			}
		}
		return result;
	}

	protected int fallbackGetStartDocumentOffset(byte[] contentBytes) {
		int result = -1;
		for (int i = 0; i < contentBytes.length - 1; i++) {
			char chr = (char) contentBytes[i];
			if (chr == '<') {
				char next = (char) contentBytes[i + 1];
				if (next == '?') {
					continue;
				} else {
					result = i;
					break;
				}
			}
		}
		return result;
	}

	protected byte[] getNamespaceAttr(byte[] contentBytes, DataAnalysis analysis) {
		byte[] result = null;
		if (null == this.defNamespaces || analysis.methodHasXMLNS
				|| analysis.hasEnvelope || analysis.startDocumentOffset < 0
				|| analysis.endFirstElementOffset < 0
				|| null == analysis.startElementName) {
			return result;
		}
		result = this.defNamespaces.get(analysis.startElementName);
		if (null == result) {
			warn("there is no default namespace for element '"
					+ analysis.startElementName + "'");
		}
		return result;
	}

	protected byte[] getNamespacePrefix(byte[] contentBytes,
			DataAnalysis analysis) {
		byte[] result = null;
		if (null == this.defPrefixes || analysis.methodHasXMLNS
				|| analysis.hasEnvelope || analysis.startDocumentOffset < 0
				|| analysis.endFirstElementOffset < 0
				|| null == analysis.startElementName) {
			return result;
		}
		result = this.defPrefixes.get(analysis.startElementName);
		if (null == result) {
			warn("there is no default namespace prefix for element '"
					+ analysis.startElementName + "'");
		}
		return result;
	}

	protected byte[] addSoapEnvelope(byte[] contentBytes, DataAnalysis analysis) {
		byte[] addNamespaceBytes = null;
		int addNamespaceLength = 0;

		byte[] addPrefixBytes = null;
		int addPrefixLength = 0;

		if (!analysis.methodHasXMLNS) {
			addNamespaceBytes = getNamespaceAttr(contentBytes, analysis);
			if (null != addNamespaceBytes) {
				addNamespaceLength = addNamespaceBytes.length;
			}
			addPrefixBytes = getNamespacePrefix(contentBytes, analysis);
			if (null != addPrefixBytes) {
				addPrefixLength = addPrefixBytes.length;
			}
		}

		byte[] output = new byte[contentBytes.length + soapPrefix.length
				+ soapSuffix.length + addNamespaceLength + addPrefixLength * 2];
		int inputPos = 0;
		int pos = 0;
		// copy xml prefix if any
		for (; inputPos < analysis.startDocumentOffset; inputPos++) {
			output[pos++] = contentBytes[inputPos];
		}
		// add soap envelope prefix
		for (int i = 0; i < soapPrefix.length; i++) {
			output[pos++] = soapPrefix[i];
		}
		// move past starting <
		output[pos++] = contentBytes[inputPos++];
		// add namespace if needed
		if (addNamespaceLength > 0) {
			// add namespace prefix to tag
			if (addPrefixLength > 0) {
				for (int i = 0; i < addPrefixLength; i++) {
					output[pos++] = addPrefixBytes[i];
				}
			}
			for (; inputPos < analysis.endFirstElementOffset; inputPos++) {
				output[pos++] = contentBytes[inputPos];
			}
			for (int i = 0; i < addNamespaceLength; i++) {
				output[pos++] = addNamespaceBytes[i];
			}
		}
		// copy request until last element start
		if ((addPrefixLength > 0) && (analysis.startLastElementOffset > 0)) {
			for (; inputPos <= analysis.startLastElementOffset; inputPos++) {
				output[pos++] = contentBytes[inputPos];
			}
			for (int i = 0; i < addPrefixLength; i++) {
				output[pos++] = addPrefixBytes[i];
			}
		}
		// copy rest
		for (; inputPos < contentBytes.length; inputPos++) {
			output[pos++] = contentBytes[inputPos];
		}
		// add soap envelope suffix
		for (int i = 0; i < soapSuffix.length; i++) {
			output[pos++] = soapSuffix[i];
		}
		return output;
	}

	protected synchronized void initialize() throws ResourceException {
		if (!isInitialized) {
			try {
				log("status=InitializingInstance name=" + this + " class="
						+ this.getClass().getSimpleName());
				if (null == this.getPropertiesFileName()) {
					throw new RuntimeException(
							"Need name of properties file, please configure the propertiesFileName environment variable");
				}
				log("resource='" + this.getPropertiesFileName() + "'");
				InputStream inputStream = null;
				Properties properties = new Properties();
				try {
					inputStream = this.getClass().getResourceAsStream(
							this.getPropertiesFileName());

					if (inputStream == null) {
						error("failed to open resource "
								+ this.getPropertiesFileName());
						throw new RuntimeException("failed to open resource "
								+ this.getPropertiesFileName());
					}

					properties.load(inputStream);
				} catch (IOException e) {
					error("failed to read input stream: " + e.getMessage());
					throw new RuntimeException("failed to read resource "
							+ this.getPropertiesFileName(), e);
				} finally {
					if (null != inputStream) {
						try {
							inputStream.close();
						} catch (IOException e) {
							error("failed to close input stream: "
									+ e.getMessage());
						}
					}
				}
				loggerName = properties.getProperty(OFFLINE_LOG_SERVICE_PROP);
				initLogger();

				if (null != properties.getProperty(OFFLINE_INSTANCE_NAME)) {
					this.instanceName = properties
							.getProperty(OFFLINE_INSTANCE_NAME);
					log("instanceName='" + this.instanceName + "'");
				}

				targetService = properties
						.getProperty(OFFLINE_TARGET_SERVICE_PROP);
				log("targetService='" + targetService + "'");
				if (null == targetService) {
					throw new RuntimeException("targetService not configured");
				}

				initDirectories(properties);

				appErrorAction = initErrorAction(properties,
						OFFLINE_APP_ERROR_ACTION_PROP, appErrorAction);
				log("appErrorAction=" + appErrorAction);

				genErrorAction = initErrorAction(properties,
						OFFLINE_GEN_ERROR_ACTION_PROP, genErrorAction);
				log("genErrorAction=" + appErrorAction);

				successAction = initErrorAction(properties,
						OFFLINE_SUCCESS_ACTION_PROP, successAction);
				log("genErrorAction=" + appErrorAction);

				if (!properties.containsKey(OFFLINE_SOAP_ENVELOPE_ACTION_PROP)) {
					log("defaultSoapEnvelopeAction=" + soapEnvelopeAction);
				} else {
					soapEnvelopeAction = initSoapEnvelopeAction(properties,
							OFFLINE_APP_ERROR_ACTION_PROP, soapEnvelopeAction);
					log("soapEnvelopeAction=" + soapEnvelopeAction);
				}
				if (!SOAPEnvelopeAction.AS_IS.equals(soapEnvelopeAction)) {
					debug("status=initSoapHeaderProcessing");
					initSoapHeaderProcessing();
					debug("status=SoapHeaderProcessingInitialized");
				}

				if (!properties.containsKey(OFFLINE_ERROR_FILE_PATTERN)) {
					log("defaultErrorFilePattern=" + this.errorFilePattern);
				} else {
					errorFilePattern = properties
							.getProperty(OFFLINE_ERROR_FILE_PATTERN);
					log("errorFilePattern=" + this.errorFilePattern);
				}

				Enumeration propsEn = properties.propertyNames();
				Map<String, byte[]> nsMap = null;
				Map<String, byte[]> prefixMap = null;
				Pattern prefixPattern = Pattern
						.compile("^\\s*xmlns:(\\w+) *=.*$");
				while (propsEn.hasMoreElements()) {
					String key = (String) propsEn.nextElement();
					if (key.startsWith(OFFLINE_DEF_NAMESPACE_PROP_PREFIX)) {
						String method = key
								.substring(OFFLINE_DEF_NAMESPACE_PROP_PREFIX
										.length());
						String nsAttr = properties.getProperty(key);

						String nsPrefix = null;
						Matcher matcher = prefixPattern.matcher(nsAttr);
						if (matcher.matches()) {
							nsPrefix = matcher.group(1);
						} else {
							warn("failed to find namespace prefix in the specification '"
									+ nsAttr + "'");
						}

						if (null == nsMap) {
							nsMap = new HashMap<String, byte[]>(1);
						}
						nsMap.put(method, (" " + nsAttr).getBytes("UTF-8"));
						log("default namespace for " + method + ": " + nsAttr);

						if (null != nsPrefix) {
							if (null == prefixMap) {
								prefixMap = new HashMap<String, byte[]>(1);
							}
							prefixMap.put(method,
									(nsPrefix + ":").getBytes("UTF-8"));
							log("default prefix for " + method + ": "
									+ nsPrefix);
						}
					}
				}
				this.defNamespaces = nsMap;
				this.defPrefixes = prefixMap;
				isInitialized = true;
				log("status=InstanceInitialized");
			} catch (ResourceException ex) {
				error("Exception initializing: " + ex);
				throw ex;
			} catch (Exception ex) {
				error("Exception initializing: " + ex);
				throw new ResourceException(ex);
			}
		}
	}

	protected SOAPEnvelopeAction initSoapEnvelopeAction(Properties loader,
			String prop, SOAPEnvelopeAction defaultValue) {
		SOAPEnvelopeAction result = defaultValue;
		if (null != prop && null != loader.getProperty(prop)) {
			String value = loader.getProperty(prop);
			result = SOAPEnvelopeAction.fromString(value);
			if (null == result) {
				throw new RuntimeException(
						"Configuration exception: invalid soap envelope action specified: "
								+ value);
			}
		}
		return result;
	}

	protected void initSoapHeaderProcessing()
			throws UnsupportedEncodingException {
		xmlInputFactory = XMLInputFactory.newInstance();
		xmlInputFactory.setProperty(XMLInputFactory.IS_NAMESPACE_AWARE, false);
		this.soapPrefix = ("<soap:Envelope "
				+ "xmlns:soap=\"http://schemas.xmlsoap.org/soap/envelope/\">"
				+ "<soap:Body>\n").getBytes("UTF-8");
		this.soapSuffix = ("</soap:Body>\n</soap:Envelope>\n")
				.getBytes("UTF-8");
	}

	protected ErrorAction initErrorAction(Properties loader, String prop,
			ErrorAction defaultValue) {
		ErrorAction result = defaultValue;
		if (null != prop && null != loader.getProperty(prop)) {
			String value = loader.getProperty(prop);
			result = ErrorAction.fromString(value);
			if (null == result) {
				throw new RuntimeException(
						"Configuration exception: invalid error action specified: "
								+ value);
			}
		}
		return result;
	}

	private void initDirectories(Properties loader) throws ResourceException {
		inputDirs = initDirectory(OFFLINE_INPUT_DIRS_PROP, loader);
		log("inputDirs=" + Arrays.asList(inputDirs));
		// archiveDirs = initDirectory(ARCHIVE_INPUT_DIRS_PROP);
		// log("archiveDirs: "+Arrays.asList(archiveDirs));
		errorDirs = initDirectory(OFFLINE_ERRORS_DIRS_PROP, loader);
		log("errorDirs=" + Arrays.asList(errorDirs));

		archiveDirs = initDirectory(OFFLINE_ARCHIVE_DIRS_PROP, loader);
		log("archiveDirs=" + Arrays.asList(archiveDirs));

		if ((errorDirs.length != archiveDirs.length)
				|| (errorDirs.length != inputDirs.length)) {
			throw new RuntimeException(
					"Configuration exception: need same number of input, archive, error directories");
		}
	}

	private File[] initDirectory(String propName, Properties loader)
			throws ResourceException {
		String specStr = loader.getProperty(propName);
		if (null == specStr) {
			throw new RuntimeException("property " + propName + " is not set");
		}
		String[] paths = specStr.split(",");
		File[] dirs = new File[paths.length];
		for (int i = 0; i < paths.length; i++) {
			String path = paths[i].trim();
			dirs[i] = new File(path);
			if (!(dirs[i].exists() && dirs[i].isDirectory())) {
				error("status=initDirectory notExistingPath='"
						+ dirs[i].getAbsolutePath() + "'");
				throw new ResourceException(" the path '"
						+ dirs[i].getAbsolutePath()
						+ "' does not exist or not a directory");
			}
		}
		return dirs;
	}

	protected void moveToDir(File file, Date ts, File targetRootDir,
			String pattern) throws ResourceException {
		String path = file.getAbsolutePath();
		log("status=moving fileName='" + path + "' outputDir=" + targetRootDir);
		File outFile = produceOutFileName(pattern, targetRootDir, file, ts);
		if (!outFile.isAbsolute()) {
			throw new ResourceException("Generated archive name '" + outFile
					+ "' is not absolute!");
		}
		File targetDir = outFile.getParentFile();
		if (null == targetDir || targetDir.equals(outFile)) {
			throw new ResourceException("Generated wrong target directory '"
					+ targetDir + "' for file '" + outFile + "'");
		}
		if (!targetDir.isDirectory()) {
			debug("statues=creatingTargetPath path='" + targetDir + "'");
			targetDir.mkdirs();
			if (!targetDir.isDirectory()) {
				throw new ResourceException("failed to create directory "
						+ targetDir + "'");
			}
		}
		archiveFile(file, outFile);
	}

	protected void archiveFile(File file, File errorFile)
			throws ResourceException {
		FileChannel inputChannel = null;
		FileChannel outputChannel = null;
		try {
			log("status=copyContent from=" + file + " to=" + errorFile);
			inputChannel = new FileInputStream(file).getChannel();
			outputChannel = new FileOutputStream(errorFile).getChannel();
			outputChannel.transferFrom(inputChannel, 0, inputChannel.size());
			outputChannel.force(true);
		} catch (IOException ioex) {
			error("Failed to copy content" + ioex.getMessage());
			throw new ResourceException("Failed to copy content", ioex);
		} finally {
			if (null != inputChannel) {
				try {
					inputChannel.close();
				} catch (IOException e) {
					error("failed to close streams: " + e.getMessage());
				}
			}
			if (null != outputChannel) {
				try {
					outputChannel.close();
				} catch (IOException e) {
					error("failed to close streams: " + e.getMessage());
				}
			}

		}
	}

	protected void checkCreateDirs(File dir) throws IOException {
		if (dir.exists() || (dir == null)) {
			return;
		}
		File parentDir = dir.getParentFile();
		if (parentDir.equals(dir)) {
			return;
		}
		checkCreateDirs(parentDir);
		if (!parentDir.isDirectory()) {
			throw new IOException("Failed to create parent directory '"
					+ parentDir + "'");
		}
	}

	protected SimpleDateFormat dateFormat = new SimpleDateFormat("yyyy-MM-dd");
	protected SimpleDateFormat hourFormat = new SimpleDateFormat("HH");
	protected SimpleDateFormat minuteFormat = new SimpleDateFormat("mm");
	protected SimpleDateFormat secondFormat = new SimpleDateFormat("ss");
	protected SimpleDateFormat monthFormat = new SimpleDateFormat("MM");
	protected SimpleDateFormat yearFormat = new SimpleDateFormat("yyyy");
	protected SimpleDateFormat dayFormat = new SimpleDateFormat("dd");
	protected SimpleDateFormat timestampFormat = new SimpleDateFormat(
			"yyyy-MM-dd_HH-MM-ss-SS");

	protected File produceOutFileName(String pattern, File errorDirRoot,
			File file, Date date) {
		String name = file.getName();
		String outFilePath = pattern;
		// "~ROOT~/~DATE~/~HOUR~/~FILENAME~.failure.~TIMESTAMP~";
		outFilePath = outFilePath.replace("~DATE~", dateFormat.format(date));
		outFilePath = outFilePath.replace("~HOUR~", hourFormat.format(date));
		outFilePath = outFilePath
				.replace("~MINUTE~", minuteFormat.format(date));
		outFilePath = outFilePath
				.replace("~SECOND~", secondFormat.format(date));
		outFilePath = outFilePath.replace("~YEAR~", yearFormat.format(date));
		outFilePath = outFilePath.replace("~MONTH~", monthFormat.format(date));
		outFilePath = outFilePath.replace("~DAY~", dayFormat.format(date));
		outFilePath = outFilePath.replace("~TIMESTAMP~",
				timestampFormat.format(date));
		outFilePath = outFilePath.replace("~ROOT~",
				errorDirRoot.getAbsolutePath());
		outFilePath = outFilePath.replace("~FILENAME~", name);
		File outFile = new File(outFilePath);
		debug("GeneratedPath='" + outFile + "'");

		return outFile;
	}

	protected File matchOutputDir(File file, File[] outDirs)
			throws ResourceException {
		String path = file.getAbsolutePath();
		int i;
		for (i = 0; i < this.inputDirs.length; i++) {
			if (path.startsWith(inputDirs[i].getAbsolutePath())) {
				break;
			}
		}
		if (i >= inputDirs.length) {
			error("Failed to find input dir that to corresponds to '" + path
					+ "'");
			error("  known input dirs are: " + Arrays.asList(inputDirs));
			throw new ResourceException(
					"Failed to find input dir that to corresponds to '" + path
							+ "'");
		}
		debug("matchedInputDir=" + inputDirs[i]);
		debug("matchedOutputDir=" + outDirs[i]);
		return outDirs[i];
	}

	public void giveUp(MessageDrivenContext ctx, String msg,
			ResourceException rex) throws ResourceException {
		error(msg);
		log("status=flaggingTransactionForRollback");
		try {
			ctx.setRollbackOnly();
		} catch (Exception ex) {
			error("Failed to flag transaction for rollback: " + ex);
		}
		throw rex;
	}

	protected FlatFileInputStreamRecord getInputRecord(Record inputData)
			throws ResourceException {
		debug(" status=startingOfflineRecordProcessing inputData=" + inputData
				+ " recordName=" + inputData.getRecordName() + " recordDesc="
				+ inputData.getRecordShortDescription() + " recordClass="
				+ inputData.getClass());

		if (!(inputData instanceof FlatFileInputStreamRecord)) {
			throw new ResourceException(
					"Do not know how to handle record of type: "
							+ ((null != inputData) ? inputData.getClass()
									.getCanonicalName() : "null"));
		}
		FlatFileInputStreamRecord isr = (FlatFileInputStreamRecord) inputData;

		debug(" recordDirectory=" + isr.getDirectoryPath() + " recordFileName="
				+ isr.getFilename());
		return isr;
	}

	protected MessageDrivenContext getMDBContext() throws ResourceException {
		try {
			InitialContext ictx = new InitialContext();
			MessageDrivenContext ctx = (MessageDrivenContext) ictx
					.lookup("java:comp/EJBContext");
			debug("MDBContext=" + ctx);
			return ctx;
		} catch (Exception e) {
			error("Failed to get MDB context: " + e);
			e.printStackTrace();
			throw new ResourceException(e);
		}

	}

	protected Throwable drillToCause(Throwable ax, Class claz) {
		if (null == ax) {
			return null;
		}
		if (claz.isAssignableFrom(ax.getClass())) {
			return ax;
		}
		return drillToCause(ax.getCause(), claz);
	}

	public void getConfigContext() throws Exception {
		debug("getConfigContext() started");
		try {
			WASAxis2Service service = null;
			service = (WASAxis2Service) AccessController
					.doPrivileged(new PrivilegedAction() {
						public Object run() {
							try {
								return WsServiceRegistry.getService(this,
										WASAxis2Service.class);
							} catch (Exception e) {
								error("PrivilegedAction failed: "
										+ e.getMessage());
								throw new RuntimeException(e);
							}
						}

					});

			if (service != null) {
				debug("WASAxis2Service=" + service.toString());
				ServerModuleMetaData smmd = (ServerModuleMetaData) service
						.getModuleMetaData();
				debug("SMDD= " + smmd);
				if (smmd != null) {
					this.configContext = smmd.getConfigurationContext();
					debug("configContext=" + this.configContext.toString());
					// getPortComponentNames();
				} else {
					error("SMMD=null");
				}
			} else {
				error("WASAxis2Service=null ");
			}
			if (null == configContext) {
				throw new ResourceException(
						"failed to initialize ConfigContext");
			}

		} catch (ResourceException ex) {
			error("getConfigContext(): Exception: " + ex);
			throw ex;
		} catch (Exception ex) {
			error("getConfigContext(): Exception: " + ex);
			throw new ResourceException(ex);
		} finally {
			debug("getConfigContext() finished with "
					+ ((null == configContext) ? "failure" : "success"));

		}

	}

	/*
	 * public List getPortComponentNames() { log("getPortComponentNames()"); if
	 * (this.configContext != null) { this.jaxwsPortComponents = new
	 * ArrayList(); AxisConfiguration axisCfg =
	 * this.configContext.getAxisConfiguration(); Iterator svcGrpIter =
	 * axisCfg.getServiceGroups(); if (!(svcGrpIter.hasNext())) {
	 * log("No ServiceGroups"); } while (svcGrpIter.hasNext()) {
	 * AxisServiceGroup svcGrp = (AxisServiceGroup)svcGrpIter.next();
	 * log("serviceGroup: "
	 * +svcGrp.getServiceGroupName()+": "+svcGrp.getDocumentation()); Iterator
	 * svcIter = svcGrp.getServices(); if (!(svcIter.hasNext())) {
	 * log("No Service Groups"); } while (svcIter.hasNext()) { AxisService svc =
	 * (AxisService)svcIter.next(); log("service: "+svc.getName()
	 * +": "+svc.getDocumentation()); String portCompName =
	 * Axis2Utils.getPortComponentName(svc); if (portCompName != null) {
	 * log("Adding Port Component : " + portCompName);
	 * this.jaxwsPortComponents.add(portCompName); } else {
	 * log("service has no port "); } } } if
	 * (!(this.jaxwsPortComponents.isEmpty())) { log("jaxwsPortComponents : " +
	 * this.jaxwsPortComponents.toString()); } }
	 * log("getPortComponentNames() finished"); return this.jaxwsPortComponents;
	 * }
	 */

	protected MessageContext createMessageContext(byte[] bytes,
			ByteArrayOutputStream responseOstrm) throws AxisFault, OMException,
			XMLStreamException, FactoryConfigurationError, WSSecurityException {
		debug("state=creatingMessageContext");

		String contentType = "text/xml; charset=UTF-8";

		MessageContext msgContext = new MessageContext();
		msgContext.setConfigurationContext(this.configContext);
		msgContext.setIncomingTransportName("jms");
		AxisConfiguration axisConfiguration = this.configContext
				.getAxisConfiguration();
		if (axisConfiguration != null) {
			msgContext.setTransportIn(axisConfiguration.getTransportIn("jms"));
			msgContext
					.setTransportOut(axisConfiguration.getTransportOut("jms"));
		} else {
			error("state=createMessageContext axisConfiguration=null");
			throw new AxisFault("axis config is null");
		}

		msgContext.setProperty("CHARACTER_SET_ENCODING", "UTF-8");
		msgContext.setProperty("OutTransportInfo", null /*
														 * this.jmsOutTransportInfo
														 */);
		msgContext.setProperty(
				"com.ibm.ws.websvcs.INCOMING_SERVER_SIDE_REQUEST", new Boolean(
						true));
		msgContext.setProperty("ContentType", contentType);
		msgContext.setServerSide(true);

		msgContext.setReplyTo(new EndpointReference(
				AddressingConstants.Final.WSA_ANONYMOUS_URL));
		debug("state=createMessageContext replyTo=" + msgContext.getReplyTo());
		msgContext.setProperty("targetService", targetService);
		debug("state=createMessageContext targetService=" + targetService);
		msgContext.setFrom(new EndpointReference(
				"http://ws.apache.org/axis2/from"));
		debug("state=createMessageContext from=" + msgContext.getFrom());
		msgContext
				.setTo(new EndpointReference("http://ws.apache.org/axis2/to"));

		EndpointManagerMBean mbean = Axis2Utils
				.getEndpointManagerMBean(this.configContext);
		if (mbean != null) {
			Endpoint endpoint = mbean
					.getEndpointListenerWithPortComponentName(targetService);
			debug("state=createMessageContext endpoint=" + endpoint);
		}
		msgContext.setProperty("TRANSPORT_OUT", responseOstrm);

		// handleSoapAction( msgContext, this.soapAction);

		if (ContextManagerFactory.getInstance().isCellSecurityEnabled()) {
			debug("state=createMessageContext securityContext="
					+ ContextManager.getContext());
			msgContext.setProperty(
					"com.ibm.wsspi.websphere.security.SecurityContext",
					ContextManager.getContext());
		}

		debug("state=createMessageContext setting envelope");
		try {
			SOAPEnvelope envelope = TransportUtils.createSOAPMessage(
					msgContext, new ByteArrayInputStream(bytes), contentType);
			msgContext.setEnvelope(envelope);
		} catch (XMLStreamException xe) {
			error("Error reading the SOAP envelope: " + xe.getMessage());
			throw new AxisFault("OFFLINE ", xe.toString());
		} catch (Exception e) {
			error("Error setting envelope envelope: " + e.getMessage());
			throw new AxisFault("OFFLINE ", e.toString());
		}
		return msgContext;
	}

	/*
	 * private void handleSoapAction( MessageContext msgContext, String
	 * soapAction) { if ((soapAction == null) || (soapAction.length() == 0)) {
	 * log("Setting soapAction on MessageContext to: null");
	 * msgContext.setSoapAction(null); } else { if
	 * ((soapAction.startsWith("\"")) && (soapAction.endsWith("\""))) soapAction
	 * = soapAction.substring(1, soapAction.length() - 1);
	 * msgContext.setSoapAction(soapAction);
	 * log("Setting soapAction on MessageContext to: " + soapAction); } }
	 */

	@Override
	public Record onMessage(Record inputData) throws ResourceException {
		error("BnhpInboundMessageListener: GOT onMessage: " + inputData);
		// should never happen
		throw new ResourceException("NOT IMPLEMENTED");
	}

	public void log(String msg) {
		if (null == DfsRequestThreadAttributes.logger
				|| null == DfsRequestThreadAttributes.logger.get()) {
			System.out.println("instanceName=" + instanceName + msg
					+ " dctmRequestId="
					+ DfsRequestThreadAttributes.dctmRequestId.get()
					+ " threadid=" + Thread.currentThread().getName());

		} else {
			DfsRequestThreadAttributes.logger.get().info(instanceName, msg);
		}
	}

	public void debug(String msg) {
		if (null == DfsRequestThreadAttributes.logger
				|| null == DfsRequestThreadAttributes.logger.get()) {
			System.out.println("instanceName=" + instanceName + "level=DEBUG"
					+ msg + " dctmRequestId="
					+ DfsRequestThreadAttributes.dctmRequestId.get()
					+ " threadid=" + Thread.currentThread().getName());
		} else {
			DfsRequestThreadAttributes.logger.get().debug(instanceName, msg);
		}
	}

	public void error(String msg) {
		if (null == DfsRequestThreadAttributes.logger
				|| null == DfsRequestThreadAttributes.logger.get()) {
			System.out.println("instanceName=" + instanceName + "level=ERROR"
					+ msg + " dctmRequestId="
					+ DfsRequestThreadAttributes.dctmRequestId.get()
					+ " threadid=" + Thread.currentThread().getName());
		} else {
			DfsRequestThreadAttributes.logger.get().error(instanceName, msg);
		}
	}

	public void warn(String msg) {
		if (null == DfsRequestThreadAttributes.logger
				|| null == DfsRequestThreadAttributes.logger.get()) {
			System.out.println("instanceName=" + instanceName + "level=WARN"
					+ msg + " dctmRequestId="
					+ DfsRequestThreadAttributes.dctmRequestId.get()
					+ " threadid=" + Thread.currentThread().getName());
		} else {
			DfsRequestThreadAttributes.logger.get().warn(instanceName, msg);
		}
	}

	public enum SOAPEnvelopeAction {
		ADD_IF_MISSING("add_if_missing"), AS_IS("as_is");
		private String text;

		public static SOAPEnvelopeAction fromString(String str) {
			for (SOAPEnvelopeAction value : values()) {
				if (value.toString().toLowerCase().equals(str)) {
					return value;
				}
			}
			return null;
		}

		public String toString() {
			return text;
		}

		private SOAPEnvelopeAction(String name) {
			this.text = name;

		}
	}

	public enum ErrorAction {
		SAVE("save"), IGNORE("ignore"), GIVEUP("giveup");
		private String text;

		public static ErrorAction fromString(String str) {
			for (ErrorAction value : values()) {
				if (value.toString().toLowerCase().equals(str)) {
					return value;
				}
			}
			return null;
		}

		public String toString() {
			return text;
		}

		private ErrorAction(String name) {
			this.text = name;

		}
	}

}


file Read:C:\Users\AP068\git\documentum\duecmcustomerwrappers\OFFLINE\BnhpDFSWrapperOffline_JC2Router\ejbModule\META-INF\ejb-jar.xml
-----------------------------------------------------
<?xml version="1.0" encoding="UTF-8"?>
<ejb-jar xmlns="http://java.sun.com/xml/ns/javaee" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/ejb-jar_3_1.xsd" version="3.1">
		<display-name>BnhpDFSWrapperOffline_JC2Router</display-name>
	<enterprise-beans>
		<message-driven>
			<ejb-name>WebServicesJMSRouter</ejb-name>
			<ejb-class>bnhp.infra.dfs.services.BnhpInboundMessageListener</ejb-class>
			<transaction-type>Container</transaction-type>
			<message-destination-type>javax.jms.Queue</message-destination-type>
			<activation-config>
				<activation-config-property>
					<activation-config-property-name>destinationType</activation-config-property-name>
					<activation-config-property-value>javax.jms.Queue</activation-config-property-value>
				</activation-config-property>
			</activation-config>
			<env-entry>
				<description />
				<env-entry-name>propertiesFileName</env-entry-name>
				<env-entry-type>java.lang.String</env-entry-type>
				<env-entry-value>/BnhpDFSWrapper_JC2Router.properties</env-entry-value>
			</env-entry>
		</message-driven>
	</enterprise-beans>
</ejb-jar>


file Read:C:\Users\AP068\git\documentum\duecmcustomerwrappers\OFFLINE\BnhpDFSWrapperOffline_JC2Router\ejbModule\META-INF\ibm-ejb-jar-bnd.xml
-----------------------------------------------------
<?xml version="1.0" encoding="UTF-8"?>
<ejb-jar-bnd
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns="http://websphere.ibm.com/xml/ns/javaee"
    xsi:schemaLocation="http://websphere.ibm.com/xml/ns/javaee http://websphere.ibm.com/xml/ns/javaee/ibm-ejb-jar-bnd_1_1.xsd" version="1.1">
  <message-driven name="WebServicesJMSRouter">
    <jca-adapter activation-spec-binding-name="jms/duEcmFileListener"/>
  </message-driven>

</ejb-jar-bnd>



file Read:C:\Users\AP068\git\documentum\duecmcustomerwrappers\OFFLINE\BnhpDFSWrapperOffline_JC2Router\ejbModule\META-INF\ibm-ejb-jar-ext.xml
-----------------------------------------------------
<?xml version="1.0" encoding="UTF-8"?>
<ejb-jar-ext
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns="http://websphere.ibm.com/xml/ns/javaee"
    xsi:schemaLocation="http://websphere.ibm.com/xml/ns/javaee http://websphere.ibm.com/xml/ns/javaee/ibm-ejb-jar-ext_1_1.xsd" version="1.1">
	<message-driven name="WebServicesJMSRouter">
		<start-at-app-start value="true"/>
	</message-driven>
</ejb-jar-ext>



file Read:C:\Users\AP068\git\documentum\duecmcustomerwrappers\OFFLINE\BnhpDFSWrapperOffline_JC2Router\junit\bnhp\infra\dfs\services\BnhpInboundMessageListenerTest.java
-----------------------------------------------------
package bnhp.infra.dfs.services;

import java.io.File;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.OutputStream;
import java.io.UnsupportedEncodingException;
import java.util.Date;

import javax.resource.ResourceException;

import org.junit.Assert;
import org.junit.Test;

import bnhp.infra.dfs.services.BnhpInboundMessageListener.DataAnalysis;
import bnhp.infra.dfs.services.BnhpInboundMessageListener.SOAPEnvelopeAction;

public class BnhpInboundMessageListenerTest {
	
	public static final String testConfigFile  = "/BnhpDFSWrapper_JC2Router.properties";
	@Test
	public void initializationTest() throws ResourceException {
		BnhpInboundMessageListener instance = new BnhpInboundMessageListener();
		instance.setPropertiesFileName(testConfigFile);
		instance.initialize();
		System.out.println("initialized "+instance);
		
		Assert.assertNotNull(instance.defNamespaces);
		Assert.assertNotNull(instance.defPrefixes);
		Assert.assertEquals(instance.defPrefixes.size(),instance.defNamespaces.size());
		
	}
	
	@Test
	public void matchErrorDirTest() throws IOException, ResourceException {
		BnhpInboundMessageListener instance = new BnhpInboundMessageListener();
		instance.setPropertiesFileName(testConfigFile);
		instance.initialize();
		File []inputDirs = instance.inputDirs;
		File []errorsDirs = instance.errorDirs;
		Assert.assertTrue(inputDirs.length>0);
		
		for (int i = 0; i < inputDirs.length; i++ ) {
			Assert.assertNotNull(inputDirs[i]);
			Assert.assertTrue(inputDirs[i].exists());
			Assert.assertTrue(inputDirs[i].isDirectory());
			File matched = testMatchDir(instance, inputDirs[i]);
			Assert.assertEquals(errorsDirs[i],matched);
		}
	}

	@Test
	public void moveErrorDirTest() throws IOException, ResourceException {
		BnhpInboundMessageListener instance = new BnhpInboundMessageListener();
		instance.setPropertiesFileName(testConfigFile);
		instance.initialize();
		File []inputDirs = instance.inputDirs;
		File []errorsDirs = instance.errorDirs;
		Assert.assertTrue(inputDirs.length>0);
		
		for (int i = 0; i < inputDirs.length; i++ ) {
			Assert.assertNotNull(inputDirs[i]);
			Assert.assertTrue(inputDirs[i].exists());
			Assert.assertTrue(inputDirs[i].isDirectory());
			File matched = testMatchDir(instance, inputDirs[i]);
			File testFile = File.createTempFile("test-move-file-", ".test.xml",inputDirs[i]);
			Date ts = new Date();
			
			File copyFile = instance.produceOutFileName(instance.errorFilePattern,
					matched, testFile, ts);
			System.out.println("Input file is: "+testFile);
			System.out.println("Archived file mustBe: "+copyFile);
			Assert.assertNotNull(copyFile);
			Assert.assertFalse(copyFile.exists());
			Assert.assertTrue(copyFile.getAbsolutePath().startsWith(matched.getAbsolutePath()));
			Assert.assertTrue(copyFile.getAbsolutePath().contains(testFile.getName()));
			Assert.assertFalse(copyFile.getAbsolutePath().equals(testFile.getAbsolutePath()));
			
			OutputStream os = new FileOutputStream(testFile);
			testFile.deleteOnExit();
			byte [] testData = ("TEST"+ System.currentTimeMillis()+this).getBytes();
			os.write(testData);
			os.flush();
			os.close();
			File targetRootDir = instance.matchOutputDir(testFile, instance.errorDirs);
			Assert.assertNotNull(targetRootDir);
			Assert.assertTrue(targetRootDir.isDirectory());
			instance.moveToDir(testFile, ts, targetRootDir, instance.errorFilePattern);
			Assert.assertTrue(testFile.exists());
			Assert.assertTrue(copyFile.exists());
			copyFile.deleteOnExit();
			Assert.assertEquals(testFile.length(), copyFile.length());
			byte []copiedData = readBytes(copyFile);
			Assert.assertArrayEquals(testData, copiedData);
		}
	}
	
	private byte[] readBytes(File copyFile) throws IOException {
		byte []bytes = new byte[(int)copyFile.length()];
		FileInputStream is = new FileInputStream(copyFile);
		is.read(bytes);
		is.close();
		return bytes;
	}

	private File testMatchDir(BnhpInboundMessageListener instance, File dir) throws IOException, ResourceException {
		System.out.println("testMatchForDir "+dir);
		File testFile = File.createTempFile("test-match-dir", ".test.xml",dir);
		dir = instance.matchOutputDir(testFile, instance.errorDirs);
		System.out.println("matched dir: "+dir);
		Assert.assertNotNull(dir);
		Assert.assertTrue(dir.exists());
		Assert.assertTrue(dir.isDirectory());
		Assert.assertTrue(dir.isDirectory());
		return dir;
	}
	
	@Test
	public void testBytesMatchEnvelope() throws ResourceException, UnsupportedEncodingException {
		BnhpInboundMessageListener instance = new BnhpInboundMessageListener();
		instance.setPropertiesFileName(testConfigFile);
		instance.initialize();
		if (null == instance.xmlInputFactory) {
			instance.soapEnvelopeAction=SOAPEnvelopeAction.ADD_IF_MISSING;
			instance.initSoapHeaderProcessing();
		}
		Assert.assertNotNull(instance.xmlInputFactory);
		
		String []yes = {" <SOAP:Envelope></SOAP:Envelope>",
				"<?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"no\"?><SOAP:Envelope><foo/></SOAP:Envelope>", 
				" <soap:envelope><foo/></soap:envelope>",
				" <soap:envelope/>",
				" <env11000_222_eee-ee.e:EnVeLoPe></env11000_222_eee-ee.e:EnVeLoPe>",
				"    <env11000_222_eee-ee.e:EnVeLoPe aaaa=\"sss\"><foo/></env11000_222_eee-ee.e:EnVeLoPe>",
				"<?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"no\"?><envelope></envelope>",
				" <:envelope>"
		};
		String []no = {"<SOAP:Envilope><foo/></SOAP:Envilope>",
				"<foo><SOAP:Envelope><bar></bar></SOAP:Envelope></foo>",
		};
		String []fail = {"RANDOM JUNK \n\nIS HERE \n\n", "",
				"                 ",
				"\n\n\n\r\n"};
		
		for (String str: yes) {
			byte[] bytes = str.getBytes("UTF-8");
			System.out.println("should match:"+str);
			DataAnalysis result = instance.analyzeData(bytes);
			Assert.assertTrue(result.success);
			Assert.assertTrue(result.hasEnvelope);
			Assert.assertTrue(result.startDocumentOffset>=0);
			if (result.startDocumentOffset>=0) {
				System.out.println("position is "+result.startDocumentOffset +" value="+((char)bytes[result.startDocumentOffset])+ " char="+str.charAt(result.startDocumentOffset));
			}
			//Assert.assertEquals('<',(char)bytes[result.startDocumentOffset]);
			//Asse
		}
		for (String str: no) {
			byte[] bytes = str.getBytes("UTF-8");
			System.out.println("should not match "+str);
			DataAnalysis result = instance.analyzeData(bytes);
			Assert.assertTrue(result.success);
			Assert.assertFalse(result.hasEnvelope);
		}
		for (String str: fail) {
			byte[] bytes = str.getBytes("UTF-8");
			System.out.println("should not match "+str);
			DataAnalysis result = instance.analyzeData(bytes);
			Assert.assertFalse(result.success);
		}
	}
	
	@Test
	public void testHandleSOAPEnvelope() throws ResourceException, UnsupportedEncodingException {
		BnhpInboundMessageListener instance = new BnhpInboundMessageListener();
		instance.setPropertiesFileName(testConfigFile);
		instance.initialize();
		if (null == instance.xmlInputFactory) {
			instance.soapEnvelopeAction=SOAPEnvelopeAction.ADD_IF_MISSING;
			instance.initSoapHeaderProcessing();
		}
		
		String keep[] = {
				"<SOAP:Envelope><foo/></SOAP:Envelope>",
				"<?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"no\"?><SOAP:Envelope><foo/></SOAP:Envelope>"
		};
		String add[][] = {
				{"","<foo xmlns=\"http://somewhere\"><bar/></foo>"},
				{"<?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"no\"?>","<foo xmlns=\"http://somewhere\"><bar/></foo>"}
		};
		String addWithNS[][] = {
				{"<?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"no\"?>","<ns1:foo xmlns:ns1=\"http://somewhere\"><bar/></ns1:foo>"},
				{"<?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"no\"?>","<foo xmlns=\"http://somewhere\"><bar/></foo>"},
				{"","<foo xmlns=\"http://somewhere\"><bar/></foo>"}
		};
		
		String addNoNS[][] = {
				{"","<createDocuments><bar/></createDocuments>"},
				{"","<createDocuments  ><bar/></createDocuments>"},
				{"<?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"no\"?>","<createDocuments><bar/></createDocuments>"}
		};
		
		for (String str: keep) {
			System.out.println(" INPUT: "+str);
			byte[] in = str.getBytes("UTF-8");
			
			DataAnalysis an = instance.analyzeData(in);
			System.out.println(" ANALYSIS: "+an);
			Assert.assertTrue(an.success);
			Assert.assertTrue(an.hasEnvelope);
			
			byte []out = instance.handleSOAPEnvelope(in);
			Assert.assertArrayEquals(in,out);
		}
		for (String str[]: add) {
			String inStr = str[0] + str[1];
			System.out.println(" INPUT: "+inStr);
			byte[] in = inStr.getBytes("UTF-8");
			
			DataAnalysis an = instance.analyzeData(in);
			System.out.println(" ANALYSIS: "+an);
			Assert.assertTrue(an.success);
			Assert.assertFalse(an.hasEnvelope);
						
			
			byte []out = instance.handleSOAPEnvelope(in);
			String strOut = new String(out);
			
			System.out.println("OUTPUT: "+strOut);
			Assert.assertTrue(out.length > in.length);
			
			Assert.assertTrue(strOut.contains("<soap:Envelope"));
			String testStrOut = str[0]+(new String(instance.soapPrefix)) + 
			str[1]+(new String(instance.soapSuffix));
			Assert.assertEquals(testStrOut,strOut);
		}
		for (String str[]: addWithNS) {
			String inStr = str[0] + str[1];
			System.out.println(" INPUT: "+inStr);
			byte[] in = inStr.getBytes("UTF-8");
			
			DataAnalysis an = instance.analyzeData(in);
			System.out.println(" ANALYSIS: "+an);
			Assert.assertFalse(an.hasEnvelope);
			Assert.assertTrue(an.methodHasXMLNS);
			Assert.assertTrue(an.success);
			
			Assert.assertNotNull(an.startElementName);
			Assert.assertTrue(an.startDocumentOffset>=0);
			Assert.assertTrue(an.endFirstElementOffset>an.startDocumentOffset);
			
			Assert.assertNull(instance.getNamespaceAttr(in, an));
			
			byte []out = instance.handleSOAPEnvelope(in);
			String strOut = new String(out);
			System.out.println("OUTPUT: "+strOut);
			Assert.assertTrue(out.length > in.length);
			
			Assert.assertTrue(strOut.contains("<soap:Envelope"));
			String testStrOut = str[0]+(new String(instance.soapPrefix)) + 
			str[1]+(new String(instance.soapSuffix));
			Assert.assertEquals(testStrOut,strOut);
		}
		for (String str[]: addNoNS) {
			String inStr = str[0] + str[1];
			System.out.println(" INPUT: "+inStr);
			byte[] in = inStr.getBytes("UTF-8");
			
			DataAnalysis an = instance.analyzeData(in);
			System.out.println(" ANALYSIS: "+an);
			Assert.assertFalse(an.hasEnvelope);
			Assert.assertFalse(an.methodHasXMLNS);
			Assert.assertTrue(an.success);
			
			Assert.assertNotNull(an.startElementName);
			Assert.assertTrue(an.startDocumentOffset>=0);
			Assert.assertTrue(an.endFirstElementOffset>an.startDocumentOffset);
			
			byte[] nsattrBytes = instance.getNamespaceAttr(in,an);
			Assert.assertNotNull(nsattrBytes);
			String nsattr = new String(nsattrBytes,"UTF-8");
			System.out.println(" ADD NAMESPACE: "+nsattr);
			Assert.assertTrue(nsattr.startsWith(" xmlns:ns1=\"http://"));
			
			byte []out = instance.handleSOAPEnvelope(in);
			String strOut = new String(out);
			System.out.println("OUTPUT: "+strOut);
			Assert.assertTrue(out.length > in.length);
			
			Assert.assertTrue(strOut.contains("<soap:Envelope"));
			String testStrOut = str[0]+(new String(instance.soapPrefix)) + 
			(str[1].replaceAll("<(createDocuments *)>","<ns1:$1 xmlns:ns1=\"http://bnhp.infra.services.com\">")
			.replaceAll("</(createDocuments *)>","</ns1:$1>"))
			+(new String(instance.soapSuffix));
			System.out.println("MUST BE: "+testStrOut);
			Assert.assertEquals(testStrOut,strOut);
		}
		
	}
}


file Read:C:\Users\AP068\git\documentum\duecmcustomerwrappers\OFFLINE\BnhpDFSWrapperOffline_JC2Router\pom.xml
-----------------------------------------------------
<?xml version="1.0" encoding="UTF-8"?>

<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
	<modelVersion>4.0.0</modelVersion>
	
	<parent>
		<groupId>com.poalim.documentum</groupId>
		<artifactId>parent</artifactId>
		<version>1.0-SNAPSHOT</version>
	</parent>
	
	<artifactId>BnhpDFSWrapperOffline_JC2Router</artifactId>
	<packaging>ejb</packaging>
	<name>BnhpDFSWrapperOffline_JC2Router</name>
	<description>BnhpDFSWrapperOffline_JC2Router</description>		
	
	<dependencies>					
			<dependency>
				<groupId>junit</groupId>
				<artifactId>junit</artifactId>
			</dependency>								
			<dependency>
				<groupId>was</groupId>
				<artifactId>j2ee</artifactId>
				<scope>provided</scope>
			</dependency>
			
			<dependency>
				<groupId>was</groupId>
				<artifactId>jaxws_thinclient</artifactId>
				<scope>provided</scope>
			</dependency>						
		
			<dependency>
				<groupId>websphere</groupId>
				<artifactId>com.ibm.ws.runtime</artifactId>
				<scope>provided</scope>
			</dependency>
			
			<dependency>
				<groupId>com.ibm</groupId>
				<artifactId>commonj.connector</artifactId>
				<scope>provided</scope>
			</dependency>
			
			<dependency>
				<groupId>com.poalim.documentum</groupId>
				<artifactId>BnhpWrapperDependencyModule</artifactId>				
			</dependency>
			
			<dependency>
				<groupId>com.ibm.j2ca.flatfile</groupId>
				<artifactId>CWYFF_FlatFile</artifactId>				
			</dependency>
			
				<dependency>
				<groupId>com.ibm.j2ca.flatfile</groupId>
				<artifactId>DESPI</artifactId>				
			</dependency>
		
			
			<dependency>
				<groupId>com.ibm.j2ca.base</groupId>
				<artifactId>CWYBS_AdapterFoundation</artifactId>				
			</dependency>
		
	</dependencies>						
	
	<build>						
		<sourceDirectory>ejbModule</sourceDirectory>
		<testSourceDirectory>junit</testSourceDirectory>
		<testResources>
			<testResource>
				<directory>test/resources</directory>
			</testResource>
		</testResources>
		
		<resources>
			<resource>
				<directory>ejbModule</directory>
				<excludes>
					<exclude>**/*.java</exclude>
					<exclude>**/.copyarea.db</exclude>
				</excludes>
			</resource>
		</resources>
		<plugins>
		<plugin>
				<groupId>org.apache.maven.plugins</groupId>
				<artifactId>maven-surefire-plugin</artifactId>
				<version>2.7.2</version>
				<configuration>
					<skipTests>true</skipTests>
					<useFile>false</useFile>
				</configuration>
		</plugin>
		</plugins>				
	</build>
	
	
</project>


file Read:C:\Users\AP068\git\documentum\duecmcustomerwrappers\OFFLINE\BnhpDFSWrapperOffline_JC2Router\target\classes\META-INF\ejb-jar.xml
-----------------------------------------------------
<?xml version="1.0" encoding="UTF-8"?>
<ejb-jar xmlns="http://java.sun.com/xml/ns/javaee" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/ejb-jar_3_1.xsd" version="3.1">
		<display-name>BnhpDFSWrapperOffline_JC2Router</display-name>
	<enterprise-beans>
		<message-driven>
			<ejb-name>WebServicesJMSRouter</ejb-name>
			<ejb-class>bnhp.infra.dfs.services.BnhpInboundMessageListener</ejb-class>
			<transaction-type>Container</transaction-type>
			<message-destination-type>javax.jms.Queue</message-destination-type>
			<activation-config>
				<activation-config-property>
					<activation-config-property-name>destinationType</activation-config-property-name>
					<activation-config-property-value>javax.jms.Queue</activation-config-property-value>
				</activation-config-property>
			</activation-config>
			<env-entry>
				<description />
				<env-entry-name>propertiesFileName</env-entry-name>
				<env-entry-type>java.lang.String</env-entry-type>
				<env-entry-value>/BnhpDFSWrapper_JC2Router.properties</env-entry-value>
			</env-entry>
		</message-driven>
	</enterprise-beans>
</ejb-jar>


file Read:C:\Users\AP068\git\documentum\duecmcustomerwrappers\OFFLINE\BnhpDFSWrapperOffline_JC2Router\target\classes\META-INF\ibm-ejb-jar-bnd.xml
-----------------------------------------------------
<?xml version="1.0" encoding="UTF-8"?>
<ejb-jar-bnd
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns="http://websphere.ibm.com/xml/ns/javaee"
    xsi:schemaLocation="http://websphere.ibm.com/xml/ns/javaee http://websphere.ibm.com/xml/ns/javaee/ibm-ejb-jar-bnd_1_1.xsd" version="1.1">
  <message-driven name="WebServicesJMSRouter">
    <jca-adapter activation-spec-binding-name="jms/duEcmFileListener"/>
  </message-driven>

</ejb-jar-bnd>



file Read:C:\Users\AP068\git\documentum\duecmcustomerwrappers\OFFLINE\BnhpDFSWrapperOffline_JC2Router\target\classes\META-INF\ibm-ejb-jar-ext.xml
-----------------------------------------------------
<?xml version="1.0" encoding="UTF-8"?>
<ejb-jar-ext
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns="http://websphere.ibm.com/xml/ns/javaee"
    xsi:schemaLocation="http://websphere.ibm.com/xml/ns/javaee http://websphere.ibm.com/xml/ns/javaee/ibm-ejb-jar-ext_1_1.xsd" version="1.1">
	<message-driven name="WebServicesJMSRouter">
		<start-at-app-start value="true"/>
	</message-driven>
</ejb-jar-ext>



file Read:C:\Users\AP068\git\documentum\duecmcustomerwrappers\OFFLINE\BnhpDFSWrapperOffline_JC2Router\target\classes\META-INF\maven\com.poalim.documentum\BnhpDFSWrapperOffline_JC2Router\pom.properties
-----------------------------------------------------
#Generated by Maven Integration for Eclipse
#Wed Jun 09 16:03:22 IDT 2021
m2e.projectLocation=C\:\\Users\\AP068\\git\\documentum\\duecmcustomerwrappers\\OFFLINE\\BnhpDFSWrapperOffline_JC2Router
m2e.projectName=BnhpDFSWrapperOffline_JC2Router
groupId=com.poalim.documentum
artifactId=BnhpDFSWrapperOffline_JC2Router
version=1.0-SNAPSHOT


file Read:C:\Users\AP068\git\documentum\duecmcustomerwrappers\OFFLINE\BnhpDFSWrapperOffline_JC2Router\target\classes\META-INF\maven\com.poalim.documentum\BnhpDFSWrapperOffline_JC2Router\pom.xml
-----------------------------------------------------
<?xml version="1.0" encoding="UTF-8"?>

<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
	<modelVersion>4.0.0</modelVersion>
	
	<parent>
		<groupId>com.poalim.documentum</groupId>
		<artifactId>parent</artifactId>
		<version>1.0-SNAPSHOT</version>
	</parent>
	
	<artifactId>BnhpDFSWrapperOffline_JC2Router</artifactId>
	<packaging>ejb</packaging>
	<name>BnhpDFSWrapperOffline_JC2Router</name>
	<description>BnhpDFSWrapperOffline_JC2Router</description>		
	
	<dependencies>					
			<dependency>
				<groupId>junit</groupId>
				<artifactId>junit</artifactId>
			</dependency>								
			<dependency>
				<groupId>was</groupId>
				<artifactId>j2ee</artifactId>
				<scope>provided</scope>
			</dependency>
			
			<dependency>
				<groupId>was</groupId>
				<artifactId>jaxws_thinclient</artifactId>
				<scope>provided</scope>
			</dependency>						
		
			<dependency>
				<groupId>websphere</groupId>
				<artifactId>com.ibm.ws.runtime</artifactId>
				<scope>provided</scope>
			</dependency>
			
			<dependency>
				<groupId>com.ibm</groupId>
				<artifactId>commonj.connector</artifactId>
				<scope>provided</scope>
			</dependency>
			
			<dependency>
				<groupId>com.poalim.documentum</groupId>
				<artifactId>BnhpWrapperDependencyModule</artifactId>				
			</dependency>
			
			<dependency>
				<groupId>com.ibm.j2ca.flatfile</groupId>
				<artifactId>CWYFF_FlatFile</artifactId>				
			</dependency>
			
				<dependency>
				<groupId>com.ibm.j2ca.flatfile</groupId>
				<artifactId>DESPI</artifactId>				
			</dependency>
		
			
			<dependency>
				<groupId>com.ibm.j2ca.base</groupId>
				<artifactId>CWYBS_AdapterFoundation</artifactId>				
			</dependency>
		
	</dependencies>						
	
	<build>						
		<sourceDirectory>ejbModule</sourceDirectory>
		<testSourceDirectory>junit</testSourceDirectory>
		<testResources>
			<testResource>
				<directory>test/resources</directory>
			</testResource>
		</testResources>
		
		<resources>
			<resource>
				<directory>ejbModule</directory>
				<excludes>
					<exclude>**/*.java</exclude>
					<exclude>**/.copyarea.db</exclude>
				</excludes>
			</resource>
		</resources>
		<plugins>
		<plugin>
				<groupId>org.apache.maven.plugins</groupId>
				<artifactId>maven-surefire-plugin</artifactId>
				<version>2.7.2</version>
				<configuration>
					<skipTests>true</skipTests>
					<useFile>false</useFile>
				</configuration>
		</plugin>
		</plugins>				
	</build>
	
	
</project>


file Read:C:\Users\AP068\git\documentum\duecmcustomerwrappers\OFFLINE\BnhpDFSWrapperOffline_JC2Router\target\test-classes\BnhpDFSWrapper_JC2Router.properties
-----------------------------------------------------

offline_input_dirs=test/Offline_Service_DEV/Mesila/,test/Offline_Service_DEV/Ikulim/,test/Offline_Service_DEV/Faxes/
offline_errors_dirs=test/Offline_Service_DEV_ERRORS/Mesila/,test/Offline_Service_DEV_ERRORS/Ikulim/,test/Offline_Service_DEV_ERRORS/Faxes/
offline_archive_dirs=test/Offline_Service_DEV_ARCHIVED/Mesila/,test/Offline_Service_DEV_ARCHIVED/Ikulim/,test/Offline_Service_DEV_ARCHIVED/Faxes/

offline_gen_error_action=ignore

offline_target_service=DocumentumServicesJmsWrapper
offline_instance_name=OfflineLoader1

offline_def_namespace_createDocuments=xmlns:ns1="http://bnhp.infra.services.com"
offline_def_namespace_updateDocumentsByDctmDocumentId=xmlns:ns1="http://bnhp.infra.services.com"
offline_def_namespace_updateDocumentsByLegacyDocumentId=xmlns:ns1="http://bnhp.infra.services.com"
offline_def_namespace_updateDocumentVersionByLegacyDocumentId=xmlns:ns1="http://bnhp.infra.services.com"
offline_def_namespace_updateDocumentVersionByDctmDocumentId=xmlns:ns1="http://bnhp.infra.services.com"



file Read:C:\Users\AP068\git\documentum\duecmcustomerwrappers\OFFLINE\BnhpDFSWrapperOffline_JC2Router\test\resources\BnhpDFSWrapper_JC2Router.properties
-----------------------------------------------------

offline_input_dirs=test/Offline_Service_DEV/Mesila/,test/Offline_Service_DEV/Ikulim/,test/Offline_Service_DEV/Faxes/
offline_errors_dirs=test/Offline_Service_DEV_ERRORS/Mesila/,test/Offline_Service_DEV_ERRORS/Ikulim/,test/Offline_Service_DEV_ERRORS/Faxes/
offline_archive_dirs=test/Offline_Service_DEV_ARCHIVED/Mesila/,test/Offline_Service_DEV_ARCHIVED/Ikulim/,test/Offline_Service_DEV_ARCHIVED/Faxes/

offline_gen_error_action=ignore

offline_target_service=DocumentumServicesJmsWrapper
offline_instance_name=OfflineLoader1

offline_def_namespace_createDocuments=xmlns:ns1="http://bnhp.infra.services.com"
offline_def_namespace_updateDocumentsByDctmDocumentId=xmlns:ns1="http://bnhp.infra.services.com"
offline_def_namespace_updateDocumentsByLegacyDocumentId=xmlns:ns1="http://bnhp.infra.services.com"
offline_def_namespace_updateDocumentVersionByLegacyDocumentId=xmlns:ns1="http://bnhp.infra.services.com"
offline_def_namespace_updateDocumentVersionByDctmDocumentId=xmlns:ns1="http://bnhp.infra.services.com"



file Read:C:\Users\AP068\git\documentum\duecmcustomerwrappers\README.md
-----------------------------------------------------
### Repository description

This repo contains all the projects that are needed to run DuEcmCustomer
on IBM Websphere as ESB or OFFLINE service


```
BUILDING: TBD
```


file Read:C:\Users\AP068\git\documentum\duecmcustomerwrappers\scripts\makewsdl_for_saf.sh
-----------------------------------------------------
#!/bin/bash

WSDLDIR=/usr/TDC/WebSphere/AppServer/profiles/AppSrv01/temp/wscache/BnhpDFSWrapperEAR/BnhpDFSWrapper-1.0-SNAPSHOT.jar/bnhp.infra.dfs.services.DocumentumServicesJmsWrapper
ARCHIVENAME=`basename ${WSDLDIR}`-`hostname`-`date +%F_%T | tr : .`.zip
TMPDIR=`mktemp -d` || exit 2
TARGETDIR=`pwd`
echo using temporary directory $TMPDIR
cd $WSDLDIR || exit 2
for i in *.xsd *.wsdl
do
	cd ${TMPDIR} || exit 2
	SRCFILE=$i.tmp
	cp ${WSDLDIR}/$i ./$SRCFILE

#	if fgrep 'ref="tns:BHPeulaSearchYomanGroupsReturnList"' $SRCFILE >/dev/null; then
#		echo fixing BHPeulaSearchYomanGroupsReturnList
#		TMPFILE=${SRCFILE}.tmp
#		sed -e 's/ref="tns:BHPeulaSearchYomanGroupsReturnList"/name="BHPeulaSearchYomanGroupsReturnList" type="ns5:BHPeulaSearchYomanGroupsReturnList"/g' < ${SRCFILE}  >${TMPFILE}
#		SRCFILE=${TMPFILE}
#	fi
#	if fgrep 'ref="tns:BHPeulaSearchYomanDocumentsReturnList"' $SRCFILE >/dev/null; then
#                echo fixing BHPeulaSearchYomanDocumentsReturnList
#		TMPFILE=${SRCFILE}.tmp
#		sed -e 's/ref="tns:BHPeulaSearchYomanDocumentsReturnList"/name="BHPeulaSearchYomanDocumentsReturnList" type="ns5:BHPeulaSearchYomanDocumentsReturnList"/g' <${SRCFILE} >${TMPFILE}
#                SRCFILE=${TMPFILE}
#	fi
	if grep '<xs:complexType name="clntV2">' $SRCFILE >/dev/null; then
		echo fixing clntV2 type
        	TMPFILE=${SRCFILE}.tmp
		sed -e '/<xs:complexType name="clntV2">/,+2d'  <${SRCFILE} >${TMPFILE}
		SRCFILE=${TMPFILE}
	fi
	if grep '<xs:complexType name="clntV3">' $SRCFILE >/dev/null; then
		echo fixing clntV3 type
        	TMPFILE=${SRCFILE}.tmp
		sed -e '/<xs:complexType name="clntV3">/,+1c<xs:complexType name="clntV3"><xs:complexContent><xs:restriction base="xs:anyType"\/><\/xs:complexContent>'  <${SRCFILE} >${TMPFILE}
		SRCFILE=${TMPFILE}
	fi
	if grep 'element name="clntV2"' $SRCFILE >/dev/null; then
                echo fixing clntV2
        	TMPFILE=${SRCFILE}.tmp
		sed -e '/^.*\(element \+name="clntV2".*minOccurs="\)0.*$/d' <${SRCFILE} >${TMPFILE}
                SRCFILE=${TMPFILE}
	fi
	if grep 'element name="clntV3"' $SRCFILE >/dev/null; then
                echo fixing clntV3
        	TMPFILE=${SRCFILE}.tmp
		sed -e 's/\(element \+name="clntV3".*minOccurs="\)0/\11" nillable="true/g' <${SRCFILE} >${TMPFILE}
                SRCFILE=${TMPFILE}
	fi
	if grep 'xs:element name="date" type="xs:anySimpleType"' $SRCFILE >/dev/null; then
                echo fixing xs:anySimpleType for date
        	TMPFILE=${SRCFILE}.tmp
		sed -e 's/xs:element name="date" type="xs:anySimpleType"/xs:element name="date" type="xs:dateTime"/g' <${SRCFILE} >${TMPFILE}
                SRCFILE=${TMPFILE}
	fi
	if grep 'element name="requestDetails"' $SRCFILE >/dev/null; then
                echo fixing requestDetails
		TMPFILE=${SRCFILE}.tmp
		sed -e 's/\(element \+name="requestDetails".*type="ns[0-9]\+:requestDetails".*maxOccurs="\)unbounded/\11/g' <${SRCFILE} >${TMPFILE}
                SRCFILE=${TMPFILE}
	fi
	if grep 'element name="DocIdDataFault"' $SRCFILE >/dev/null; then
                echo fixing DocIdDataFault
		TMPFILE=${SRCFILE}.tmp
		sed -e 's/\(element \+name="DocIdDataFault".*\) type="xs:anyType"/\1 type="tns:ecmFaultDetails"/g' <${SRCFILE} >${TMPFILE}
		cp ${SRCFILE} ~/s
		cp ${TMPFILE} ~/t
                SRCFILE=${TMPFILE}
	fi
	if fgrep 'REPLACE_WITH_ACTUAL_URL' $SRCFILE >/dev/null; then
                echo fixing REPLACE_WITH_ACTUAL_URL
		TMPFILE=${SRCFILE}.tmp
		sed -e 's/REPLACE_WITH_ACTUAL_URL/jms:\/queueName=DU.DOCUMENTUM.SERVICES.ECM.REQUEST\&amp;targetService=DocumentumServicesJmsWrapper/g' <${SRCFILE} >${TMPFILE}
                SRCFILE=${TMPFILE}
	fi
	mv -v $SRCFILE $i
	rm -fv ./*.tmp
done
cd ${TMPDIR} || exit2
echo Output file: ${TARGETDIR}/${ARCHIVENAME}
rm -f ${TARGETDIR}/${ARCHIVENAME}
cd ${TMPDIR} || exit 2
zip ${TARGETDIR}/${ARCHIVENAME} * || exit 2
rm ${TMPDIR}/*
rmdir ${TMPDIR}
total files:118
